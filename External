--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

-- Instances: 484 | Scripts: 53 | Modules: 25 | Tags: 0
local G2L = {};

-- StarterGui.SSWorks
G2L["1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"));
G2L["1"]["IgnoreGuiInset"] = true;
G2L["1"]["ScreenInsets"] = Enum.ScreenInsets.DeviceSafeInsets;
G2L["1"]["Name"] = [[SSWorks]];
G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;
G2L["1"]["ResetOnSpawn"] = false;


-- StarterGui.SSWorks.Modules
G2L["2"] = Instance.new("Folder", G2L["1"]);
G2L["2"]["Name"] = [[Modules]];


-- StarterGui.SSWorks.Modules.NotificationAPI
G2L["3"] = Instance.new("ModuleScript", G2L["2"]);
G2L["3"]["Name"] = [[NotificationAPI]];


-- StarterGui.SSWorks.Modules.NotificationAPI.Template
G2L["4"] = Instance.new("CanvasGroup", G2L["3"]);
G2L["4"]["GroupTransparency"] = 1;
G2L["4"]["BorderSizePixel"] = 0;
G2L["4"]["BackgroundColor3"] = Color3.fromRGB(45, 64, 108);
G2L["4"]["Size"] = UDim2.new(0, 363, 0, 53);
G2L["4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4"]["Name"] = [[Template]];


-- StarterGui.SSWorks.Modules.NotificationAPI.Template.UICorner
G2L["5"] = Instance.new("UICorner", G2L["4"]);
G2L["5"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Modules.NotificationAPI.Template.UIStroke
G2L["6"] = Instance.new("UIStroke", G2L["4"]);
G2L["6"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["6"]["Color"] = Color3.fromRGB(87, 123, 209);


-- StarterGui.SSWorks.Modules.NotificationAPI.Template.Title
G2L["7"] = Instance.new("TextLabel", G2L["4"]);
G2L["7"]["TextWrapped"] = true;
G2L["7"]["BorderSizePixel"] = 0;
G2L["7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7"]["TextSize"] = 14;
G2L["7"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["7"]["TextColor3"] = Color3.fromRGB(106, 151, 255);
G2L["7"]["BackgroundTransparency"] = 1;
G2L["7"]["Size"] = UDim2.new(0, 343, 0, 9);
G2L["7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7"]["Text"] = [[Key]];
G2L["7"]["Name"] = [[Title]];
G2L["7"]["Position"] = UDim2.new(0.03182, 0, 0.13636, 0);


-- StarterGui.SSWorks.Modules.NotificationAPI.Template.Message
G2L["8"] = Instance.new("TextLabel", G2L["4"]);
G2L["8"]["TextWrapped"] = true;
G2L["8"]["BorderSizePixel"] = 0;
G2L["8"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["8"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8"]["TextSize"] = 12;
G2L["8"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8"]["TextColor3"] = Color3.fromRGB(106, 151, 255);
G2L["8"]["BackgroundTransparency"] = 1;
G2L["8"]["Size"] = UDim2.new(0, 343, 0, 28);
G2L["8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["Text"] = [[Your key was accepted successfully]];
G2L["8"]["Name"] = [[Message]];
G2L["8"]["Position"] = UDim2.new(0.03182, 0, 0.34091, 0);


-- StarterGui.SSWorks.Modules.BModule
G2L["9"] = Instance.new("ModuleScript", G2L["2"]);
G2L["9"]["Name"] = [[BModule]];


-- StarterGui.SSWorks.Modules.KeyAPI
G2L["a"] = Instance.new("ModuleScript", G2L["2"]);
G2L["a"]["Name"] = [[KeyAPI]];


-- StarterGui.SSWorks.Modules.AIModule
G2L["b"] = Instance.new("ModuleScript", G2L["2"]);
G2L["b"]["Name"] = [[AIModule]];


-- StarterGui.SSWorks.Modules.AIModule.Holder
G2L["c"] = Instance.new("Frame", G2L["b"]);
G2L["c"]["BorderSizePixel"] = 0;
G2L["c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c"]["Size"] = UDim2.new(0, 211, 0, 41);
G2L["c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c"]["Name"] = [[Holder]];
G2L["c"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Modules.AIModule.Holder.Main
G2L["d"] = Instance.new("Frame", G2L["c"]);
G2L["d"]["BorderSizePixel"] = 0;
G2L["d"]["BackgroundColor3"] = Color3.fromRGB(46, 100, 226);
G2L["d"]["Size"] = UDim2.new(0, 174, 0, 41);
G2L["d"]["Position"] = UDim2.new(0.14218, 0, 0, 0);
G2L["d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d"]["Name"] = [[Main]];


-- StarterGui.SSWorks.Modules.AIModule.Holder.Main.UICorner
G2L["e"] = Instance.new("UICorner", G2L["d"]);



-- StarterGui.SSWorks.Modules.AIModule.Holder.Main.ImageLabel
G2L["f"] = Instance.new("ImageLabel", G2L["d"]);
G2L["f"]["ZIndex"] = 0;
G2L["f"]["BorderSizePixel"] = 0;
G2L["f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f"]["ImageTransparency"] = 0.2;
G2L["f"]["Image"] = [[rbxassetid://14407899530]];
G2L["f"]["Size"] = UDim2.new(0, 174, 0, 41);
G2L["f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Modules.AIModule.Holder.Main.ImageLabel.UICorner
G2L["10"] = Instance.new("UICorner", G2L["f"]);



-- StarterGui.SSWorks.Modules.AIModule.Holder.Main.TextLabel
G2L["11"] = Instance.new("TextLabel", G2L["d"]);
G2L["11"]["BorderSizePixel"] = 0;
G2L["11"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["11"]["TextSize"] = 13;
G2L["11"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["11"]["TextColor3"] = Color3.fromRGB(61, 147, 204);
G2L["11"]["BackgroundTransparency"] = 1;
G2L["11"]["Size"] = UDim2.new(0, 174, 0, 41);
G2L["11"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11"]["Text"] = [[Hello there! How may i help you?]];


-- StarterGui.SSWorks.Modules.AIModule.Holder.UICorner
G2L["12"] = Instance.new("UICorner", G2L["c"]);
G2L["12"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Modules.AIModule.Holder.ImageLabel
G2L["13"] = Instance.new("ImageLabel", G2L["c"]);
G2L["13"]["BorderSizePixel"] = 0;
G2L["13"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13"]["ImageTransparency"] = 0.4;
G2L["13"]["Image"] = [[rbxassetid://10709782230]];
G2L["13"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["13"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["13"]["BackgroundTransparency"] = 1;
G2L["13"]["Position"] = UDim2.new(0.0237, 0, 0.2439, 0);


-- StarterGui.SSWorks.Modules.PurchasesAPI
G2L["14"] = Instance.new("ModuleScript", G2L["2"]);
G2L["14"]["Name"] = [[PurchasesAPI]];


-- StarterGui.SSWorks.Main
G2L["15"] = Instance.new("CanvasGroup", G2L["1"]);
G2L["15"]["Visible"] = false;
G2L["15"]["BorderSizePixel"] = 0;
G2L["15"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["15"]["Size"] = UDim2.new(0, 690, 0, 447);
G2L["15"]["Position"] = UDim2.new(0.32143, 0, 0.28975, 0);
G2L["15"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["15"]["Name"] = [[Main]];


-- StarterGui.SSWorks.Main.UICorner
G2L["16"] = Instance.new("UICorner", G2L["15"]);



-- StarterGui.SSWorks.Main.Topbar
G2L["17"] = Instance.new("Frame", G2L["15"]);
G2L["17"]["BorderSizePixel"] = 0;
G2L["17"]["BackgroundColor3"] = Color3.fromRGB(39, 39, 39);
G2L["17"]["Size"] = UDim2.new(0, 690, 0, 43);
G2L["17"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17"]["Name"] = [[Topbar]];


-- StarterGui.SSWorks.Main.Topbar.DLine
G2L["18"] = Instance.new("Frame", G2L["17"]);
G2L["18"]["BorderSizePixel"] = 0;
G2L["18"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18"]["Size"] = UDim2.new(0, 631, 0, 1);
G2L["18"]["Position"] = UDim2.new(0.08551, 0, 0.97674, 0);
G2L["18"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["18"]["Name"] = [[DLine]];
G2L["18"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.Topbar.TextLabel
G2L["19"] = Instance.new("TextLabel", G2L["17"]);
G2L["19"]["TextWrapped"] = true;
G2L["19"]["BorderSizePixel"] = 0;
G2L["19"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["19"]["TextTransparency"] = 0.4;
G2L["19"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["19"]["TextSize"] = 18;
G2L["19"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["19"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["19"]["BackgroundTransparency"] = 1;
G2L["19"]["Size"] = UDim2.new(0, 175, 0, 34);
G2L["19"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19"]["Text"] = [[Storm]];
G2L["19"]["Position"] = UDim2.new(0.02029, 0, 0.09366, 0);


-- StarterGui.SSWorks.Main.Topbar.ImageButton
G2L["1a"] = Instance.new("ImageButton", G2L["17"]);
G2L["1a"]["BorderSizePixel"] = 0;
G2L["1a"]["ImageTransparency"] = 0.4;
G2L["1a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a"]["ImageColor3"] = Color3.fromRGB(56, 159, 255);
G2L["1a"]["Image"] = [[rbxassetid://10747384394]];
G2L["1a"]["Size"] = UDim2.new(0, 23, 0, 23);
G2L["1a"]["BackgroundTransparency"] = 1;
G2L["1a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1a"]["Position"] = UDim2.new(0.95404, 0, 0.2093, 0);


-- StarterGui.SSWorks.Main.Topbar.ImageButton.LocalScript
G2L["1b"] = Instance.new("LocalScript", G2L["1a"]);



-- StarterGui.SSWorks.Main.KeySystem
G2L["1c"] = Instance.new("Frame", G2L["15"]);
G2L["1c"]["Visible"] = false;
G2L["1c"]["ZIndex"] = 9;
G2L["1c"]["BorderSizePixel"] = 0;
G2L["1c"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["1c"]["Size"] = UDim2.new(0, 690, 0, 406);
G2L["1c"]["Position"] = UDim2.new(-0.00145, 0, 0.09396, 0);
G2L["1c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c"]["Name"] = [[KeySystem]];


-- StarterGui.SSWorks.Main.KeySystem.Design
G2L["1d"] = Instance.new("Folder", G2L["1c"]);
G2L["1d"]["Name"] = [[Design]];


-- StarterGui.SSWorks.Main.KeySystem.Design.ImageLabel
G2L["1e"] = Instance.new("ImageLabel", G2L["1d"]);
G2L["1e"]["ZIndex"] = 0;
G2L["1e"]["BorderSizePixel"] = 0;
G2L["1e"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["1e"]["ImageTransparency"] = 0.3;
G2L["1e"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["1e"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["1e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e"]["BackgroundTransparency"] = 1;
G2L["1e"]["Position"] = UDim2.new(0.11449, 0, 0.32178, 0);


-- StarterGui.SSWorks.Main.KeySystem.Design.ImageLabel
G2L["1f"] = Instance.new("ImageLabel", G2L["1d"]);
G2L["1f"]["ZIndex"] = 0;
G2L["1f"]["BorderSizePixel"] = 0;
G2L["1f"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["1f"]["ImageTransparency"] = 0.3;
G2L["1f"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["1f"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["1f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f"]["BackgroundTransparency"] = 1;
G2L["1f"]["Position"] = UDim2.new(0.16812, 0, 0.44307, 0);


-- StarterGui.SSWorks.Main.KeySystem.Design.ImageLabel
G2L["20"] = Instance.new("ImageLabel", G2L["1d"]);
G2L["20"]["ZIndex"] = 0;
G2L["20"]["BorderSizePixel"] = 0;
G2L["20"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["20"]["ImageTransparency"] = 0.3;
G2L["20"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["20"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["20"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["20"]["BackgroundTransparency"] = 1;
G2L["20"]["Position"] = UDim2.new(0.2058, 0, 0.22772, 0);


-- StarterGui.SSWorks.Main.KeySystem.Design.ImageLabel
G2L["21"] = Instance.new("ImageLabel", G2L["1d"]);
G2L["21"]["BorderSizePixel"] = 0;
G2L["21"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["21"]["ImageTransparency"] = 0.2;
G2L["21"]["Image"] = [[rbxassetid://14407899530]];
G2L["21"]["Size"] = UDim2.new(0, 690, 0, 406);
G2L["21"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["21"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.KeySystem.InputBox
G2L["22"] = Instance.new("TextBox", G2L["1c"]);
G2L["22"]["TextColor3"] = Color3.fromRGB(87, 123, 209);
G2L["22"]["PlaceholderColor3"] = Color3.fromRGB(87, 123, 209);
G2L["22"]["BorderSizePixel"] = 0;
G2L["22"]["TextSize"] = 16;
G2L["22"]["Name"] = [[InputBox]];
G2L["22"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["22"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["22"]["PlaceholderText"] = [[Enter your key here]];
G2L["22"]["Size"] = UDim2.new(0, 318, 0, 43);
G2L["22"]["Position"] = UDim2.new(0.46667, 0, 0.40842, 0);
G2L["22"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["22"]["Text"] = [[]];
G2L["22"]["BackgroundTransparency"] = 0.3;


-- StarterGui.SSWorks.Main.KeySystem.InputBox.UICorner
G2L["23"] = Instance.new("UICorner", G2L["22"]);
G2L["23"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.KeySystem.InputBox.UIStroke
G2L["24"] = Instance.new("UIStroke", G2L["22"]);
G2L["24"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["24"]["Color"] = Color3.fromRGB(67, 67, 67);


-- StarterGui.SSWorks.Main.KeySystem.TextLabel
G2L["25"] = Instance.new("TextLabel", G2L["1c"]);
G2L["25"]["TextWrapped"] = true;
G2L["25"]["BorderSizePixel"] = 0;
G2L["25"]["TextTransparency"] = 0.4;
G2L["25"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25"]["TextSize"] = 20;
G2L["25"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["25"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["25"]["BackgroundTransparency"] = 1;
G2L["25"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["25"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["25"]["Text"] = [[Key System]];
G2L["25"]["Position"] = UDim2.new(0.55217, 0, 0.2797, 0);


-- StarterGui.SSWorks.Main.KeySystem.TextButton
G2L["26"] = Instance.new("TextButton", G2L["1c"]);
G2L["26"]["BorderSizePixel"] = 0;
G2L["26"]["AutoButtonColor"] = false;
G2L["26"]["TextSize"] = 14;
G2L["26"]["TextColor3"] = Color3.fromRGB(87, 123, 209);
G2L["26"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["26"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["26"]["Size"] = UDim2.new(0, 318, 0, 23);
G2L["26"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["26"]["Text"] = [[Check]];
G2L["26"]["Position"] = UDim2.new(0.46667, 0, 0.52726, 0);


-- StarterGui.SSWorks.Main.KeySystem.TextButton.UICorner
G2L["27"] = Instance.new("UICorner", G2L["26"]);
G2L["27"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.KeySystem.TextButton.UIStroke
G2L["28"] = Instance.new("UIStroke", G2L["26"]);
G2L["28"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["28"]["Color"] = Color3.fromRGB(67, 67, 67);


-- StarterGui.SSWorks.Main.KeySystem.Manager
G2L["29"] = Instance.new("LocalScript", G2L["1c"]);
G2L["29"]["Name"] = [[Manager]];


-- StarterGui.SSWorks.Main.KeySystem.UpdLogBtn
G2L["2a"] = Instance.new("TextButton", G2L["1c"]);
G2L["2a"]["BorderSizePixel"] = 0;
G2L["2a"]["AutoButtonColor"] = false;
G2L["2a"]["TextSize"] = 14;
G2L["2a"]["TextColor3"] = Color3.fromRGB(87, 123, 209);
G2L["2a"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["2a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2a"]["Size"] = UDim2.new(0, 318, 0, 23);
G2L["2a"]["Name"] = [[UpdLogBtn]];
G2L["2a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2a"]["Text"] = [[Update Logs]];
G2L["2a"]["Position"] = UDim2.new(0.46667, 0, 0.59623, 0);


-- StarterGui.SSWorks.Main.KeySystem.UpdLogBtn.UICorner
G2L["2b"] = Instance.new("UICorner", G2L["2a"]);
G2L["2b"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.KeySystem.UpdLogBtn.UIStroke
G2L["2c"] = Instance.new("UIStroke", G2L["2a"]);
G2L["2c"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["2c"]["Color"] = Color3.fromRGB(67, 67, 67);


-- StarterGui.SSWorks.Main.KeySystem.UpdLogBtn.LocalScript
G2L["2d"] = Instance.new("LocalScript", G2L["2a"]);



-- StarterGui.SSWorks.Main.Menu
G2L["2e"] = Instance.new("Frame", G2L["15"]);
G2L["2e"]["BorderSizePixel"] = 0;
G2L["2e"]["BackgroundColor3"] = Color3.fromRGB(39, 39, 39);
G2L["2e"]["Size"] = UDim2.new(0, 58, 0, 404);
G2L["2e"]["Position"] = UDim2.new(0, 0, 0.0962, 0);
G2L["2e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2e"]["Name"] = [[Menu]];


-- StarterGui.SSWorks.Main.Menu.DLine
G2L["2f"] = Instance.new("Frame", G2L["2e"]);
G2L["2f"]["BorderSizePixel"] = 0;
G2L["2f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f"]["Size"] = UDim2.new(0, 1, 0, 404);
G2L["2f"]["Position"] = UDim2.new(1, 0, 0, 0);
G2L["2f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2f"]["Name"] = [[DLine]];
G2L["2f"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.Menu.Button
G2L["30"] = Instance.new("Folder", G2L["2e"]);
G2L["30"]["Name"] = [[Button]];


-- StarterGui.SSWorks.Main.Menu.Button.ExecButton
G2L["31"] = Instance.new("ImageButton", G2L["30"]);
G2L["31"]["BorderSizePixel"] = 0;
G2L["31"]["AutoButtonColor"] = false;
G2L["31"]["ImageTransparency"] = 0.4;
G2L["31"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31"]["Image"] = [[http://www.roblox.com/asset/?id=6022668955]];
G2L["31"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["31"]["BackgroundTransparency"] = 1;
G2L["31"]["Name"] = [[ExecButton]];
G2L["31"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["31"]["Position"] = UDim2.new(0.24138, 0, 0.02723, 0);


-- StarterGui.SSWorks.Main.Menu.Button.ExecButton.UICorner
G2L["32"] = Instance.new("UICorner", G2L["31"]);



-- StarterGui.SSWorks.Main.Menu.Button.ExecButton.Indicator
G2L["33"] = Instance.new("Frame", G2L["31"]);
G2L["33"]["BorderSizePixel"] = 0;
G2L["33"]["BackgroundColor3"] = Color3.fromRGB(44, 139, 255);
G2L["33"]["Size"] = UDim2.new(0, 2, 0, 32);
G2L["33"]["Position"] = UDim2.new(-0.48276, 0, -0.06897, 0);
G2L["33"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["33"]["Name"] = [[Indicator]];


-- StarterGui.SSWorks.Main.Menu.Button.ExecButton.Indicator.UICorner
G2L["34"] = Instance.new("UICorner", G2L["33"]);



-- StarterGui.SSWorks.Main.Menu.Button.ExecButton.LocalScript
G2L["35"] = Instance.new("LocalScript", G2L["31"]);



-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton
G2L["36"] = Instance.new("ImageButton", G2L["30"]);
G2L["36"]["BorderSizePixel"] = 0;
G2L["36"]["AutoButtonColor"] = false;
G2L["36"]["ImageTransparency"] = 0.4;
G2L["36"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36"]["Image"] = [[rbxassetid://10747361219]];
G2L["36"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["36"]["BackgroundTransparency"] = 1;
G2L["36"]["Name"] = [[ScriptButton]];
G2L["36"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36"]["Position"] = UDim2.new(0.24138, 0, 0.11634, 0);


-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton.UICorner
G2L["37"] = Instance.new("UICorner", G2L["36"]);



-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton.Indicator
G2L["38"] = Instance.new("Frame", G2L["36"]);
G2L["38"]["BorderSizePixel"] = 0;
G2L["38"]["BackgroundColor3"] = Color3.fromRGB(44, 139, 255);
G2L["38"]["Size"] = UDim2.new(0, 2, 0, 32);
G2L["38"]["Position"] = UDim2.new(-0.48276, 0, -0.06897, 0);
G2L["38"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["38"]["Name"] = [[Indicator]];
G2L["38"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton.Indicator.UICorner
G2L["39"] = Instance.new("UICorner", G2L["38"]);



-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton.LocalScript
G2L["3a"] = Instance.new("LocalScript", G2L["36"]);



-- StarterGui.SSWorks.Main.Menu.Button.SettingButton
G2L["3b"] = Instance.new("ImageButton", G2L["30"]);
G2L["3b"]["BorderSizePixel"] = 0;
G2L["3b"]["AutoButtonColor"] = false;
G2L["3b"]["ImageTransparency"] = 0.4;
G2L["3b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b"]["Image"] = [[rbxassetid://10734950309]];
G2L["3b"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["3b"]["BackgroundTransparency"] = 1;
G2L["3b"]["Name"] = [[SettingButton]];
G2L["3b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b"]["Position"] = UDim2.new(0.24138, 0, 0.89604, 0);


-- StarterGui.SSWorks.Main.Menu.Button.SettingButton.UICorner
G2L["3c"] = Instance.new("UICorner", G2L["3b"]);



-- StarterGui.SSWorks.Main.Menu.Button.SettingButton.Indicator
G2L["3d"] = Instance.new("Frame", G2L["3b"]);
G2L["3d"]["BorderSizePixel"] = 0;
G2L["3d"]["BackgroundColor3"] = Color3.fromRGB(44, 139, 255);
G2L["3d"]["Size"] = UDim2.new(0, 2, 0, 32);
G2L["3d"]["Position"] = UDim2.new(-0.48276, 0, -0.06897, 0);
G2L["3d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d"]["Name"] = [[Indicator]];
G2L["3d"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.Menu.Button.SettingButton.Indicator.UICorner
G2L["3e"] = Instance.new("UICorner", G2L["3d"]);



-- StarterGui.SSWorks.Main.Menu.Button.SettingButton.LocalScript
G2L["3f"] = Instance.new("LocalScript", G2L["3b"]);



-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton
G2L["40"] = Instance.new("ImageButton", G2L["30"]);
G2L["40"]["BorderSizePixel"] = 0;
G2L["40"]["AutoButtonColor"] = false;
G2L["40"]["ImageTransparency"] = 0.4;
G2L["40"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40"]["Image"] = [[rbxassetid://10709811365]];
G2L["40"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["40"]["BackgroundTransparency"] = 1;
G2L["40"]["Name"] = [[ExternalButton]];
G2L["40"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["40"]["Position"] = UDim2.new(0.24138, 0, 0.20297, 0);


-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton.UICorner
G2L["41"] = Instance.new("UICorner", G2L["40"]);



-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton.Indicator
G2L["42"] = Instance.new("Frame", G2L["40"]);
G2L["42"]["BorderSizePixel"] = 0;
G2L["42"]["BackgroundColor3"] = Color3.fromRGB(44, 139, 255);
G2L["42"]["Size"] = UDim2.new(0, 2, 0, 32);
G2L["42"]["Position"] = UDim2.new(-0.48276, 0, -0.06897, 0);
G2L["42"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42"]["Name"] = [[Indicator]];
G2L["42"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton.Indicator.UICorner
G2L["43"] = Instance.new("UICorner", G2L["42"]);



-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton.LocalScript
G2L["44"] = Instance.new("LocalScript", G2L["40"]);



-- StarterGui.SSWorks.Main.SmoothDrag
G2L["45"] = Instance.new("LocalScript", G2L["15"]);
G2L["45"]["Name"] = [[SmoothDrag]];


-- StarterGui.SSWorks.Main.UpdateLogs
G2L["46"] = Instance.new("Frame", G2L["15"]);
G2L["46"]["Visible"] = false;
G2L["46"]["ZIndex"] = 9;
G2L["46"]["BorderSizePixel"] = 0;
G2L["46"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["46"]["Size"] = UDim2.new(0, 690, 0, 406);
G2L["46"]["Position"] = UDim2.new(-0.00145, 0, 0.09396, 0);
G2L["46"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["46"]["Name"] = [[UpdateLogs]];


-- StarterGui.SSWorks.Main.UpdateLogs.Design
G2L["47"] = Instance.new("Folder", G2L["46"]);
G2L["47"]["Name"] = [[Design]];


-- StarterGui.SSWorks.Main.UpdateLogs.Design.ImageLabel
G2L["48"] = Instance.new("ImageLabel", G2L["47"]);
G2L["48"]["ZIndex"] = 0;
G2L["48"]["BorderSizePixel"] = 0;
G2L["48"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["48"]["ImageTransparency"] = 0.3;
G2L["48"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["48"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["48"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["48"]["BackgroundTransparency"] = 1;
G2L["48"]["Position"] = UDim2.new(0.37971, 0, 0.30947, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Design.ImageLabel
G2L["49"] = Instance.new("ImageLabel", G2L["47"]);
G2L["49"]["ZIndex"] = 0;
G2L["49"]["BorderSizePixel"] = 0;
G2L["49"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["49"]["ImageTransparency"] = 0.3;
G2L["49"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["49"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["49"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["49"]["BackgroundTransparency"] = 1;
G2L["49"]["Position"] = UDim2.new(0.43333, 0, 0.43075, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Design.ImageLabel
G2L["4a"] = Instance.new("ImageLabel", G2L["47"]);
G2L["4a"]["ZIndex"] = 0;
G2L["4a"]["BorderSizePixel"] = 0;
G2L["4a"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["4a"]["ImageTransparency"] = 0.3;
G2L["4a"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["4a"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["4a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4a"]["BackgroundTransparency"] = 1;
G2L["4a"]["Position"] = UDim2.new(0.47101, 0, 0.21541, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Design.ImageLabel
G2L["4b"] = Instance.new("ImageLabel", G2L["47"]);
G2L["4b"]["BorderSizePixel"] = 0;
G2L["4b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4b"]["ImageTransparency"] = 0.2;
G2L["4b"]["Image"] = [[rbxassetid://14407899530]];
G2L["4b"]["Size"] = UDim2.new(0, 695, 0, 406);
G2L["4b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4b"]["BackgroundTransparency"] = 1;
G2L["4b"]["Position"] = UDim2.new(0.00145, 0, 0, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Design.ImageLabel
G2L["4c"] = Instance.new("ImageLabel", G2L["47"]);
G2L["4c"]["ZIndex"] = 0;
G2L["4c"]["BorderSizePixel"] = 0;
G2L["4c"]["BackgroundColor3"] = Color3.fromRGB(45, 65, 121);
G2L["4c"]["ImageTransparency"] = 0.3;
G2L["4c"]["Image"] = [[http://www.roblox.com/asset/?id=6031302918]];
G2L["4c"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["4c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4c"]["BackgroundTransparency"] = 1;
G2L["4c"]["Position"] = UDim2.new(0.55072, 0, 0.33363, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["4d"] = Instance.new("TextLabel", G2L["46"]);
G2L["4d"]["TextWrapped"] = true;
G2L["4d"]["BorderSizePixel"] = 0;
G2L["4d"]["TextTransparency"] = 0.4;
G2L["4d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d"]["TextSize"] = 20;
G2L["4d"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["4d"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["4d"]["BackgroundTransparency"] = 1;
G2L["4d"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4d"]["Text"] = [[Update Logs]];
G2L["4d"]["Position"] = UDim2.new(0.36522, 0, 0.02108, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["4e"] = Instance.new("TextLabel", G2L["46"]);
G2L["4e"]["TextWrapped"] = true;
G2L["4e"]["BorderSizePixel"] = 0;
G2L["4e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["4e"]["TextTransparency"] = 0.4;
G2L["4e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4e"]["TextSize"] = 16;
G2L["4e"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4e"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["4e"]["BackgroundTransparency"] = 1;
G2L["4e"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["4e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e"]["Text"] = [[- Update Logs functions we're added for the user's knowledge]];
G2L["4e"]["Position"] = UDim2.new(0.02174, 0, 0.23783, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["4f"] = Instance.new("TextLabel", G2L["46"]);
G2L["4f"]["TextWrapped"] = true;
G2L["4f"]["BorderSizePixel"] = 0;
G2L["4f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["4f"]["TextTransparency"] = 0.4;
G2L["4f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4f"]["TextSize"] = 18;
G2L["4f"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["4f"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["4f"]["BackgroundTransparency"] = 1;
G2L["4f"]["Size"] = UDim2.new(0, 213, 0, 21);
G2L["4f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4f"]["Text"] = [[Visuals]];
G2L["4f"]["Position"] = UDim2.new(0.02174, 0, 0.18611, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["50"] = Instance.new("TextLabel", G2L["46"]);
G2L["50"]["TextWrapped"] = true;
G2L["50"]["BorderSizePixel"] = 0;
G2L["50"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["50"]["TextTransparency"] = 0.4;
G2L["50"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["50"]["TextSize"] = 16;
G2L["50"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["50"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["50"]["BackgroundTransparency"] = 1;
G2L["50"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["50"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["50"]["Text"] = [[- Aim Assist Range Coloration was added to not be so basic anymore]];
G2L["50"]["Position"] = UDim2.new(0.02174, 0, 0.28956, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["51"] = Instance.new("TextLabel", G2L["46"]);
G2L["51"]["TextWrapped"] = true;
G2L["51"]["BorderSizePixel"] = 0;
G2L["51"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["51"]["TextTransparency"] = 0.4;
G2L["51"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["51"]["TextSize"] = 16;
G2L["51"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["51"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["51"]["BackgroundTransparency"] = 1;
G2L["51"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["51"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["51"]["Text"] = [[- Hold / Activate Method for Aim Assist.]];
G2L["51"]["Position"] = UDim2.new(0.02174, 0, 0.44719, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["52"] = Instance.new("TextLabel", G2L["46"]);
G2L["52"]["TextWrapped"] = true;
G2L["52"]["BorderSizePixel"] = 0;
G2L["52"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["52"]["TextTransparency"] = 0.4;
G2L["52"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["52"]["TextSize"] = 18;
G2L["52"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["52"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["52"]["BackgroundTransparency"] = 1;
G2L["52"]["Size"] = UDim2.new(0, 213, 0, 21);
G2L["52"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["52"]["Text"] = [[Features]];
G2L["52"]["Position"] = UDim2.new(0.02174, 0, 0.39547, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["53"] = Instance.new("TextLabel", G2L["46"]);
G2L["53"]["TextWrapped"] = true;
G2L["53"]["BorderSizePixel"] = 0;
G2L["53"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["53"]["TextTransparency"] = 0.4;
G2L["53"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["53"]["TextSize"] = 16;
G2L["53"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["53"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["53"]["BackgroundTransparency"] = 1;
G2L["53"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["53"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["53"]["Text"] = [[- Beta / Premium Features, Bypasses for stopping utilities]];
G2L["53"]["Position"] = UDim2.new(0.02174, 0, 0.60975, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["54"] = Instance.new("TextLabel", G2L["46"]);
G2L["54"]["TextWrapped"] = true;
G2L["54"]["BorderSizePixel"] = 0;
G2L["54"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["54"]["TextTransparency"] = 0.4;
G2L["54"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["54"]["TextSize"] = 18;
G2L["54"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["54"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["54"]["BackgroundTransparency"] = 1;
G2L["54"]["Size"] = UDim2.new(0, 213, 0, 21);
G2L["54"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["54"]["Text"] = [[Update Expections]];
G2L["54"]["Position"] = UDim2.new(0.02174, 0, 0.5531, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["55"] = Instance.new("TextLabel", G2L["46"]);
G2L["55"]["TextWrapped"] = true;
G2L["55"]["BorderSizePixel"] = 0;
G2L["55"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["55"]["TextTransparency"] = 0.4;
G2L["55"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["55"]["TextSize"] = 16;
G2L["55"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["55"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["55"]["BackgroundTransparency"] = 1;
G2L["55"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["55"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["55"]["Text"] = [[- Script Hub new scripts will come out and new script hub features]];
G2L["55"]["Position"] = UDim2.new(0.02174, 0, 0.66887, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.TextLabel
G2L["56"] = Instance.new("TextLabel", G2L["46"]);
G2L["56"]["TextWrapped"] = true;
G2L["56"]["BorderSizePixel"] = 0;
G2L["56"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["56"]["TextTransparency"] = 0.4;
G2L["56"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["56"]["TextSize"] = 16;
G2L["56"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["56"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["56"]["BackgroundTransparency"] = 1;
G2L["56"]["Size"] = UDim2.new(0, 667, 0, 24);
G2L["56"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["56"]["Text"] = [[- Interaction's with API to answer polls within the UI.]];
G2L["56"]["Position"] = UDim2.new(0.02174, 0, 0.72798, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll
G2L["57"] = Instance.new("Frame", G2L["46"]);
G2L["57"]["BorderSizePixel"] = 0;
G2L["57"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["57"]["Size"] = UDim2.new(0, 235, 0, 64);
G2L["57"]["Position"] = UDim2.new(0.02464, 0, 0.80788, 0);
G2L["57"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["57"]["Name"] = [[Poll]];


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.UICorner
G2L["58"] = Instance.new("UICorner", G2L["57"]);
G2L["58"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.UIStroke
G2L["59"] = Instance.new("UIStroke", G2L["57"]);
G2L["59"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["59"]["Color"] = Color3.fromRGB(86, 86, 86);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Title
G2L["5a"] = Instance.new("TextLabel", G2L["57"]);
G2L["5a"]["TextWrapped"] = true;
G2L["5a"]["BorderSizePixel"] = 0;
G2L["5a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["5a"]["TextTransparency"] = 0.4;
G2L["5a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5a"]["TextSize"] = 16;
G2L["5a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["5a"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["5a"]["BackgroundTransparency"] = 1;
G2L["5a"]["Size"] = UDim2.new(0, 178, 0, 12);
G2L["5a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["5a"]["Text"] = [[Poll]];
G2L["5a"]["Name"] = [[Title]];
G2L["5a"]["Position"] = UDim2.new(0.03221, 0, 0.15486, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Message
G2L["5b"] = Instance.new("TextLabel", G2L["57"]);
G2L["5b"]["TextWrapped"] = true;
G2L["5b"]["BorderSizePixel"] = 0;
G2L["5b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["5b"]["TextTransparency"] = 0.4;
G2L["5b"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["5b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5b"]["TextSize"] = 14;
G2L["5b"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["5b"]["TextColor3"] = Color3.fromRGB(210, 210, 210);
G2L["5b"]["BackgroundTransparency"] = 1;
G2L["5b"]["Size"] = UDim2.new(0, 178, 0, 33);
G2L["5b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["5b"]["Text"] = [[Example Poll]];
G2L["5b"]["Name"] = [[Message]];
G2L["5b"]["Position"] = UDim2.new(0.03221, 0, 0.37361, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Vote
G2L["5c"] = Instance.new("ImageButton", G2L["57"]);
G2L["5c"]["BorderSizePixel"] = 0;
G2L["5c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5c"]["ImageColor3"] = Color3.fromRGB(146, 255, 126);
G2L["5c"]["Image"] = [[rbxassetid://10709790298]];
G2L["5c"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["5c"]["BackgroundTransparency"] = 1;
G2L["5c"]["Name"] = [[Vote]];
G2L["5c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["5c"]["Position"] = UDim2.new(0.87234, 0, 0.14063, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Vote.LocalScript
G2L["5d"] = Instance.new("LocalScript", G2L["5c"]);



-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Vote.UIStroke
G2L["5e"] = Instance.new("UIStroke", G2L["5c"]);
G2L["5e"]["Transparency"] = 1;
G2L["5e"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["5e"]["Color"] = Color3.fromRGB(0, 255, 18);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Vote.UICorner
G2L["5f"] = Instance.new("UICorner", G2L["5c"]);
G2L["5f"]["CornerRadius"] = UDim.new(1, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Exclude
G2L["60"] = Instance.new("ImageButton", G2L["57"]);
G2L["60"]["BorderSizePixel"] = 0;
G2L["60"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["60"]["ImageColor3"] = Color3.fromRGB(255, 134, 134);
G2L["60"]["Image"] = [[rbxassetid://10747383819]];
G2L["60"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["60"]["BackgroundTransparency"] = 1;
G2L["60"]["Name"] = [[Exclude]];
G2L["60"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["60"]["Position"] = UDim2.new(0.87234, 0, 0.54688, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Exclude.UICorner
G2L["61"] = Instance.new("UICorner", G2L["60"]);
G2L["61"]["CornerRadius"] = UDim.new(1, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Exclude.UIStroke
G2L["62"] = Instance.new("UIStroke", G2L["60"]);
G2L["62"]["Transparency"] = 1;
G2L["62"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["62"]["Color"] = Color3.fromRGB(255, 130, 130);


-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Exclude.LocalScript
G2L["63"] = Instance.new("LocalScript", G2L["60"]);



-- StarterGui.SSWorks.Main.UpdateLogs.ImageButton
G2L["64"] = Instance.new("ImageButton", G2L["46"]);
G2L["64"]["BorderSizePixel"] = 0;
G2L["64"]["ImageTransparency"] = 0.4;
G2L["64"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["64"]["Image"] = [[http://www.roblox.com/asset/?id=6035047397]];
G2L["64"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["64"]["BackgroundTransparency"] = 1;
G2L["64"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["64"]["Position"] = UDim2.new(0.93333, 0, 0.05172, 0);


-- StarterGui.SSWorks.Main.UpdateLogs.ImageButton.LocalScript
G2L["65"] = Instance.new("LocalScript", G2L["64"]);



-- StarterGui.SSWorks.Main.ContentProvider
G2L["66"] = Instance.new("Frame", G2L["15"]);
G2L["66"]["BorderSizePixel"] = 0;
G2L["66"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["66"]["Size"] = UDim2.new(0, 631, 0, 404);
G2L["66"]["Position"] = UDim2.new(0.08551, 0, 0.0962, 0);
G2L["66"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["66"]["Name"] = [[ContentProvider]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor
G2L["67"] = Instance.new("Frame", G2L["66"]);
G2L["67"]["BorderSizePixel"] = 0;
G2L["67"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["67"]["Size"] = UDim2.new(0, 631, 0, 404);
G2L["67"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["67"]["Name"] = [[Executor]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI
G2L["68"] = Instance.new("Frame", G2L["67"]);
G2L["68"]["BorderSizePixel"] = 0;
G2L["68"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["68"]["Size"] = UDim2.new(0, 162, 0, 402);
G2L["68"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["68"]["Name"] = [[AI]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.DLine
G2L["69"] = Instance.new("Frame", G2L["68"]);
G2L["69"]["BorderSizePixel"] = 0;
G2L["69"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["69"]["Size"] = UDim2.new(0, 1, 0, 403);
G2L["69"]["Position"] = UDim2.new(1.36198, 0, 0, 0);
G2L["69"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["69"]["Name"] = [[DLine]];
G2L["69"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.TextLabel
G2L["6a"] = Instance.new("TextLabel", G2L["68"]);
G2L["6a"]["BorderSizePixel"] = 0;
G2L["6a"]["TextTransparency"] = 0.4;
G2L["6a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6a"]["TextSize"] = 16;
G2L["6a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["6a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6a"]["BackgroundTransparency"] = 1;
G2L["6a"]["Size"] = UDim2.new(0, 199, 0, 19);
G2L["6a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6a"]["Text"] = [[Artificial Inteligence]];
G2L["6a"]["Position"] = UDim2.new(0.06069, 0, 0.021, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.DLine
G2L["6b"] = Instance.new("Frame", G2L["68"]);
G2L["6b"]["BorderSizePixel"] = 0;
G2L["6b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6b"]["Size"] = UDim2.new(0, 221, 0, 1);
G2L["6b"]["Position"] = UDim2.new(-0.00617, 0, 0.08458, 0);
G2L["6b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6b"]["Name"] = [[DLine]];
G2L["6b"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.ScrollingFrame
G2L["6c"] = Instance.new("ScrollingFrame", G2L["68"]);
G2L["6c"]["Active"] = true;
G2L["6c"]["BorderSizePixel"] = 0;
G2L["6c"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["6c"]["Size"] = UDim2.new(0, 212, 0, 318);
G2L["6c"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6c"]["Position"] = UDim2.new(0.0274, 0, 0.0995, 0);
G2L["6c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6c"]["ScrollBarThickness"] = 0;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.ScrollingFrame.UIListLayout
G2L["6d"] = Instance.new("UIListLayout", G2L["6c"]);
G2L["6d"]["Padding"] = UDim.new(0, 5);
G2L["6d"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input
G2L["6e"] = Instance.new("Frame", G2L["68"]);
G2L["6e"]["BorderSizePixel"] = 0;
G2L["6e"]["BackgroundColor3"] = Color3.fromRGB(46, 100, 226);
G2L["6e"]["Size"] = UDim2.new(0, 213, 0, 41);
G2L["6e"]["Position"] = UDim2.new(0.017, 0, 0.89055, 0);
G2L["6e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6e"]["Name"] = [[Input]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.ImageLabel
G2L["6f"] = Instance.new("ImageLabel", G2L["6e"]);
G2L["6f"]["ZIndex"] = 0;
G2L["6f"]["BorderSizePixel"] = 0;
G2L["6f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6f"]["ImageTransparency"] = 0.2;
G2L["6f"]["Image"] = [[rbxassetid://14407899530]];
G2L["6f"]["Size"] = UDim2.new(0, 213, 0, 41);
G2L["6f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6f"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.ImageLabel.UICorner
G2L["70"] = Instance.new("UICorner", G2L["6f"]);
G2L["70"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.TextBox
G2L["71"] = Instance.new("TextBox", G2L["6e"]);
G2L["71"]["TextColor3"] = Color3.fromRGB(24, 84, 141);
G2L["71"]["PlaceholderColor3"] = Color3.fromRGB(24, 84, 141);
G2L["71"]["BorderSizePixel"] = 0;
G2L["71"]["TextSize"] = 14;
G2L["71"]["BackgroundColor3"] = Color3.fromRGB(9, 23, 36);
G2L["71"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["71"]["PlaceholderText"] = [[Send an message to AI]];
G2L["71"]["Size"] = UDim2.new(0, 167, 0, 30);
G2L["71"]["Position"] = UDim2.new(0.02853, 0, 0.12195, 0);
G2L["71"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["71"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.TextBox.UICorner
G2L["72"] = Instance.new("UICorner", G2L["71"]);
G2L["72"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.ImageButton
G2L["73"] = Instance.new("ImageButton", G2L["6e"]);
G2L["73"]["BorderSizePixel"] = 0;
G2L["73"]["AutoButtonColor"] = false;
G2L["73"]["ImageTransparency"] = 0.4;
G2L["73"]["BackgroundColor3"] = Color3.fromRGB(9, 23, 36);
G2L["73"]["ImageColor3"] = Color3.fromRGB(9, 23, 36);
G2L["73"]["Image"] = [[http://www.roblox.com/asset/?id=6035067832]];
G2L["73"]["Size"] = UDim2.new(0, 26, 0, 26);
G2L["73"]["BackgroundTransparency"] = 1;
G2L["73"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["73"]["Position"] = UDim2.new(0.84507, 0, 0.17073, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.ImageButton.UICorner
G2L["74"] = Instance.new("UICorner", G2L["73"]);
G2L["74"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.UICorner
G2L["75"] = Instance.new("UICorner", G2L["6e"]);
G2L["75"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.Manager
G2L["76"] = Instance.new("LocalScript", G2L["6e"]);
G2L["76"]["Name"] = [[Manager]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options
G2L["77"] = Instance.new("Frame", G2L["67"]);
G2L["77"]["BorderSizePixel"] = 0;
G2L["77"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["77"]["Size"] = UDim2.new(0, 409, 0, 34);
G2L["77"]["Position"] = UDim2.new(0.35182, 0, 0, 0);
G2L["77"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["77"]["Name"] = [[Options]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.DLine
G2L["78"] = Instance.new("Frame", G2L["77"]);
G2L["78"]["BorderSizePixel"] = 0;
G2L["78"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["78"]["Size"] = UDim2.new(0, 468, 0, 1);
G2L["78"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["78"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["78"]["Name"] = [[DLine]];
G2L["78"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Execute
G2L["79"] = Instance.new("ImageButton", G2L["77"]);
G2L["79"]["BorderSizePixel"] = 0;
G2L["79"]["ImageTransparency"] = 0.4;
G2L["79"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["79"]["Image"] = [[rbxassetid://10734923549]];
G2L["79"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["79"]["BackgroundTransparency"] = 1;
G2L["79"]["Name"] = [[Execute]];
G2L["79"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["79"]["Position"] = UDim2.new(0.01496, 0, 0.17647, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Execute.LocalScript
G2L["7a"] = Instance.new("LocalScript", G2L["79"]);



-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Clear
G2L["7b"] = Instance.new("ImageButton", G2L["77"]);
G2L["7b"]["BorderSizePixel"] = 0;
G2L["7b"]["ImageTransparency"] = 0.4;
G2L["7b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7b"]["Image"] = [[rbxassetid://10723346158]];
G2L["7b"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["7b"]["BackgroundTransparency"] = 1;
G2L["7b"]["Name"] = [[Clear]];
G2L["7b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7b"]["Position"] = UDim2.new(0.07265, 0, 0.17647, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Clear.LocalScript
G2L["7c"] = Instance.new("LocalScript", G2L["7b"]);



-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.DLine
G2L["7d"] = Instance.new("Frame", G2L["77"]);
G2L["7d"]["BorderSizePixel"] = 0;
G2L["7d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7d"]["Size"] = UDim2.new(0, 466, 0, 1);
G2L["7d"]["Position"] = UDim2.new(0, 0, 2, 0);
G2L["7d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7d"]["Name"] = [[DLine]];
G2L["7d"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Tab
G2L["7e"] = Instance.new("ImageButton", G2L["77"]);
G2L["7e"]["BorderSizePixel"] = 0;
G2L["7e"]["ImageTransparency"] = 0.4;
G2L["7e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7e"]["Image"] = [[rbxassetid://10734924532]];
G2L["7e"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["7e"]["BackgroundTransparency"] = 1;
G2L["7e"]["Name"] = [[Tab]];
G2L["7e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7e"]["Position"] = UDim2.new(0.14844, 0, 0.17647, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.TabHolder
G2L["7f"] = Instance.new("Frame", G2L["67"]);
G2L["7f"]["BorderSizePixel"] = 0;
G2L["7f"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["7f"]["Size"] = UDim2.new(0, 397, 0, 318);
G2L["7f"]["Position"] = UDim2.new(0.36133, 0, 0.18812, 0);
G2L["7f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7f"]["Name"] = [[TabHolder]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.TabHolder.Tab0
G2L["80"] = Instance.new("TextBox", G2L["7f"]);
G2L["80"]["TextColor3"] = Color3.fromRGB(199, 199, 199);
G2L["80"]["BorderSizePixel"] = 0;
G2L["80"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["80"]["TextSize"] = 14;
G2L["80"]["Name"] = [[Tab0]];
G2L["80"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["80"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["80"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["80"]["PlaceholderText"] = [[--Storm Softworks]];
G2L["80"]["Size"] = UDim2.new(0, 397, 0, 318);
G2L["80"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["80"]["Text"] = [[]];
G2L["80"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs
G2L["81"] = Instance.new("Frame", G2L["67"]);
G2L["81"]["BorderSizePixel"] = 0;
G2L["81"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["81"]["Size"] = UDim2.new(0, 410, 0, 33);
G2L["81"]["Position"] = UDim2.new(0.35182, 0, 0.08663, 0);
G2L["81"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["81"]["Name"] = [[Tabs]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.UIListLayout
G2L["82"] = Instance.new("UIListLayout", G2L["81"]);
G2L["82"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["82"]["FillDirection"] = Enum.FillDirection.Horizontal;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager
G2L["83"] = Instance.new("LocalScript", G2L["81"]);
G2L["83"]["Name"] = [[TabManager]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager.Tab0
G2L["84"] = Instance.new("Frame", G2L["83"]);
G2L["84"]["BorderSizePixel"] = 0;
G2L["84"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["84"]["Size"] = UDim2.new(0, 82, 0, 33);
G2L["84"]["Position"] = UDim2.new(0.76829, 0, 0, 0);
G2L["84"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["84"]["Name"] = [[Tab0]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager.Tab0.DLine
G2L["85"] = Instance.new("Frame", G2L["84"]);
G2L["85"]["BorderSizePixel"] = 0;
G2L["85"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["85"]["Size"] = UDim2.new(0, 1, 0, 33);
G2L["85"]["Position"] = UDim2.new(1, 0, 0, 0);
G2L["85"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["85"]["Name"] = [[DLine]];
G2L["85"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager.Tab0.TextButton
G2L["86"] = Instance.new("TextButton", G2L["84"]);
G2L["86"]["BorderSizePixel"] = 0;
G2L["86"]["AutoButtonColor"] = false;
G2L["86"]["TextTransparency"] = 1;
G2L["86"]["TextSize"] = 14;
G2L["86"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["86"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["86"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["86"]["Size"] = UDim2.new(0, 82, 0, 33);
G2L["86"]["BackgroundTransparency"] = 1;
G2L["86"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager.Tab0.TextLabel
G2L["87"] = Instance.new("TextLabel", G2L["84"]);
G2L["87"]["BorderSizePixel"] = 0;
G2L["87"]["TextTransparency"] = 0.4;
G2L["87"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["87"]["TextSize"] = 14;
G2L["87"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["87"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["87"]["BackgroundTransparency"] = 1;
G2L["87"]["Size"] = UDim2.new(0, 69, 0, 33);
G2L["87"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["87"]["Text"] = [[#1]];


-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager.Tab0.Close
G2L["88"] = Instance.new("ImageButton", G2L["84"]);
G2L["88"]["BorderSizePixel"] = 0;
G2L["88"]["ImageTransparency"] = 0.4;
G2L["88"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["88"]["Image"] = [[rbxassetid://10747384394]];
G2L["88"]["Size"] = UDim2.new(0, 14, 0, 14);
G2L["88"]["BackgroundTransparency"] = 1;
G2L["88"]["Name"] = [[Close]];
G2L["88"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["88"]["Position"] = UDim2.new(0.671, 0, 0.301, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Executor.CurrentTab
G2L["89"] = Instance.new("ObjectValue", G2L["67"]);
G2L["89"]["Name"] = [[CurrentTab]];
-- [ERROR] cannot convert Value, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub
G2L["8a"] = Instance.new("Frame", G2L["66"]);
G2L["8a"]["Visible"] = false;
G2L["8a"]["BorderSizePixel"] = 0;
G2L["8a"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["8a"]["Size"] = UDim2.new(0, 631, 0, 403);
G2L["8a"]["Position"] = UDim2.new(0.00634, 0, 0, 0);
G2L["8a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8a"]["Name"] = [[ScriptHub]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Box
G2L["8b"] = Instance.new("Frame", G2L["8a"]);
G2L["8b"]["BorderSizePixel"] = 0;
G2L["8b"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["8b"]["Size"] = UDim2.new(0, 613, 0, 31);
G2L["8b"]["Position"] = UDim2.new(0.01426, 0, 0.01985, 0);
G2L["8b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8b"]["Name"] = [[Box]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Box.UICorner
G2L["8c"] = Instance.new("UICorner", G2L["8b"]);
G2L["8c"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Box.UIStroke
G2L["8d"] = Instance.new("UIStroke", G2L["8b"]);
G2L["8d"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["8d"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Box.ImageLabel
G2L["8e"] = Instance.new("ImageLabel", G2L["8b"]);
G2L["8e"]["BorderSizePixel"] = 0;
G2L["8e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8e"]["ImageTransparency"] = 0.4;
G2L["8e"]["Image"] = [[http://www.roblox.com/asset/?id=6031154871]];
G2L["8e"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["8e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8e"]["BackgroundTransparency"] = 1;
G2L["8e"]["Position"] = UDim2.new(0.01142, 0, 0.16129, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Box.TextBox
G2L["8f"] = Instance.new("TextBox", G2L["8b"]);
G2L["8f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8f"]["BorderSizePixel"] = 0;
G2L["8f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["8f"]["TextTransparency"] = 0.4;
G2L["8f"]["TextSize"] = 14;
G2L["8f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8f"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8f"]["PlaceholderText"] = [[Search Anything]];
G2L["8f"]["Size"] = UDim2.new(0, 516, 0, 24);
G2L["8f"]["Position"] = UDim2.new(0.05383, 0, 0.09677, 0);
G2L["8f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8f"]["Text"] = [[]];
G2L["8f"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Manager
G2L["90"] = Instance.new("LocalScript", G2L["8a"]);
G2L["90"]["Name"] = [[Manager]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage
G2L["91"] = Instance.new("Folder", G2L["8a"]);
G2L["91"]["Name"] = [[controlPage]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PageCount
G2L["92"] = Instance.new("Frame", G2L["91"]);
G2L["92"]["BorderSizePixel"] = 0;
G2L["92"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["92"]["Size"] = UDim2.new(0, 71, 0, 29);
G2L["92"]["Position"] = UDim2.new(0.07132, 0, 0.11663, 0);
G2L["92"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["92"]["Name"] = [[PageCount]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PageCount.UICorner
G2L["93"] = Instance.new("UICorner", G2L["92"]);
G2L["93"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PageCount.UIStroke
G2L["94"] = Instance.new("UIStroke", G2L["92"]);
G2L["94"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["94"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PageCount.TextLabel
G2L["95"] = Instance.new("TextLabel", G2L["92"]);
G2L["95"]["BorderSizePixel"] = 0;
G2L["95"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["95"]["TextSize"] = 16;
G2L["95"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["95"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["95"]["BackgroundTransparency"] = 1;
G2L["95"]["Size"] = UDim2.new(0, 69, 0, 29);
G2L["95"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["95"]["Text"] = [[1 / 5]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.IncreasePage
G2L["96"] = Instance.new("Frame", G2L["91"]);
G2L["96"]["BorderSizePixel"] = 0;
G2L["96"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["96"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["96"]["Position"] = UDim2.new(0.19334, 0, 0.11663, 0);
G2L["96"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["96"]["Name"] = [[IncreasePage]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.IncreasePage.UICorner
G2L["97"] = Instance.new("UICorner", G2L["96"]);
G2L["97"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.IncreasePage.UIStroke
G2L["98"] = Instance.new("UIStroke", G2L["96"]);
G2L["98"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["98"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.IncreasePage.ImageButton
G2L["99"] = Instance.new("ImageButton", G2L["96"]);
G2L["99"]["BorderSizePixel"] = 0;
G2L["99"]["ImageTransparency"] = 0.6;
G2L["99"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["99"]["Image"] = [[http://www.roblox.com/asset/?id=6034818365]];
G2L["99"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["99"]["BackgroundTransparency"] = 1;
G2L["99"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["99"]["Position"] = UDim2.new(0.10345, 0, 0.10345, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.DecreasePage
G2L["9a"] = Instance.new("Frame", G2L["91"]);
G2L["9a"]["BorderSizePixel"] = 0;
G2L["9a"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["9a"]["Size"] = UDim2.new(0, 29, 0, 29);
G2L["9a"]["Position"] = UDim2.new(0.01426, 0, 0.11663, 0);
G2L["9a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9a"]["Name"] = [[DecreasePage]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.DecreasePage.UICorner
G2L["9b"] = Instance.new("UICorner", G2L["9a"]);
G2L["9b"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.DecreasePage.UIStroke
G2L["9c"] = Instance.new("UIStroke", G2L["9a"]);
G2L["9c"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["9c"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.DecreasePage.ImageButton
G2L["9d"] = Instance.new("ImageButton", G2L["9a"]);
G2L["9d"]["BorderSizePixel"] = 0;
G2L["9d"]["ImageTransparency"] = 0.6;
G2L["9d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9d"]["Image"] = [[http://www.roblox.com/asset/?id=6034818375]];
G2L["9d"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["9d"]["BackgroundTransparency"] = 1;
G2L["9d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9d"]["Position"] = UDim2.new(0.10345, 0, 0.10345, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PagesManager
G2L["9e"] = Instance.new("LocalScript", G2L["91"]);
G2L["9e"]["Name"] = [[PagesManager]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages
G2L["9f"] = Instance.new("Folder", G2L["8a"]);
G2L["9f"]["Name"] = [[Pages]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1
G2L["a0"] = Instance.new("Frame", G2L["9f"]);
G2L["a0"]["BorderSizePixel"] = 0;
G2L["a0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a0"]["Size"] = UDim2.new(0, 609, 0, 304);
G2L["a0"]["Position"] = UDim2.new(0.014, 0, 0.216, 0);
G2L["a0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a0"]["Name"] = [[Page1]];
G2L["a0"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame
G2L["a1"] = Instance.new("ScrollingFrame", G2L["a0"]);
G2L["a1"]["Active"] = true;
G2L["a1"]["BorderSizePixel"] = 0;
G2L["a1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a1"]["Size"] = UDim2.new(0, 609, 0, 304);
G2L["a1"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a1"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a1"]["ScrollBarThickness"] = 0;
G2L["a1"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame
G2L["a2"] = Instance.new("Frame", G2L["a1"]);
G2L["a2"]["BorderSizePixel"] = 0;
G2L["a2"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["a2"]["Size"] = UDim2.new(0, 298, 0, 205);
G2L["a2"]["Position"] = UDim2.new(0.004, 0, 0.001, 0);
G2L["a2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image
G2L["a3"] = Instance.new("Frame", G2L["a2"]);
G2L["a3"]["BorderSizePixel"] = 0;
G2L["a3"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["a3"]["Size"] = UDim2.new(0, 276, 0, 92);
G2L["a3"]["Position"] = UDim2.new(0.03944, 0, 0.03369, 0);
G2L["a3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a3"]["Name"] = [[Image]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.ImageLabel
G2L["a4"] = Instance.new("ImageLabel", G2L["a3"]);
G2L["a4"]["ZIndex"] = -1;
G2L["a4"]["BorderSizePixel"] = 0;
G2L["a4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a4"]["Image"] = [[http://www.roblox.com/asset/?id=7073873268]];
G2L["a4"]["Size"] = UDim2.new(0, 263, 0, 156);
G2L["a4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a4"]["BackgroundTransparency"] = 1;
G2L["a4"]["Position"] = UDim2.new(-0.00084, 0, -0.40929, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UICorner
G2L["a5"] = Instance.new("UICorner", G2L["a3"]);
G2L["a5"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UIStroke
G2L["a6"] = Instance.new("UIStroke", G2L["a3"]);
G2L["a6"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["a6"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator
G2L["a7"] = Instance.new("TextLabel", G2L["a2"]);
G2L["a7"]["BorderSizePixel"] = 0;
G2L["a7"]["BackgroundColor3"] = Color3.fromRGB(43, 62, 191);
G2L["a7"]["TextSize"] = 16;
G2L["a7"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["a7"]["TextColor3"] = Color3.fromRGB(6, 135, 204);
G2L["a7"]["Size"] = UDim2.new(0, 90, 0, 22);
G2L["a7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a7"]["Text"] = [[Universal]];
G2L["a7"]["Name"] = [[Indicator]];
G2L["a7"]["Position"] = UDim2.new(0.67951, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UICorner
G2L["a8"] = Instance.new("UICorner", G2L["a7"]);
G2L["a8"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UIStroke
G2L["a9"] = Instance.new("UIStroke", G2L["a7"]);
G2L["a9"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["a9"]["Color"] = Color3.fromRGB(11, 26, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton
G2L["aa"] = Instance.new("ImageButton", G2L["a2"]);
G2L["aa"]["BorderSizePixel"] = 0;
G2L["aa"]["AutoButtonColor"] = false;
G2L["aa"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["aa"]["ImageColor3"] = Color3.fromRGB(149, 149, 149);
G2L["aa"]["Image"] = [[http://www.roblox.com/asset/?id=6026663705]];
G2L["aa"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["aa"]["BackgroundTransparency"] = 1;
G2L["aa"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["aa"]["Position"] = UDim2.new(0.03663, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["ab"] = Instance.new("LocalScript", G2L["aa"]);



-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Title
G2L["ac"] = Instance.new("TextLabel", G2L["a2"]);
G2L["ac"]["BorderSizePixel"] = 0;
G2L["ac"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["ac"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ac"]["TextSize"] = 16;
G2L["ac"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ac"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["ac"]["BackgroundTransparency"] = 1;
G2L["ac"]["Size"] = UDim2.new(0, 276, 0, 22);
G2L["ac"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ac"]["Text"] = [[Infinite Yeild]];
G2L["ac"]["Name"] = [[Title]];
G2L["ac"]["Position"] = UDim2.new(0.04224, 0, 0.50998, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UIStroke
G2L["ad"] = Instance.new("UIStroke", G2L["a2"]);
G2L["ad"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["ad"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UICorner
G2L["ae"] = Instance.new("UICorner", G2L["a2"]);
G2L["ae"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.TextLabel
G2L["af"] = Instance.new("TextLabel", G2L["a2"]);
G2L["af"]["TextWrapped"] = true;
G2L["af"]["BorderSizePixel"] = 0;
G2L["af"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["af"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["af"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["af"]["TextSize"] = 13;
G2L["af"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["af"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["af"]["BackgroundTransparency"] = 1;
G2L["af"]["Size"] = UDim2.new(0, 276, 0, 56);
G2L["af"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["af"]["Text"] = [[An Remote Administrator Script]];
G2L["af"]["Position"] = UDim2.new(0.04224, 0, 0.62411, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame
G2L["b0"] = Instance.new("Frame", G2L["a1"]);
G2L["b0"]["BorderSizePixel"] = 0;
G2L["b0"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["b0"]["Size"] = UDim2.new(0, 298, 0, 205);
G2L["b0"]["Position"] = UDim2.new(0.508, 0, 0.001, 0);
G2L["b0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image
G2L["b1"] = Instance.new("Frame", G2L["b0"]);
G2L["b1"]["BorderSizePixel"] = 0;
G2L["b1"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["b1"]["Size"] = UDim2.new(0, 276, 0, 92);
G2L["b1"]["Position"] = UDim2.new(0.03944, 0, 0.03369, 0);
G2L["b1"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b1"]["Name"] = [[Image]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.ImageLabel
G2L["b2"] = Instance.new("ImageLabel", G2L["b1"]);
G2L["b2"]["ZIndex"] = -1;
G2L["b2"]["BorderSizePixel"] = 0;
G2L["b2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b2"]["Image"] = [[http://www.roblox.com/asset/?id=7073873268]];
G2L["b2"]["Size"] = UDim2.new(0, 263, 0, 156);
G2L["b2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b2"]["BackgroundTransparency"] = 1;
G2L["b2"]["Position"] = UDim2.new(-0.00084, 0, -0.40929, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UICorner
G2L["b3"] = Instance.new("UICorner", G2L["b1"]);
G2L["b3"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UIStroke
G2L["b4"] = Instance.new("UIStroke", G2L["b1"]);
G2L["b4"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["b4"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator
G2L["b5"] = Instance.new("TextLabel", G2L["b0"]);
G2L["b5"]["BorderSizePixel"] = 0;
G2L["b5"]["BackgroundColor3"] = Color3.fromRGB(43, 62, 191);
G2L["b5"]["TextSize"] = 16;
G2L["b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b5"]["TextColor3"] = Color3.fromRGB(6, 135, 204);
G2L["b5"]["Size"] = UDim2.new(0, 90, 0, 22);
G2L["b5"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b5"]["Text"] = [[Universal]];
G2L["b5"]["Name"] = [[Indicator]];
G2L["b5"]["Position"] = UDim2.new(0.67951, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UICorner
G2L["b6"] = Instance.new("UICorner", G2L["b5"]);
G2L["b6"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UIStroke
G2L["b7"] = Instance.new("UIStroke", G2L["b5"]);
G2L["b7"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["b7"]["Color"] = Color3.fromRGB(11, 26, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton
G2L["b8"] = Instance.new("ImageButton", G2L["b0"]);
G2L["b8"]["BorderSizePixel"] = 0;
G2L["b8"]["AutoButtonColor"] = false;
G2L["b8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b8"]["ImageColor3"] = Color3.fromRGB(149, 149, 149);
G2L["b8"]["Image"] = [[http://www.roblox.com/asset/?id=6026663705]];
G2L["b8"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["b8"]["BackgroundTransparency"] = 1;
G2L["b8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b8"]["Position"] = UDim2.new(0.03663, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["b9"] = Instance.new("LocalScript", G2L["b8"]);



-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Title
G2L["ba"] = Instance.new("TextLabel", G2L["b0"]);
G2L["ba"]["BorderSizePixel"] = 0;
G2L["ba"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["ba"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ba"]["TextSize"] = 16;
G2L["ba"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ba"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["ba"]["BackgroundTransparency"] = 1;
G2L["ba"]["Size"] = UDim2.new(0, 276, 0, 22);
G2L["ba"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ba"]["Text"] = [[Infinite Yeild]];
G2L["ba"]["Name"] = [[Title]];
G2L["ba"]["Position"] = UDim2.new(0.04224, 0, 0.50998, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UIStroke
G2L["bb"] = Instance.new("UIStroke", G2L["b0"]);
G2L["bb"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["bb"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UICorner
G2L["bc"] = Instance.new("UICorner", G2L["b0"]);
G2L["bc"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.TextLabel
G2L["bd"] = Instance.new("TextLabel", G2L["b0"]);
G2L["bd"]["TextWrapped"] = true;
G2L["bd"]["BorderSizePixel"] = 0;
G2L["bd"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["bd"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["bd"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["bd"]["TextSize"] = 13;
G2L["bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["bd"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["bd"]["BackgroundTransparency"] = 1;
G2L["bd"]["Size"] = UDim2.new(0, 276, 0, 56);
G2L["bd"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["bd"]["Text"] = [[An Remote Administrator Script]];
G2L["bd"]["Position"] = UDim2.new(0.04224, 0, 0.62411, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame
G2L["be"] = Instance.new("Frame", G2L["a1"]);
G2L["be"]["BorderSizePixel"] = 0;
G2L["be"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["be"]["Size"] = UDim2.new(0, 298, 0, 205);
G2L["be"]["Position"] = UDim2.new(0.004, 0, 0.35, 0);
G2L["be"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image
G2L["bf"] = Instance.new("Frame", G2L["be"]);
G2L["bf"]["BorderSizePixel"] = 0;
G2L["bf"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["bf"]["Size"] = UDim2.new(0, 276, 0, 92);
G2L["bf"]["Position"] = UDim2.new(0.03944, 0, 0.03369, 0);
G2L["bf"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["bf"]["Name"] = [[Image]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.ImageLabel
G2L["c0"] = Instance.new("ImageLabel", G2L["bf"]);
G2L["c0"]["ZIndex"] = -1;
G2L["c0"]["BorderSizePixel"] = 0;
G2L["c0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c0"]["Image"] = [[http://www.roblox.com/asset/?id=7073873268]];
G2L["c0"]["Size"] = UDim2.new(0, 263, 0, 156);
G2L["c0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c0"]["BackgroundTransparency"] = 1;
G2L["c0"]["Position"] = UDim2.new(-0.00084, 0, -0.40929, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UICorner
G2L["c1"] = Instance.new("UICorner", G2L["bf"]);
G2L["c1"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UIStroke
G2L["c2"] = Instance.new("UIStroke", G2L["bf"]);
G2L["c2"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["c2"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator
G2L["c3"] = Instance.new("TextLabel", G2L["be"]);
G2L["c3"]["BorderSizePixel"] = 0;
G2L["c3"]["BackgroundColor3"] = Color3.fromRGB(43, 62, 191);
G2L["c3"]["TextSize"] = 16;
G2L["c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c3"]["TextColor3"] = Color3.fromRGB(6, 135, 204);
G2L["c3"]["Size"] = UDim2.new(0, 90, 0, 22);
G2L["c3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c3"]["Text"] = [[Universal]];
G2L["c3"]["Name"] = [[Indicator]];
G2L["c3"]["Position"] = UDim2.new(0.67951, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UICorner
G2L["c4"] = Instance.new("UICorner", G2L["c3"]);
G2L["c4"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UIStroke
G2L["c5"] = Instance.new("UIStroke", G2L["c3"]);
G2L["c5"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["c5"]["Color"] = Color3.fromRGB(11, 26, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton
G2L["c6"] = Instance.new("ImageButton", G2L["be"]);
G2L["c6"]["BorderSizePixel"] = 0;
G2L["c6"]["AutoButtonColor"] = false;
G2L["c6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c6"]["ImageColor3"] = Color3.fromRGB(149, 149, 149);
G2L["c6"]["Image"] = [[http://www.roblox.com/asset/?id=6026663705]];
G2L["c6"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["c6"]["BackgroundTransparency"] = 1;
G2L["c6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c6"]["Position"] = UDim2.new(0.03663, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["c7"] = Instance.new("LocalScript", G2L["c6"]);



-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Title
G2L["c8"] = Instance.new("TextLabel", G2L["be"]);
G2L["c8"]["BorderSizePixel"] = 0;
G2L["c8"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["c8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c8"]["TextSize"] = 16;
G2L["c8"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c8"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["c8"]["BackgroundTransparency"] = 1;
G2L["c8"]["Size"] = UDim2.new(0, 276, 0, 22);
G2L["c8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c8"]["Text"] = [[Infinite Yeild]];
G2L["c8"]["Name"] = [[Title]];
G2L["c8"]["Position"] = UDim2.new(0.04224, 0, 0.50998, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UIStroke
G2L["c9"] = Instance.new("UIStroke", G2L["be"]);
G2L["c9"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["c9"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UICorner
G2L["ca"] = Instance.new("UICorner", G2L["be"]);
G2L["ca"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.TextLabel
G2L["cb"] = Instance.new("TextLabel", G2L["be"]);
G2L["cb"]["TextWrapped"] = true;
G2L["cb"]["BorderSizePixel"] = 0;
G2L["cb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["cb"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["cb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["cb"]["TextSize"] = 13;
G2L["cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["cb"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["cb"]["BackgroundTransparency"] = 1;
G2L["cb"]["Size"] = UDim2.new(0, 276, 0, 56);
G2L["cb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["cb"]["Text"] = [[An Remote Administrator Script]];
G2L["cb"]["Position"] = UDim2.new(0.04224, 0, 0.62411, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame
G2L["cc"] = Instance.new("Frame", G2L["a1"]);
G2L["cc"]["BorderSizePixel"] = 0;
G2L["cc"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["cc"]["Size"] = UDim2.new(0, 298, 0, 205);
G2L["cc"]["Position"] = UDim2.new(0.508, 0, 0.35, 0);
G2L["cc"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image
G2L["cd"] = Instance.new("Frame", G2L["cc"]);
G2L["cd"]["BorderSizePixel"] = 0;
G2L["cd"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["cd"]["Size"] = UDim2.new(0, 276, 0, 92);
G2L["cd"]["Position"] = UDim2.new(0.03944, 0, 0.03369, 0);
G2L["cd"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["cd"]["Name"] = [[Image]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.ImageLabel
G2L["ce"] = Instance.new("ImageLabel", G2L["cd"]);
G2L["ce"]["ZIndex"] = -1;
G2L["ce"]["BorderSizePixel"] = 0;
G2L["ce"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ce"]["Image"] = [[http://www.roblox.com/asset/?id=7073873268]];
G2L["ce"]["Size"] = UDim2.new(0, 263, 0, 156);
G2L["ce"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ce"]["BackgroundTransparency"] = 1;
G2L["ce"]["Position"] = UDim2.new(-0.00084, 0, -0.40929, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UICorner
G2L["cf"] = Instance.new("UICorner", G2L["cd"]);
G2L["cf"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Image.UIStroke
G2L["d0"] = Instance.new("UIStroke", G2L["cd"]);
G2L["d0"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["d0"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator
G2L["d1"] = Instance.new("TextLabel", G2L["cc"]);
G2L["d1"]["BorderSizePixel"] = 0;
G2L["d1"]["BackgroundColor3"] = Color3.fromRGB(43, 62, 191);
G2L["d1"]["TextSize"] = 16;
G2L["d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["d1"]["TextColor3"] = Color3.fromRGB(6, 135, 204);
G2L["d1"]["Size"] = UDim2.new(0, 90, 0, 22);
G2L["d1"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d1"]["Text"] = [[Universal]];
G2L["d1"]["Name"] = [[Indicator]];
G2L["d1"]["Position"] = UDim2.new(0.67951, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UICorner
G2L["d2"] = Instance.new("UICorner", G2L["d1"]);
G2L["d2"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Indicator.UIStroke
G2L["d3"] = Instance.new("UIStroke", G2L["d1"]);
G2L["d3"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["d3"]["Color"] = Color3.fromRGB(11, 26, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton
G2L["d4"] = Instance.new("ImageButton", G2L["cc"]);
G2L["d4"]["BorderSizePixel"] = 0;
G2L["d4"]["AutoButtonColor"] = false;
G2L["d4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d4"]["ImageColor3"] = Color3.fromRGB(149, 149, 149);
G2L["d4"]["Image"] = [[http://www.roblox.com/asset/?id=6026663705]];
G2L["d4"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["d4"]["BackgroundTransparency"] = 1;
G2L["d4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d4"]["Position"] = UDim2.new(0.03663, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["d5"] = Instance.new("LocalScript", G2L["d4"]);



-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.Title
G2L["d6"] = Instance.new("TextLabel", G2L["cc"]);
G2L["d6"]["BorderSizePixel"] = 0;
G2L["d6"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["d6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d6"]["TextSize"] = 16;
G2L["d6"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d6"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["d6"]["BackgroundTransparency"] = 1;
G2L["d6"]["Size"] = UDim2.new(0, 276, 0, 22);
G2L["d6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d6"]["Text"] = [[Infinite Yeild]];
G2L["d6"]["Name"] = [[Title]];
G2L["d6"]["Position"] = UDim2.new(0.04224, 0, 0.50998, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UIStroke
G2L["d7"] = Instance.new("UIStroke", G2L["cc"]);
G2L["d7"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["d7"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.UICorner
G2L["d8"] = Instance.new("UICorner", G2L["cc"]);
G2L["d8"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.TextLabel
G2L["d9"] = Instance.new("TextLabel", G2L["cc"]);
G2L["d9"]["TextWrapped"] = true;
G2L["d9"]["BorderSizePixel"] = 0;
G2L["d9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["d9"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["d9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d9"]["TextSize"] = 13;
G2L["d9"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d9"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["d9"]["BackgroundTransparency"] = 1;
G2L["d9"]["Size"] = UDim2.new(0, 276, 0, 56);
G2L["d9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d9"]["Text"] = [[An Remote Administrator Script]];
G2L["d9"]["Position"] = UDim2.new(0.04224, 0, 0.62411, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2
G2L["da"] = Instance.new("Frame", G2L["9f"]);
G2L["da"]["Visible"] = false;
G2L["da"]["BorderSizePixel"] = 0;
G2L["da"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["da"]["Size"] = UDim2.new(0, 609, 0, 304);
G2L["da"]["Position"] = UDim2.new(0.014, 0, 0.216, 0);
G2L["da"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["da"]["Name"] = [[Page2]];
G2L["da"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame
G2L["db"] = Instance.new("ScrollingFrame", G2L["da"]);
G2L["db"]["Active"] = true;
G2L["db"]["BorderSizePixel"] = 0;
G2L["db"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["db"]["Size"] = UDim2.new(0, 609, 0, 304);
G2L["db"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["db"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["db"]["ScrollBarThickness"] = 0;
G2L["db"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame
G2L["dc"] = Instance.new("Frame", G2L["db"]);
G2L["dc"]["BorderSizePixel"] = 0;
G2L["dc"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["dc"]["Size"] = UDim2.new(0, 298, 0, 205);
G2L["dc"]["Position"] = UDim2.new(0.004, 0, 0.001, 0);
G2L["dc"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Image
G2L["dd"] = Instance.new("Frame", G2L["dc"]);
G2L["dd"]["BorderSizePixel"] = 0;
G2L["dd"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["dd"]["Size"] = UDim2.new(0, 276, 0, 92);
G2L["dd"]["Position"] = UDim2.new(0.03944, 0, 0.03369, 0);
G2L["dd"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["dd"]["Name"] = [[Image]];


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Image.ImageLabel
G2L["de"] = Instance.new("ImageLabel", G2L["dd"]);
G2L["de"]["ZIndex"] = -1;
G2L["de"]["BorderSizePixel"] = 0;
G2L["de"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["de"]["Image"] = [[http://www.roblox.com/asset/?id=7073873268]];
G2L["de"]["Size"] = UDim2.new(0, 263, 0, 156);
G2L["de"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["de"]["BackgroundTransparency"] = 1;
G2L["de"]["Position"] = UDim2.new(-0.00084, 0, -0.40929, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Image.UICorner
G2L["df"] = Instance.new("UICorner", G2L["dd"]);
G2L["df"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Image.UIStroke
G2L["e0"] = Instance.new("UIStroke", G2L["dd"]);
G2L["e0"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["e0"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Indicator
G2L["e1"] = Instance.new("TextLabel", G2L["dc"]);
G2L["e1"]["BorderSizePixel"] = 0;
G2L["e1"]["BackgroundColor3"] = Color3.fromRGB(43, 62, 191);
G2L["e1"]["TextSize"] = 16;
G2L["e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["e1"]["TextColor3"] = Color3.fromRGB(6, 135, 204);
G2L["e1"]["Size"] = UDim2.new(0, 90, 0, 22);
G2L["e1"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e1"]["Text"] = [[Universal]];
G2L["e1"]["Name"] = [[Indicator]];
G2L["e1"]["Position"] = UDim2.new(0.67951, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Indicator.UICorner
G2L["e2"] = Instance.new("UICorner", G2L["e1"]);
G2L["e2"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Indicator.UIStroke
G2L["e3"] = Instance.new("UIStroke", G2L["e1"]);
G2L["e3"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["e3"]["Color"] = Color3.fromRGB(11, 26, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.ImageButton
G2L["e4"] = Instance.new("ImageButton", G2L["dc"]);
G2L["e4"]["BorderSizePixel"] = 0;
G2L["e4"]["AutoButtonColor"] = false;
G2L["e4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e4"]["ImageColor3"] = Color3.fromRGB(149, 149, 149);
G2L["e4"]["Image"] = [[http://www.roblox.com/asset/?id=6026663705]];
G2L["e4"]["Size"] = UDim2.new(0, 22, 0, 22);
G2L["e4"]["BackgroundTransparency"] = 1;
G2L["e4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e4"]["Position"] = UDim2.new(0.03663, 0, 0.83957, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["e5"] = Instance.new("LocalScript", G2L["e4"]);



-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.Title
G2L["e6"] = Instance.new("TextLabel", G2L["dc"]);
G2L["e6"]["BorderSizePixel"] = 0;
G2L["e6"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["e6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e6"]["TextSize"] = 16;
G2L["e6"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e6"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["e6"]["BackgroundTransparency"] = 1;
G2L["e6"]["Size"] = UDim2.new(0, 276, 0, 22);
G2L["e6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e6"]["Text"] = [[Infinite Yeild]];
G2L["e6"]["Name"] = [[Title]];
G2L["e6"]["Position"] = UDim2.new(0.04224, 0, 0.50998, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.UIStroke
G2L["e7"] = Instance.new("UIStroke", G2L["dc"]);
G2L["e7"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["e7"]["Color"] = Color3.fromRGB(76, 76, 76);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.UICorner
G2L["e8"] = Instance.new("UICorner", G2L["dc"]);
G2L["e8"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.TextLabel
G2L["e9"] = Instance.new("TextLabel", G2L["dc"]);
G2L["e9"]["TextWrapped"] = true;
G2L["e9"]["BorderSizePixel"] = 0;
G2L["e9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["e9"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["e9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e9"]["TextSize"] = 13;
G2L["e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e9"]["TextColor3"] = Color3.fromRGB(149, 149, 149);
G2L["e9"]["BackgroundTransparency"] = 1;
G2L["e9"]["Size"] = UDim2.new(0, 276, 0, 56);
G2L["e9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e9"]["Text"] = [[An Remote Administrator Script]];
G2L["e9"]["Position"] = UDim2.new(0.04224, 0, 0.62411, 0);


-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Value
G2L["ea"] = Instance.new("ObjectValue", G2L["8a"]);
-- [ERROR] cannot convert Value, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.SSWorks.Main.ContentProvider.Settings
G2L["eb"] = Instance.new("Frame", G2L["66"]);
G2L["eb"]["Visible"] = false;
G2L["eb"]["BorderSizePixel"] = 0;
G2L["eb"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["eb"]["Size"] = UDim2.new(0, 631, 0, 404);
G2L["eb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["eb"]["Name"] = [[Settings]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame
G2L["ec"] = Instance.new("ScrollingFrame", G2L["eb"]);
G2L["ec"]["Active"] = true;
G2L["ec"]["BorderSizePixel"] = 0;
G2L["ec"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ec"]["Size"] = UDim2.new(0, 615, 0, 393);
G2L["ec"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ec"]["Position"] = UDim2.new(0.014, 0, 0.01485, 0);
G2L["ec"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ec"]["ScrollBarThickness"] = 0;
G2L["ec"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.UIListLayout
G2L["ed"] = Instance.new("UIListLayout", G2L["ec"]);
G2L["ed"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["ed"]["Padding"] = UDim.new(0, 5);
G2L["ed"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame
G2L["ee"] = Instance.new("Frame", G2L["ec"]);
G2L["ee"]["BorderSizePixel"] = 0;
G2L["ee"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["ee"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["ee"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["ee"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.UICorner
G2L["ef"] = Instance.new("UICorner", G2L["ee"]);
G2L["ef"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["f0"] = Instance.new("TextLabel", G2L["ee"]);
G2L["f0"]["BorderSizePixel"] = 0;
G2L["f0"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["f0"]["TextTransparency"] = 0.4;
G2L["f0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f0"]["TextSize"] = 16;
G2L["f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f0"]["BackgroundTransparency"] = 1;
G2L["f0"]["Size"] = UDim2.new(0, 522, 0, 21);
G2L["f0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f0"]["Text"] = [[Themes]];
G2L["f0"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["f1"] = Instance.new("TextLabel", G2L["ee"]);
G2L["f1"]["BorderSizePixel"] = 0;
G2L["f1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["f1"]["TextTransparency"] = 0.4;
G2L["f1"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["f1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f1"]["TextSize"] = 14;
G2L["f1"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f1"]["BackgroundTransparency"] = 1;
G2L["f1"]["Size"] = UDim2.new(0, 522, 0, 26);
G2L["f1"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f1"]["Text"] = [[Set's the GroupColor of the UI to chosen Theme on the dropdown menu]];
G2L["f1"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextButton
G2L["f2"] = Instance.new("TextButton", G2L["ee"]);
G2L["f2"]["BorderSizePixel"] = 0;
G2L["f2"]["AutoButtonColor"] = false;
G2L["f2"]["TextSize"] = 14;
G2L["f2"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f2"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["f2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f2"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["f2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f2"]["Text"] = [[]];
G2L["f2"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextButton.UICorner
G2L["f3"] = Instance.new("UICorner", G2L["f2"]);
G2L["f3"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextButton.LocalScript
G2L["f4"] = Instance.new("LocalScript", G2L["f2"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown
G2L["f5"] = Instance.new("Frame", G2L["ee"]);
G2L["f5"]["Visible"] = false;
G2L["f5"]["ZIndex"] = 2;
G2L["f5"]["BorderSizePixel"] = 0;
G2L["f5"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["f5"]["Size"] = UDim2.new(0, 137, 0, 150);
G2L["f5"]["Position"] = UDim2.new(0.71336, 0, 0.88525, 0);
G2L["f5"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f5"]["Name"] = [[Dropdown]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UICorner
G2L["f6"] = Instance.new("UICorner", G2L["f5"]);
G2L["f6"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UIListLayout
G2L["f7"] = Instance.new("UIListLayout", G2L["f5"]);
G2L["f7"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UIStroke
G2L["f8"] = Instance.new("UIStroke", G2L["f5"]);
G2L["f8"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton
G2L["f9"] = Instance.new("TextButton", G2L["f5"]);
G2L["f9"]["BorderSizePixel"] = 0;
G2L["f9"]["AutoButtonColor"] = false;
G2L["f9"]["TextSize"] = 14;
G2L["f9"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["f9"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f9"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["f9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f9"]["Text"] = [[Red]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.UIStroke
G2L["fa"] = Instance.new("UIStroke", G2L["f9"]);
G2L["fa"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["fa"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
G2L["fb"] = Instance.new("LocalScript", G2L["f9"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.UICorner
G2L["fc"] = Instance.new("UICorner", G2L["f9"]);
G2L["fc"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton
G2L["fd"] = Instance.new("TextButton", G2L["f5"]);
G2L["fd"]["BorderSizePixel"] = 0;
G2L["fd"]["AutoButtonColor"] = false;
G2L["fd"]["TextSize"] = 14;
G2L["fd"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["fd"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["fd"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["fd"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["fd"]["Text"] = [[Blue]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.UIStroke
G2L["fe"] = Instance.new("UIStroke", G2L["fd"]);
G2L["fe"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["fe"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
G2L["ff"] = Instance.new("LocalScript", G2L["fd"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton
G2L["100"] = Instance.new("TextButton", G2L["f5"]);
G2L["100"]["BorderSizePixel"] = 0;
G2L["100"]["AutoButtonColor"] = false;
G2L["100"]["TextSize"] = 14;
G2L["100"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["100"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["100"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["100"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["100"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["100"]["Text"] = [[Cyan]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.UIStroke
G2L["101"] = Instance.new("UIStroke", G2L["100"]);
G2L["101"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["101"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
G2L["102"] = Instance.new("LocalScript", G2L["100"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextBox
G2L["103"] = Instance.new("TextBox", G2L["f5"]);
G2L["103"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["103"]["BorderSizePixel"] = 0;
G2L["103"]["TextWrapped"] = true;
G2L["103"]["TextSize"] = 14;
G2L["103"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["103"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["103"]["PlaceholderText"] = [[Colors: 10 --> 255. only one number]];
G2L["103"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["103"]["Position"] = UDim2.new(0, 0, 0.7, 0);
G2L["103"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["103"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextBox.UIStroke
G2L["104"] = Instance.new("UIStroke", G2L["103"]);
G2L["104"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["104"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextBox.LocalScript
G2L["105"] = Instance.new("LocalScript", G2L["103"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton
G2L["106"] = Instance.new("ImageButton", G2L["ee"]);
G2L["106"]["BorderSizePixel"] = 0;
G2L["106"]["AutoButtonColor"] = false;
G2L["106"]["ImageTransparency"] = 0.4;
G2L["106"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["106"]["Image"] = [[http://www.roblox.com/asset/?id=6031091004]];
G2L["106"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["106"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["106"]["Position"] = UDim2.new(0.88436, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.UICorner
G2L["107"] = Instance.new("UICorner", G2L["106"]);
G2L["107"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["108"] = Instance.new("LocalScript", G2L["106"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.SelectedValue
G2L["109"] = Instance.new("StringValue", G2L["ee"]);
G2L["109"]["Name"] = [[SelectedValue]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame
G2L["10a"] = Instance.new("Frame", G2L["ec"]);
G2L["10a"]["BorderSizePixel"] = 0;
G2L["10a"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["10a"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["10a"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["10a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.UICorner
G2L["10b"] = Instance.new("UICorner", G2L["10a"]);
G2L["10b"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["10c"] = Instance.new("TextLabel", G2L["10a"]);
G2L["10c"]["BorderSizePixel"] = 0;
G2L["10c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["10c"]["TextTransparency"] = 0.4;
G2L["10c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10c"]["TextSize"] = 16;
G2L["10c"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["10c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10c"]["BackgroundTransparency"] = 1;
G2L["10c"]["Size"] = UDim2.new(0, 522, 0, 21);
G2L["10c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10c"]["Text"] = [[Config]];
G2L["10c"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["10d"] = Instance.new("TextLabel", G2L["10a"]);
G2L["10d"]["BorderSizePixel"] = 0;
G2L["10d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["10d"]["TextTransparency"] = 0.4;
G2L["10d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["10d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10d"]["TextSize"] = 14;
G2L["10d"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["10d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10d"]["BackgroundTransparency"] = 1;
G2L["10d"]["Size"] = UDim2.new(0, 522, 0, 26);
G2L["10d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10d"]["Text"] = [[Set's up the configurations you chose]];
G2L["10d"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown
G2L["10e"] = Instance.new("Frame", G2L["10a"]);
G2L["10e"]["Visible"] = false;
G2L["10e"]["ZIndex"] = 2;
G2L["10e"]["BorderSizePixel"] = 0;
G2L["10e"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["10e"]["Size"] = UDim2.new(0, 235, 0, 245);
G2L["10e"]["Position"] = UDim2.new(0.59446, 0, 0.88525, 0);
G2L["10e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10e"]["Name"] = [[Dropdown]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UICorner
G2L["10f"] = Instance.new("UICorner", G2L["10e"]);
G2L["10f"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UIStroke
G2L["110"] = Instance.new("UIStroke", G2L["10e"]);
G2L["110"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame
G2L["111"] = Instance.new("ScrollingFrame", G2L["10e"]);
G2L["111"]["Active"] = true;
G2L["111"]["BorderSizePixel"] = 0;
G2L["111"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["111"]["Size"] = UDim2.new(0, 235, 0, 245);
G2L["111"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["111"]["ScrollBarThickness"] = 0;
G2L["111"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.UIGridLayout
G2L["112"] = Instance.new("UIGridLayout", G2L["111"]);
G2L["112"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["112"]["CellSize"] = UDim2.new(0, 235, 0, 30);
G2L["112"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["112"]["CellPadding"] = UDim2.new(0, 0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame
G2L["113"] = Instance.new("Frame", G2L["111"]);
G2L["113"]["BorderSizePixel"] = 0;
G2L["113"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["113"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["113"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextLabel
G2L["114"] = Instance.new("TextLabel", G2L["113"]);
G2L["114"]["BorderSizePixel"] = 0;
G2L["114"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["114"]["TextSize"] = 14;
G2L["114"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["114"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["114"]["BackgroundTransparency"] = 1;
G2L["114"]["Size"] = UDim2.new(0, 132, 0, 30);
G2L["114"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["114"]["Text"] = [[Aim Assist Smooth]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.Frame
G2L["115"] = Instance.new("Frame", G2L["113"]);
G2L["115"]["BorderSizePixel"] = 0;
G2L["115"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["115"]["Size"] = UDim2.new(0, 1, 0, 30);
G2L["115"]["Position"] = UDim2.new(0.5617, 0, 0, 0);
G2L["115"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["115"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox
G2L["116"] = Instance.new("TextBox", G2L["113"]);
G2L["116"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["116"]["BorderSizePixel"] = 0;
G2L["116"]["TextWrapped"] = true;
G2L["116"]["TextSize"] = 14;
G2L["116"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["116"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["116"]["PlaceholderText"] = [[0 --> 1]];
G2L["116"]["Size"] = UDim2.new(0, 102, 0, 30);
G2L["116"]["Position"] = UDim2.new(0.56344, 0, 0, 0);
G2L["116"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["116"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
G2L["117"] = Instance.new("LocalScript", G2L["116"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.UIStroke
G2L["118"] = Instance.new("UIStroke", G2L["113"]);
G2L["118"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame
G2L["119"] = Instance.new("Frame", G2L["111"]);
G2L["119"]["BorderSizePixel"] = 0;
G2L["119"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["119"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["119"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextLabel
G2L["11a"] = Instance.new("TextLabel", G2L["119"]);
G2L["11a"]["BorderSizePixel"] = 0;
G2L["11a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["11a"]["TextSize"] = 14;
G2L["11a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["11a"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["11a"]["BackgroundTransparency"] = 1;
G2L["11a"]["Size"] = UDim2.new(0, 132, 0, 30);
G2L["11a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11a"]["Text"] = [[Aim Assist Part]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.Frame
G2L["11b"] = Instance.new("Frame", G2L["119"]);
G2L["11b"]["BorderSizePixel"] = 0;
G2L["11b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["11b"]["Size"] = UDim2.new(0, 1, 0, 30);
G2L["11b"]["Position"] = UDim2.new(0.5617, 0, 0, 0);
G2L["11b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11b"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox
G2L["11c"] = Instance.new("TextBox", G2L["119"]);
G2L["11c"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["11c"]["BorderSizePixel"] = 0;
G2L["11c"]["TextWrapped"] = true;
G2L["11c"]["TextSize"] = 14;
G2L["11c"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["11c"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["11c"]["PlaceholderText"] = [[Head]];
G2L["11c"]["Size"] = UDim2.new(0, 102, 0, 30);
G2L["11c"]["Position"] = UDim2.new(0.56344, 0, 0, 0);
G2L["11c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11c"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
G2L["11d"] = Instance.new("LocalScript", G2L["11c"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.UIStroke
G2L["11e"] = Instance.new("UIStroke", G2L["119"]);
G2L["11e"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame
G2L["11f"] = Instance.new("Frame", G2L["111"]);
G2L["11f"]["BorderSizePixel"] = 0;
G2L["11f"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["11f"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["11f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextLabel
G2L["120"] = Instance.new("TextLabel", G2L["11f"]);
G2L["120"]["BorderSizePixel"] = 0;
G2L["120"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["120"]["TextSize"] = 14;
G2L["120"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["120"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["120"]["BackgroundTransparency"] = 1;
G2L["120"]["Size"] = UDim2.new(0, 132, 0, 30);
G2L["120"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["120"]["Text"] = [[Aim Assist CColor]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.Frame
G2L["121"] = Instance.new("Frame", G2L["11f"]);
G2L["121"]["BorderSizePixel"] = 0;
G2L["121"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["121"]["Size"] = UDim2.new(0, 1, 0, 30);
G2L["121"]["Position"] = UDim2.new(0.5617, 0, 0, 0);
G2L["121"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["121"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox
G2L["122"] = Instance.new("TextBox", G2L["11f"]);
G2L["122"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["122"]["BorderSizePixel"] = 0;
G2L["122"]["TextWrapped"] = true;
G2L["122"]["TextSize"] = 12;
G2L["122"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["122"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["122"]["PlaceholderText"] = [[Red / Blue / Green / Purple / Black / Default]];
G2L["122"]["Size"] = UDim2.new(0, 102, 0, 30);
G2L["122"]["Position"] = UDim2.new(0.56344, 0, 0, 0);
G2L["122"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["122"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
G2L["123"] = Instance.new("LocalScript", G2L["122"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.UIStroke
G2L["124"] = Instance.new("UIStroke", G2L["11f"]);
G2L["124"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame
G2L["125"] = Instance.new("Frame", G2L["111"]);
G2L["125"]["BorderSizePixel"] = 0;
G2L["125"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["125"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["125"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextLabel
G2L["126"] = Instance.new("TextLabel", G2L["125"]);
G2L["126"]["BorderSizePixel"] = 0;
G2L["126"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["126"]["TextSize"] = 14;
G2L["126"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["126"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["126"]["BackgroundTransparency"] = 1;
G2L["126"]["Size"] = UDim2.new(0, 132, 0, 30);
G2L["126"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["126"]["Text"] = [[Aim Assist Method]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.Frame
G2L["127"] = Instance.new("Frame", G2L["125"]);
G2L["127"]["BorderSizePixel"] = 0;
G2L["127"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["127"]["Size"] = UDim2.new(0, 1, 0, 30);
G2L["127"]["Position"] = UDim2.new(0.5617, 0, 0, 0);
G2L["127"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["127"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox
G2L["128"] = Instance.new("TextBox", G2L["125"]);
G2L["128"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["128"]["BorderSizePixel"] = 0;
G2L["128"]["TextWrapped"] = true;
G2L["128"]["TextSize"] = 14;
G2L["128"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["128"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["128"]["PlaceholderText"] = [[Hold / Activate]];
G2L["128"]["Size"] = UDim2.new(0, 102, 0, 30);
G2L["128"]["Position"] = UDim2.new(0.56344, 0, 0, 0);
G2L["128"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["128"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
G2L["129"] = Instance.new("LocalScript", G2L["128"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.UIStroke
G2L["12a"] = Instance.new("UIStroke", G2L["125"]);
G2L["12a"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame
G2L["12b"] = Instance.new("Frame", G2L["111"]);
G2L["12b"]["BorderSizePixel"] = 0;
G2L["12b"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["12b"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["12b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextLabel
G2L["12c"] = Instance.new("TextLabel", G2L["12b"]);
G2L["12c"]["BorderSizePixel"] = 0;
G2L["12c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12c"]["TextSize"] = 14;
G2L["12c"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["12c"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["12c"]["BackgroundTransparency"] = 1;
G2L["12c"]["Size"] = UDim2.new(0, 132, 0, 30);
G2L["12c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["12c"]["Text"] = [[AA Hold Method]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.Frame
G2L["12d"] = Instance.new("Frame", G2L["12b"]);
G2L["12d"]["BorderSizePixel"] = 0;
G2L["12d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12d"]["Size"] = UDim2.new(0, 1, 0, 30);
G2L["12d"]["Position"] = UDim2.new(0.5617, 0, 0, 0);
G2L["12d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["12d"]["BackgroundTransparency"] = 0.6;


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox
G2L["12e"] = Instance.new("TextBox", G2L["12b"]);
G2L["12e"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["12e"]["BorderSizePixel"] = 0;
G2L["12e"]["TextWrapped"] = true;
G2L["12e"]["TextSize"] = 14;
G2L["12e"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["12e"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["12e"]["PlaceholderText"] = [[MouseButton1 / MouseButton2]];
G2L["12e"]["Size"] = UDim2.new(0, 102, 0, 30);
G2L["12e"]["Position"] = UDim2.new(0.56344, 0, 0, 0);
G2L["12e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["12e"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
G2L["12f"] = Instance.new("LocalScript", G2L["12e"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.UIStroke
G2L["130"] = Instance.new("UIStroke", G2L["12b"]);
G2L["130"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton
G2L["131"] = Instance.new("ImageButton", G2L["10a"]);
G2L["131"]["BorderSizePixel"] = 0;
G2L["131"]["AutoButtonColor"] = false;
G2L["131"]["ImageTransparency"] = 0.4;
G2L["131"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["131"]["Image"] = [[http://www.roblox.com/asset/?id=6031091004]];
G2L["131"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["131"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["131"]["Position"] = UDim2.new(0.93648, 0, 0.29508, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.UICorner
G2L["132"] = Instance.new("UICorner", G2L["131"]);
G2L["132"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["133"] = Instance.new("LocalScript", G2L["131"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame
G2L["134"] = Instance.new("Frame", G2L["ec"]);
G2L["134"]["BorderSizePixel"] = 0;
G2L["134"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["134"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["134"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["134"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.UICorner
G2L["135"] = Instance.new("UICorner", G2L["134"]);
G2L["135"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["136"] = Instance.new("TextLabel", G2L["134"]);
G2L["136"]["BorderSizePixel"] = 0;
G2L["136"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["136"]["TextTransparency"] = 0.4;
G2L["136"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["136"]["TextSize"] = 16;
G2L["136"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["136"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["136"]["BackgroundTransparency"] = 1;
G2L["136"]["Size"] = UDim2.new(0, 522, 0, 21);
G2L["136"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["136"]["Text"] = [[Management]];
G2L["136"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextLabel
G2L["137"] = Instance.new("TextLabel", G2L["134"]);
G2L["137"]["BorderSizePixel"] = 0;
G2L["137"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["137"]["TextTransparency"] = 0.4;
G2L["137"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["137"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["137"]["TextSize"] = 14;
G2L["137"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["137"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["137"]["BackgroundTransparency"] = 1;
G2L["137"]["Size"] = UDim2.new(0, 522, 0, 26);
G2L["137"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["137"]["Text"] = [[Prompts an management dropdown menu]];
G2L["137"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown
G2L["138"] = Instance.new("Frame", G2L["134"]);
G2L["138"]["Visible"] = false;
G2L["138"]["ZIndex"] = 2;
G2L["138"]["BorderSizePixel"] = 0;
G2L["138"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["138"]["Size"] = UDim2.new(0, 235, 0, 245);
G2L["138"]["Position"] = UDim2.new(0.59446, 0, 0.88525, 0);
G2L["138"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["138"]["Name"] = [[Dropdown]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UICorner
G2L["139"] = Instance.new("UICorner", G2L["138"]);
G2L["139"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UIGridLayout
G2L["13a"] = Instance.new("UIGridLayout", G2L["138"]);
G2L["13a"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["13a"]["CellSize"] = UDim2.new(0, 235, 0, 30);
G2L["13a"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["13a"]["CellPadding"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.UIStroke
G2L["13b"] = Instance.new("UIStroke", G2L["138"]);
G2L["13b"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame
G2L["13c"] = Instance.new("Frame", G2L["138"]);
G2L["13c"]["BorderSizePixel"] = 0;
G2L["13c"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["13c"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["13c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.UIStroke
G2L["13d"] = Instance.new("UIStroke", G2L["13c"]);
G2L["13d"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["13d"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton
G2L["13e"] = Instance.new("TextButton", G2L["13c"]);
G2L["13e"]["BorderSizePixel"] = 0;
G2L["13e"]["AutoButtonColor"] = false;
G2L["13e"]["TextSize"] = 14;
G2L["13e"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["13e"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["13e"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["13e"]["Size"] = UDim2.new(0, 235, 0, 30);
G2L["13e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["13e"]["Text"] = [[Change Key]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.LocalScript
G2L["13f"] = Instance.new("LocalScript", G2L["13e"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.UIStroke
G2L["140"] = Instance.new("UIStroke", G2L["13e"]);
G2L["140"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["140"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.UICorner
G2L["141"] = Instance.new("UICorner", G2L["13e"]);
G2L["141"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.UICorner
G2L["142"] = Instance.new("UICorner", G2L["13c"]);
G2L["142"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame
G2L["143"] = Instance.new("Frame", G2L["138"]);
G2L["143"]["BorderSizePixel"] = 0;
G2L["143"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["143"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["143"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.UIStroke
G2L["144"] = Instance.new("UIStroke", G2L["143"]);
G2L["144"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["144"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton
G2L["145"] = Instance.new("TextButton", G2L["143"]);
G2L["145"]["BorderSizePixel"] = 0;
G2L["145"]["AutoButtonColor"] = false;
G2L["145"]["TextSize"] = 14;
G2L["145"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["145"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["145"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["145"]["Size"] = UDim2.new(0, 235, 0, 30);
G2L["145"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["145"]["Text"] = [[Buy Premium]];


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.LocalScript
G2L["146"] = Instance.new("LocalScript", G2L["145"]);



-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.UIStroke
G2L["147"] = Instance.new("UIStroke", G2L["145"]);
G2L["147"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["147"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton
G2L["148"] = Instance.new("ImageButton", G2L["134"]);
G2L["148"]["BorderSizePixel"] = 0;
G2L["148"]["AutoButtonColor"] = false;
G2L["148"]["ImageTransparency"] = 0.4;
G2L["148"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["148"]["Image"] = [[http://www.roblox.com/asset/?id=6031091004]];
G2L["148"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["148"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["148"]["Position"] = UDim2.new(0.93648, 0, 0.29508, 0);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.UICorner
G2L["149"] = Instance.new("UICorner", G2L["148"]);
G2L["149"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["14a"] = Instance.new("LocalScript", G2L["148"]);



-- StarterGui.SSWorks.Main.ContentProvider.External
G2L["14b"] = Instance.new("Frame", G2L["66"]);
G2L["14b"]["Visible"] = false;
G2L["14b"]["BorderSizePixel"] = 0;
G2L["14b"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["14b"]["Size"] = UDim2.new(0, 631, 0, 404);
G2L["14b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["14b"]["Name"] = [[External]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame
G2L["14c"] = Instance.new("ScrollingFrame", G2L["14b"]);
G2L["14c"]["Active"] = true;
G2L["14c"]["BorderSizePixel"] = 0;
G2L["14c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14c"]["Size"] = UDim2.new(0, 615, 0, 390);
G2L["14c"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["14c"]["Position"] = UDim2.new(0.014, 0, 0.0209, 0);
G2L["14c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["14c"]["ScrollBarThickness"] = 0;
G2L["14c"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.UIListLayout
G2L["14d"] = Instance.new("UIListLayout", G2L["14c"]);
G2L["14d"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["14d"]["Padding"] = UDim.new(0, 5);
G2L["14d"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["14e"] = Instance.new("Frame", G2L["14c"]);
G2L["14e"]["BorderSizePixel"] = 0;
G2L["14e"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["14e"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["14e"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["14e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["14f"] = Instance.new("UICorner", G2L["14e"]);
G2L["14f"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["150"] = Instance.new("TextLabel", G2L["14e"]);
G2L["150"]["BorderSizePixel"] = 0;
G2L["150"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["150"]["TextTransparency"] = 0.4;
G2L["150"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["150"]["TextSize"] = 16;
G2L["150"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["150"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["150"]["BackgroundTransparency"] = 1;
G2L["150"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["150"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["150"]["Text"] = [[Noclip]];
G2L["150"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["151"] = Instance.new("TextLabel", G2L["14e"]);
G2L["151"]["TextWrapped"] = true;
G2L["151"]["BorderSizePixel"] = 0;
G2L["151"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["151"]["TextTransparency"] = 0.4;
G2L["151"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["151"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["151"]["TextSize"] = 14;
G2L["151"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["151"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["151"]["BackgroundTransparency"] = 1;
G2L["151"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["151"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["151"]["Text"] = [[This module triggers an server response to noclip ur character]];
G2L["151"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["152"] = Instance.new("TextButton", G2L["14e"]);
G2L["152"]["BorderSizePixel"] = 0;
G2L["152"]["AutoButtonColor"] = false;
G2L["152"]["TextSize"] = 14;
G2L["152"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["152"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["152"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["152"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["152"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["152"]["Text"] = [[]];
G2L["152"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["153"] = Instance.new("UICorner", G2L["152"]);
G2L["153"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["154"] = Instance.new("LocalScript", G2L["152"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["155"] = Instance.new("Frame", G2L["14c"]);
G2L["155"]["BorderSizePixel"] = 0;
G2L["155"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["155"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["155"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["155"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["156"] = Instance.new("UICorner", G2L["155"]);
G2L["156"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["157"] = Instance.new("TextLabel", G2L["155"]);
G2L["157"]["BorderSizePixel"] = 0;
G2L["157"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["157"]["TextTransparency"] = 0.4;
G2L["157"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["157"]["TextSize"] = 16;
G2L["157"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["157"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["157"]["BackgroundTransparency"] = 1;
G2L["157"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["157"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["157"]["Text"] = [[Status UI]];
G2L["157"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["158"] = Instance.new("TextLabel", G2L["155"]);
G2L["158"]["TextWrapped"] = true;
G2L["158"]["BorderSizePixel"] = 0;
G2L["158"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["158"]["TextTransparency"] = 0.4;
G2L["158"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["158"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["158"]["TextSize"] = 14;
G2L["158"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["158"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["158"]["BackgroundTransparency"] = 1;
G2L["158"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["158"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["158"]["Text"] = [[This triggers an visibility of an ui which gets every info of players:health, etc]];
G2L["158"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["159"] = Instance.new("TextButton", G2L["155"]);
G2L["159"]["BorderSizePixel"] = 0;
G2L["159"]["AutoButtonColor"] = false;
G2L["159"]["TextSize"] = 14;
G2L["159"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["159"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["159"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["159"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["159"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["159"]["Text"] = [[]];
G2L["159"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["15a"] = Instance.new("UICorner", G2L["159"]);
G2L["15a"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["15b"] = Instance.new("LocalScript", G2L["159"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["15c"] = Instance.new("Frame", G2L["14c"]);
G2L["15c"]["BorderSizePixel"] = 0;
G2L["15c"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["15c"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["15c"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["15c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["15d"] = Instance.new("UICorner", G2L["15c"]);
G2L["15d"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["15e"] = Instance.new("TextLabel", G2L["15c"]);
G2L["15e"]["BorderSizePixel"] = 0;
G2L["15e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["15e"]["TextTransparency"] = 0.4;
G2L["15e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15e"]["TextSize"] = 16;
G2L["15e"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["15e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15e"]["BackgroundTransparency"] = 1;
G2L["15e"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["15e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["15e"]["Text"] = [[BBypass]];
G2L["15e"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["15f"] = Instance.new("TextLabel", G2L["15c"]);
G2L["15f"]["TextWrapped"] = true;
G2L["15f"]["BorderSizePixel"] = 0;
G2L["15f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["15f"]["TextTransparency"] = 0.4;
G2L["15f"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["15f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15f"]["TextSize"] = 14;
G2L["15f"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["15f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15f"]["BackgroundTransparency"] = 1;
G2L["15f"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["15f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["15f"]["Text"] = [[This module searches for anticheat bypasses. It might break the game! Use it with caution]];
G2L["15f"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["160"] = Instance.new("TextButton", G2L["15c"]);
G2L["160"]["BorderSizePixel"] = 0;
G2L["160"]["AutoButtonColor"] = false;
G2L["160"]["TextSize"] = 14;
G2L["160"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["160"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["160"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["160"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["160"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["160"]["Text"] = [[]];
G2L["160"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["161"] = Instance.new("UICorner", G2L["160"]);
G2L["161"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["162"] = Instance.new("LocalScript", G2L["160"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["163"] = Instance.new("Frame", G2L["14c"]);
G2L["163"]["BorderSizePixel"] = 0;
G2L["163"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["163"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["163"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["163"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["164"] = Instance.new("UICorner", G2L["163"]);
G2L["164"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["165"] = Instance.new("TextLabel", G2L["163"]);
G2L["165"]["BorderSizePixel"] = 0;
G2L["165"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["165"]["TextTransparency"] = 0.4;
G2L["165"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["165"]["TextSize"] = 16;
G2L["165"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["165"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["165"]["BackgroundTransparency"] = 1;
G2L["165"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["165"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["165"]["Text"] = [[Aim Assist]];
G2L["165"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["166"] = Instance.new("TextLabel", G2L["163"]);
G2L["166"]["TextWrapped"] = true;
G2L["166"]["BorderSizePixel"] = 0;
G2L["166"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["166"]["TextTransparency"] = 0.4;
G2L["166"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["166"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["166"]["TextSize"] = 14;
G2L["166"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["166"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["166"]["BackgroundTransparency"] = 1;
G2L["166"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["166"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["166"]["Text"] = [[This module locks onto player's head prohibiting missing ur aim]];
G2L["166"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["167"] = Instance.new("TextButton", G2L["163"]);
G2L["167"]["BorderSizePixel"] = 0;
G2L["167"]["AutoButtonColor"] = false;
G2L["167"]["TextSize"] = 14;
G2L["167"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["167"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["167"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["167"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["167"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["167"]["Text"] = [[]];
G2L["167"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["168"] = Instance.new("UICorner", G2L["167"]);
G2L["168"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["169"] = Instance.new("LocalScript", G2L["167"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["16a"] = Instance.new("Frame", G2L["14c"]);
G2L["16a"]["BorderSizePixel"] = 0;
G2L["16a"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["16a"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["16a"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["16a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["16b"] = Instance.new("UICorner", G2L["16a"]);
G2L["16b"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["16c"] = Instance.new("TextLabel", G2L["16a"]);
G2L["16c"]["BorderSizePixel"] = 0;
G2L["16c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["16c"]["TextTransparency"] = 0.4;
G2L["16c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16c"]["TextSize"] = 16;
G2L["16c"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16c"]["BackgroundTransparency"] = 1;
G2L["16c"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["16c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16c"]["Text"] = [[ESP]];
G2L["16c"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["16d"] = Instance.new("TextLabel", G2L["16a"]);
G2L["16d"]["TextWrapped"] = true;
G2L["16d"]["BorderSizePixel"] = 0;
G2L["16d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["16d"]["TextTransparency"] = 0.4;
G2L["16d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["16d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16d"]["TextSize"] = 14;
G2L["16d"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16d"]["BackgroundTransparency"] = 1;
G2L["16d"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["16d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16d"]["Text"] = [[This module highlights all players in the game and keeps the track of the hightlights]];
G2L["16d"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["16e"] = Instance.new("TextButton", G2L["16a"]);
G2L["16e"]["BorderSizePixel"] = 0;
G2L["16e"]["AutoButtonColor"] = false;
G2L["16e"]["TextSize"] = 14;
G2L["16e"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16e"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["16e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16e"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["16e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16e"]["Text"] = [[]];
G2L["16e"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["16f"] = Instance.new("UICorner", G2L["16e"]);
G2L["16f"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["170"] = Instance.new("LocalScript", G2L["16e"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["171"] = Instance.new("Frame", G2L["14c"]);
G2L["171"]["BorderSizePixel"] = 0;
G2L["171"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["171"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["171"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["171"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["172"] = Instance.new("UICorner", G2L["171"]);
G2L["172"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["173"] = Instance.new("TextLabel", G2L["171"]);
G2L["173"]["BorderSizePixel"] = 0;
G2L["173"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["173"]["TextTransparency"] = 0.4;
G2L["173"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["173"]["TextSize"] = 16;
G2L["173"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["173"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["173"]["BackgroundTransparency"] = 1;
G2L["173"]["Size"] = UDim2.new(0, 549, 0, 21);
G2L["173"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["173"]["Text"] = [[XRay]];
G2L["173"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["174"] = Instance.new("TextLabel", G2L["171"]);
G2L["174"]["TextWrapped"] = true;
G2L["174"]["BorderSizePixel"] = 0;
G2L["174"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["174"]["TextTransparency"] = 0.4;
G2L["174"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["174"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["174"]["TextSize"] = 14;
G2L["174"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["174"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["174"]["BackgroundTransparency"] = 1;
G2L["174"]["Size"] = UDim2.new(0, 549, 0, 26);
G2L["174"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["174"]["Text"] = [[This module set's all of the part's transparency to .5]];
G2L["174"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["175"] = Instance.new("TextButton", G2L["171"]);
G2L["175"]["BorderSizePixel"] = 0;
G2L["175"]["AutoButtonColor"] = false;
G2L["175"]["TextSize"] = 14;
G2L["175"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["175"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["175"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["175"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["175"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["175"]["Text"] = [[]];
G2L["175"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["176"] = Instance.new("UICorner", G2L["175"]);
G2L["176"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["177"] = Instance.new("LocalScript", G2L["175"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame
G2L["178"] = Instance.new("Frame", G2L["14c"]);
G2L["178"]["BorderSizePixel"] = 0;
G2L["178"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["178"]["Size"] = UDim2.new(0, 614, 0, 61);
G2L["178"]["Position"] = UDim2.new(0.00081, 0, 0, 0);
G2L["178"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.UICorner
G2L["179"] = Instance.new("UICorner", G2L["178"]);
G2L["179"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["17a"] = Instance.new("TextLabel", G2L["178"]);
G2L["17a"]["BorderSizePixel"] = 0;
G2L["17a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17a"]["TextTransparency"] = 0.4;
G2L["17a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17a"]["TextSize"] = 16;
G2L["17a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17a"]["BackgroundTransparency"] = 1;
G2L["17a"]["Size"] = UDim2.new(0, 392, 0, 21);
G2L["17a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17a"]["Text"] = [[Speed]];
G2L["17a"]["Position"] = UDim2.new(0.01466, 0, 0.11475, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextLabel
G2L["17b"] = Instance.new("TextLabel", G2L["178"]);
G2L["17b"]["BorderSizePixel"] = 0;
G2L["17b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17b"]["TextTransparency"] = 0.4;
G2L["17b"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["17b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17b"]["TextSize"] = 14;
G2L["17b"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17b"]["BackgroundTransparency"] = 1;
G2L["17b"]["Size"] = UDim2.new(0, 392, 0, 26);
G2L["17b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17b"]["Text"] = [[Configurates your walkspeed.]];
G2L["17b"]["Position"] = UDim2.new(0.01466, 0, 0.45902, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton
G2L["17c"] = Instance.new("TextButton", G2L["178"]);
G2L["17c"]["BorderSizePixel"] = 0;
G2L["17c"]["AutoButtonColor"] = false;
G2L["17c"]["TextSize"] = 14;
G2L["17c"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17c"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["17c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17c"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["17c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17c"]["Text"] = [[]];
G2L["17c"]["Position"] = UDim2.new(0.93648, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.UICorner
G2L["17d"] = Instance.new("UICorner", G2L["17c"]);
G2L["17d"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
G2L["17e"] = Instance.new("LocalScript", G2L["17c"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown
G2L["17f"] = Instance.new("Frame", G2L["178"]);
G2L["17f"]["Visible"] = false;
G2L["17f"]["ZIndex"] = 2;
G2L["17f"]["BorderSizePixel"] = 0;
G2L["17f"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["17f"]["Size"] = UDim2.new(0, 137, 0, 150);
G2L["17f"]["Position"] = UDim2.new(0.71336, 0, 0.88525, 0);
G2L["17f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17f"]["Name"] = [[Dropdown]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.UICorner
G2L["180"] = Instance.new("UICorner", G2L["17f"]);
G2L["180"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.UIListLayout
G2L["181"] = Instance.new("UIListLayout", G2L["17f"]);
G2L["181"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.UIStroke
G2L["182"] = Instance.new("UIStroke", G2L["17f"]);
G2L["182"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton
G2L["183"] = Instance.new("TextButton", G2L["17f"]);
G2L["183"]["BorderSizePixel"] = 0;
G2L["183"]["AutoButtonColor"] = false;
G2L["183"]["TextSize"] = 14;
G2L["183"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["183"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["183"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["183"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["183"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["183"]["Text"] = [[Normal]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.UIStroke
G2L["184"] = Instance.new("UIStroke", G2L["183"]);
G2L["184"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["184"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
G2L["185"] = Instance.new("LocalScript", G2L["183"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.UICorner
G2L["186"] = Instance.new("UICorner", G2L["183"]);
G2L["186"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton
G2L["187"] = Instance.new("TextButton", G2L["17f"]);
G2L["187"]["BorderSizePixel"] = 0;
G2L["187"]["AutoButtonColor"] = false;
G2L["187"]["TextSize"] = 14;
G2L["187"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["187"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["187"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["187"]["Size"] = UDim2.new(0, 137, 0, 30);
G2L["187"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["187"]["Text"] = [[CFrame]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.UIStroke
G2L["188"] = Instance.new("UIStroke", G2L["187"]);
G2L["188"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["188"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
G2L["189"] = Instance.new("LocalScript", G2L["187"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.UICorner
G2L["18a"] = Instance.new("UICorner", G2L["187"]);
G2L["18a"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.ImageButton
G2L["18b"] = Instance.new("ImageButton", G2L["178"]);
G2L["18b"]["BorderSizePixel"] = 0;
G2L["18b"]["AutoButtonColor"] = false;
G2L["18b"]["ImageTransparency"] = 0.4;
G2L["18b"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["18b"]["Image"] = [[http://www.roblox.com/asset/?id=6031091004]];
G2L["18b"]["Size"] = UDim2.new(0, 25, 0, 25);
G2L["18b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["18b"]["Position"] = UDim2.new(0.88436, 0, 0.2623, 0);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.ImageButton.UICorner
G2L["18c"] = Instance.new("UICorner", G2L["18b"]);
G2L["18c"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.ImageButton.LocalScript
G2L["18d"] = Instance.new("LocalScript", G2L["18b"]);



-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.SelectedValue
G2L["18e"] = Instance.new("StringValue", G2L["178"]);
G2L["18e"]["Name"] = [[SelectedValue]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextBox
G2L["18f"] = Instance.new("TextBox", G2L["178"]);
G2L["18f"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["18f"]["BorderSizePixel"] = 0;
G2L["18f"]["TextSize"] = 16;
G2L["18f"]["BackgroundColor3"] = Color3.fromRGB(71, 71, 71);
G2L["18f"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18f"]["PlaceholderText"] = [[100]];
G2L["18f"]["Size"] = UDim2.new(0, 125, 0, 25);
G2L["18f"]["Position"] = UDim2.new(0.66938, 0, 0.2623, 0);
G2L["18f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["18f"]["Text"] = [[]];


-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextBox.UICorner
G2L["190"] = Instance.new("UICorner", G2L["18f"]);
G2L["190"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.NList
G2L["191"] = Instance.new("Frame", G2L["1"]);
G2L["191"]["ZIndex"] = 2;
G2L["191"]["BorderSizePixel"] = 0;
G2L["191"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["191"]["Size"] = UDim2.new(0.18838, 0, 0.92568, 0);
G2L["191"]["Position"] = UDim2.new(0.80747, 0, 0.06635, 0);
G2L["191"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["191"]["Name"] = [[NList]];
G2L["191"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.NList.UIListLayout
G2L["192"] = Instance.new("UIListLayout", G2L["191"]);
G2L["192"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Right;
G2L["192"]["Padding"] = UDim.new(0, 5);
G2L["192"]["VerticalAlignment"] = Enum.VerticalAlignment.Bottom;
G2L["192"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.SSWorks.OpenManager
G2L["193"] = Instance.new("LocalScript", G2L["1"]);
G2L["193"]["Name"] = [[OpenManager]];


-- StarterGui.SSWorks.OpenManager.Icon
G2L["194"] = Instance.new("ModuleScript", G2L["193"]);
G2L["194"]["Name"] = [[Icon]];


-- StarterGui.SSWorks.OpenManager.Icon.PackageLink
G2L["195"] = Instance.new("PackageLink", G2L["194"]);
G2L["195"]["VersionNumber"] = 20;
G2L["195"]["Name"] = [[PackageLink]];
G2L["195"]["DefaultName"] = [[]];
G2L["195"]["Archivable"] = true;


-- StarterGui.SSWorks.OpenManager.Icon.Elements
G2L["196"] = Instance.new("Folder", G2L["194"]);
G2L["196"]["Name"] = [[Elements]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Caption
G2L["197"] = Instance.new("ModuleScript", G2L["196"]);
G2L["197"]["Name"] = [[Caption]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Container
G2L["198"] = Instance.new("ModuleScript", G2L["196"]);
G2L["198"]["Name"] = [[Container]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Dropdown
G2L["199"] = Instance.new("ModuleScript", G2L["196"]);
G2L["199"]["Name"] = [[Dropdown]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Indicator
G2L["19a"] = Instance.new("ModuleScript", G2L["196"]);
G2L["19a"]["Name"] = [[Indicator]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Menu
G2L["19b"] = Instance.new("ModuleScript", G2L["196"]);
G2L["19b"]["Name"] = [[Menu]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Selection
G2L["19c"] = Instance.new("ModuleScript", G2L["196"]);
G2L["19c"]["Name"] = [[Selection]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Widget
G2L["19d"] = Instance.new("ModuleScript", G2L["196"]);
G2L["19d"]["Name"] = [[Widget]];


-- StarterGui.SSWorks.OpenManager.Icon.Elements.Notice
G2L["19e"] = Instance.new("ModuleScript", G2L["196"]);
G2L["19e"]["Name"] = [[Notice]];


-- StarterGui.SSWorks.OpenManager.Icon.Attribute
G2L["19f"] = Instance.new("ModuleScript", G2L["194"]);
G2L["19f"]["Name"] = [[Attribute]];


-- StarterGui.SSWorks.OpenManager.Icon.Features
G2L["1a0"] = Instance.new("Folder", G2L["194"]);
G2L["1a0"]["Name"] = [[Features]];


-- StarterGui.SSWorks.OpenManager.Icon.Features.Gamepad
G2L["1a1"] = Instance.new("ModuleScript", G2L["1a0"]);
G2L["1a1"]["Name"] = [[Gamepad]];


-- StarterGui.SSWorks.OpenManager.Icon.Features.Overflow
G2L["1a2"] = Instance.new("ModuleScript", G2L["1a0"]);
G2L["1a2"]["Name"] = [[Overflow]];


-- StarterGui.SSWorks.OpenManager.Icon.Features.Themes
G2L["1a3"] = Instance.new("ModuleScript", G2L["1a0"]);
G2L["1a3"]["Name"] = [[Themes]];


-- StarterGui.SSWorks.OpenManager.Icon.Features.Themes.Classic
G2L["1a4"] = Instance.new("ModuleScript", G2L["1a3"]);
G2L["1a4"]["Name"] = [[Classic]];


-- StarterGui.SSWorks.OpenManager.Icon.Features.Themes.Default
G2L["1a5"] = Instance.new("ModuleScript", G2L["1a3"]);
G2L["1a5"]["Name"] = [[Default]];


-- StarterGui.SSWorks.OpenManager.Icon.Reference
G2L["1a6"] = Instance.new("ModuleScript", G2L["194"]);
G2L["1a6"]["Name"] = [[Reference]];


-- StarterGui.SSWorks.OpenManager.Icon.VERSION
G2L["1a7"] = Instance.new("ModuleScript", G2L["194"]);
G2L["1a7"]["Name"] = [[VERSION]];


-- StarterGui.SSWorks.OpenManager.Icon.Utility
G2L["1a8"] = Instance.new("ModuleScript", G2L["194"]);
G2L["1a8"]["Name"] = [[Utility]];


-- StarterGui.SSWorks.OpenManager.Icon.Packages
G2L["1a9"] = Instance.new("Folder", G2L["194"]);
G2L["1a9"]["Name"] = [[Packages]];


-- StarterGui.SSWorks.OpenManager.Icon.Packages.GoodSignal
G2L["1aa"] = Instance.new("ModuleScript", G2L["1a9"]);
G2L["1aa"]["Name"] = [[GoodSignal]];


-- StarterGui.SSWorks.OpenManager.Icon.Packages.Janitor
G2L["1ab"] = Instance.new("ModuleScript", G2L["1a9"]);
G2L["1ab"]["Name"] = [[Janitor]];


-- StarterGui.SSWorks.isOpen
G2L["1ac"] = Instance.new("BoolValue", G2L["1"]);
G2L["1ac"]["Name"] = [[isOpen]];


-- StarterGui.SSWorks.FPlayerUI
G2L["1ad"] = Instance.new("Frame", G2L["1"]);
G2L["1ad"]["BorderSizePixel"] = 0;
G2L["1ad"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["1ad"]["Size"] = UDim2.new(0, 260, 0, 51);
G2L["1ad"]["Position"] = UDim2.new(0, -2147483648, 0, -2147483648);
G2L["1ad"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ad"]["Name"] = [[FPlayerUI]];
G2L["1ad"]["BackgroundTransparency"] = 0.5;


-- StarterGui.SSWorks.FPlayerUI.UICorner
G2L["1ae"] = Instance.new("UICorner", G2L["1ad"]);



-- StarterGui.SSWorks.FPlayerUI.UIStroke
G2L["1af"] = Instance.new("UIStroke", G2L["1ad"]);
G2L["1af"]["Transparency"] = 0.5;
G2L["1af"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1af"]["Color"] = Color3.fromRGB(83, 181, 255);


-- StarterGui.SSWorks.FPlayerUI.ImageLabel
G2L["1b0"] = Instance.new("ImageLabel", G2L["1ad"]);
G2L["1b0"]["BorderSizePixel"] = 0;
G2L["1b0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b0"]["Image"] = [[rbxasset://textures/ui/GuiImagePlaceholder.png]];
G2L["1b0"]["Size"] = UDim2.new(0, 40, 0, 40);
G2L["1b0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b0"]["BackgroundTransparency"] = 1;
G2L["1b0"]["Position"] = UDim2.new(0.024, 0, 0.118, 0);


-- StarterGui.SSWorks.FPlayerUI.ImageLabel.UICorner
G2L["1b1"] = Instance.new("UICorner", G2L["1b0"]);



-- StarterGui.SSWorks.FPlayerUI.ImageLabel.UIStroke
G2L["1b2"] = Instance.new("UIStroke", G2L["1b0"]);
G2L["1b2"]["Transparency"] = 0.5;
G2L["1b2"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1b2"]["Color"] = Color3.fromRGB(83, 181, 255);


-- StarterGui.SSWorks.FPlayerUI.TextLabel
G2L["1b3"] = Instance.new("TextLabel", G2L["1ad"]);
G2L["1b3"]["TextWrapped"] = true;
G2L["1b3"]["BorderSizePixel"] = 0;
G2L["1b3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1b3"]["TextScaled"] = true;
G2L["1b3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b3"]["TextSize"] = 18;
G2L["1b3"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1b3"]["TextColor3"] = Color3.fromRGB(200, 200, 200);
G2L["1b3"]["BackgroundTransparency"] = 1;
G2L["1b3"]["Size"] = UDim2.new(0, 200, 0, 21);
G2L["1b3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b3"]["Text"] = [[Player's Username]];
G2L["1b3"]["Position"] = UDim2.new(0.20745, 0, 0.17738, 0);


-- StarterGui.SSWorks.FPlayerUI.HealthBar
G2L["1b4"] = Instance.new("Frame", G2L["1ad"]);
G2L["1b4"]["BorderSizePixel"] = 0;
G2L["1b4"]["BackgroundColor3"] = Color3.fromRGB(83, 181, 255);
G2L["1b4"]["Size"] = UDim2.new(0, 200, 0, 4);
G2L["1b4"]["Position"] = UDim2.new(0.20385, 0, 0.72549, 0);
G2L["1b4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b4"]["Name"] = [[HealthBar]];


-- StarterGui.SSWorks.FPlayerUI.HealthBar.UICorner
G2L["1b5"] = Instance.new("UICorner", G2L["1b4"]);



-- StarterGui.SSWorks.FPlayerUI.Manager
G2L["1b6"] = Instance.new("LocalScript", G2L["1ad"]);
G2L["1b6"]["Name"] = [[Manager]];


-- StarterGui.SSWorks.FPlayerUI.shadowHolder
G2L["1b7"] = Instance.new("Frame", G2L["1ad"]);
G2L["1b7"]["ZIndex"] = 0;
G2L["1b7"]["Size"] = UDim2.new(1.04615, 0, 1.31373, 0);
G2L["1b7"]["Position"] = UDim2.new(-0.02308, 0, -0.19608, 0);
G2L["1b7"]["Name"] = [[shadowHolder]];
G2L["1b7"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.FPlayerUI.shadowHolder.umbraShadow
G2L["1b8"] = Instance.new("ImageLabel", G2L["1b7"]);
G2L["1b8"]["ZIndex"] = 0;
G2L["1b8"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1b8"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1b8"]["ImageTransparency"] = 0.86;
G2L["1b8"]["ImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b8"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1b8"]["Image"] = [[rbxassetid://1316045217]];
G2L["1b8"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1b8"]["BackgroundTransparency"] = 1;
G2L["1b8"]["Name"] = [[umbraShadow]];
G2L["1b8"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.FPlayerUI.shadowHolder.penumbraShadow
G2L["1b9"] = Instance.new("ImageLabel", G2L["1b7"]);
G2L["1b9"]["ZIndex"] = 0;
G2L["1b9"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1b9"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1b9"]["ImageTransparency"] = 0.88;
G2L["1b9"]["ImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b9"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1b9"]["Image"] = [[rbxassetid://1316045217]];
G2L["1b9"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1b9"]["BackgroundTransparency"] = 1;
G2L["1b9"]["Name"] = [[penumbraShadow]];
G2L["1b9"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.FPlayerUI.shadowHolder.ambientShadow
G2L["1ba"] = Instance.new("ImageLabel", G2L["1b7"]);
G2L["1ba"]["ZIndex"] = 0;
G2L["1ba"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1ba"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1ba"]["ImageTransparency"] = 0.88;
G2L["1ba"]["ImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ba"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1ba"]["Image"] = [[rbxassetid://1316045217]];
G2L["1ba"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1ba"]["BackgroundTransparency"] = 1;
G2L["1ba"]["Name"] = [[ambientShadow]];
G2L["1ba"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.AimAssistFrame
G2L["1bb"] = Instance.new("Frame", G2L["1"]);
G2L["1bb"]["Visible"] = false;
G2L["1bb"]["BorderSizePixel"] = 0;
G2L["1bb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1bb"]["Size"] = UDim2.new(0, 350, 0, 350);
G2L["1bb"]["Position"] = UDim2.new(0.42488, 0, 0.33835, 0);
G2L["1bb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1bb"]["Name"] = [[AimAssistFrame]];
G2L["1bb"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.AimAssistFrame.UICorner
G2L["1bc"] = Instance.new("UICorner", G2L["1bb"]);
G2L["1bc"]["CornerRadius"] = UDim.new(1, 0);


-- StarterGui.SSWorks.AimAssistFrame.UIStroke
G2L["1bd"] = Instance.new("UIStroke", G2L["1bb"]);
G2L["1bd"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1bd"]["Thickness"] = 2;
G2L["1bd"]["Color"] = Color3.fromRGB(255, 255, 255);


-- StarterGui.SSWorks.AimAssistFrame.LocalScript
G2L["1be"] = Instance.new("LocalScript", G2L["1bb"]);



-- StarterGui.SSWorks.Resources
G2L["1bf"] = Instance.new("Folder", G2L["1"]);
G2L["1bf"]["Name"] = [[Resources]];


-- StarterGui.SSWorks.Resources.ESP
G2L["1c0"] = Instance.new("Highlight", G2L["1bf"]);
G2L["1c0"]["Name"] = [[ESP]];
G2L["1c0"]["FillColor"] = Color3.fromRGB(53, 175, 255);


-- StarterGui.SSWorks.Configurations
G2L["1c1"] = Instance.new("Folder", G2L["1"]);
G2L["1c1"]["Name"] = [[Configurations]];


-- StarterGui.SSWorks.Configurations.AimAssistSmoothness
G2L["1c2"] = Instance.new("NumberValue", G2L["1c1"]);
G2L["1c2"]["Name"] = [[AimAssistSmoothness]];
G2L["1c2"]["Value"] = 1;


-- StarterGui.SSWorks.Configurations.AimAssistPart
G2L["1c3"] = Instance.new("StringValue", G2L["1c1"]);
G2L["1c3"]["Name"] = [[AimAssistPart]];
G2L["1c3"]["Value"] = [[Head]];


-- StarterGui.SSWorks.Configurations.Key
G2L["1c4"] = Instance.new("StringValue", G2L["1c1"]);
G2L["1c4"]["Name"] = [[Key]];


-- StarterGui.SSWorks.Configurations.AATrigger
G2L["1c5"] = Instance.new("StringValue", G2L["1c1"]);
G2L["1c5"]["Name"] = [[AATrigger]];
G2L["1c5"]["Value"] = [[Activate]];


-- StarterGui.SSWorks.Configurations.AAKeyHoldMethod
G2L["1c6"] = Instance.new("StringValue", G2L["1c1"]);
G2L["1c6"]["Name"] = [[AAKeyHoldMethod]];
G2L["1c6"]["Value"] = [[MouseButton1]];


-- StarterGui.SSWorks.KeyConfig
G2L["1c7"] = Instance.new("Folder", G2L["1"]);
G2L["1c7"]["Name"] = [[KeyConfig]];


-- StarterGui.SSWorks.KeyConfig.ChangeKey
G2L["1c8"] = Instance.new("Frame", G2L["1c7"]);
G2L["1c8"]["Visible"] = false;
G2L["1c8"]["BorderSizePixel"] = 0;
G2L["1c8"]["BackgroundColor3"] = Color3.fromRGB(26, 26, 26);
G2L["1c8"]["Size"] = UDim2.new(0, 345, 0, 168);
G2L["1c8"]["Position"] = UDim2.new(0.42612, 0, 0.40645, 0);
G2L["1c8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c8"]["Name"] = [[ChangeKey]];


-- StarterGui.SSWorks.KeyConfig.ChangeKey.SmoothDrag
G2L["1c9"] = Instance.new("LocalScript", G2L["1c8"]);
G2L["1c9"]["Name"] = [[SmoothDrag]];


-- StarterGui.SSWorks.KeyConfig.ChangeKey.UICorner
G2L["1ca"] = Instance.new("UICorner", G2L["1c8"]);



-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextLabel
G2L["1cb"] = Instance.new("TextLabel", G2L["1c8"]);
G2L["1cb"]["BorderSizePixel"] = 0;
G2L["1cb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1cb"]["TextSize"] = 18;
G2L["1cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1cb"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["1cb"]["BackgroundTransparency"] = 1;
G2L["1cb"]["Size"] = UDim2.new(0, 264, 0, 25);
G2L["1cb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1cb"]["Text"] = [[Key Configuration - Change Key]];
G2L["1cb"]["Position"] = UDim2.new(0.11594, 0, 0.05254, 0);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextBox
G2L["1cc"] = Instance.new("TextBox", G2L["1c8"]);
G2L["1cc"]["TextColor3"] = Color3.fromRGB(151, 151, 151);
G2L["1cc"]["BorderSizePixel"] = 0;
G2L["1cc"]["TextSize"] = 16;
G2L["1cc"]["BackgroundColor3"] = Color3.fromRGB(51, 51, 51);
G2L["1cc"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1cc"]["PlaceholderText"] = [[Enter the new Key]];
G2L["1cc"]["Size"] = UDim2.new(0, 264, 0, 31);
G2L["1cc"]["Position"] = UDim2.new(0.11594, 0, 0.27318, 0);
G2L["1cc"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1cc"]["Text"] = [[]];


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextBox.UICorner
G2L["1cd"] = Instance.new("UICorner", G2L["1cc"]);
G2L["1cd"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextBox.UIStroke
G2L["1ce"] = Instance.new("UIStroke", G2L["1cc"]);
G2L["1ce"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1ce"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton
G2L["1cf"] = Instance.new("TextButton", G2L["1c8"]);
G2L["1cf"]["BorderSizePixel"] = 0;
G2L["1cf"]["AutoButtonColor"] = false;
G2L["1cf"]["TextSize"] = 14;
G2L["1cf"]["TextColor3"] = Color3.fromRGB(70, 172, 23);
G2L["1cf"]["BackgroundColor3"] = Color3.fromRGB(140, 255, 157);
G2L["1cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1cf"]["Size"] = UDim2.new(0, 264, 0, 25);
G2L["1cf"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1cf"]["Text"] = [[Change]];
G2L["1cf"]["Position"] = UDim2.new(0.11594, 0, 0.5165, 0);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.UICorner
G2L["1d0"] = Instance.new("UICorner", G2L["1cf"]);
G2L["1d0"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.UIStroke
G2L["1d1"] = Instance.new("UIStroke", G2L["1cf"]);
G2L["1d1"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1d1"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder
G2L["1d2"] = Instance.new("Frame", G2L["1cf"]);
G2L["1d2"]["ZIndex"] = 0;
G2L["1d2"]["Size"] = UDim2.new(0, 273, 0, 35);
G2L["1d2"]["Position"] = UDim2.new(-0.01894, 0, -0.16531, 0);
G2L["1d2"]["Name"] = [[shadowHolder]];
G2L["1d2"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.umbraShadow
G2L["1d3"] = Instance.new("ImageLabel", G2L["1d2"]);
G2L["1d3"]["ZIndex"] = 0;
G2L["1d3"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1d3"]["BackgroundColor3"] = Color3.fromRGB(24, 255, 24);
G2L["1d3"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1d3"]["ImageTransparency"] = 0.86;
G2L["1d3"]["ImageColor3"] = Color3.fromRGB(53, 255, 38);
G2L["1d3"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1d3"]["Image"] = [[rbxassetid://1316045217]];
G2L["1d3"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1d3"]["BackgroundTransparency"] = 1;
G2L["1d3"]["Name"] = [[umbraShadow]];
G2L["1d3"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.penumbraShadow
G2L["1d4"] = Instance.new("ImageLabel", G2L["1d2"]);
G2L["1d4"]["ZIndex"] = 0;
G2L["1d4"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1d4"]["BackgroundColor3"] = Color3.fromRGB(24, 255, 24);
G2L["1d4"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1d4"]["ImageTransparency"] = 0.88;
G2L["1d4"]["ImageColor3"] = Color3.fromRGB(53, 255, 38);
G2L["1d4"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1d4"]["Image"] = [[rbxassetid://1316045217]];
G2L["1d4"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1d4"]["BackgroundTransparency"] = 1;
G2L["1d4"]["Name"] = [[penumbraShadow]];
G2L["1d4"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.ambientShadow
G2L["1d5"] = Instance.new("ImageLabel", G2L["1d2"]);
G2L["1d5"]["ZIndex"] = 0;
G2L["1d5"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1d5"]["BackgroundColor3"] = Color3.fromRGB(24, 255, 24);
G2L["1d5"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1d5"]["ImageTransparency"] = 0.88;
G2L["1d5"]["ImageColor3"] = Color3.fromRGB(53, 255, 38);
G2L["1d5"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1d5"]["Image"] = [[rbxassetid://1316045217]];
G2L["1d5"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1d5"]["BackgroundTransparency"] = 1;
G2L["1d5"]["Name"] = [[ambientShadow]];
G2L["1d5"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.LocalScript
G2L["1d6"] = Instance.new("LocalScript", G2L["1cf"]);



-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton
G2L["1d7"] = Instance.new("TextButton", G2L["1c8"]);
G2L["1d7"]["BorderSizePixel"] = 0;
G2L["1d7"]["AutoButtonColor"] = false;
G2L["1d7"]["TextSize"] = 14;
G2L["1d7"]["TextColor3"] = Color3.fromRGB(57, 57, 57);
G2L["1d7"]["BackgroundColor3"] = Color3.fromRGB(255, 166, 166);
G2L["1d7"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1d7"]["Size"] = UDim2.new(0, 264, 0, 25);
G2L["1d7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d7"]["Text"] = [[Cancel]];
G2L["1d7"]["Position"] = UDim2.new(0.11594, 0, 0.70698, 0);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.UICorner
G2L["1d8"] = Instance.new("UICorner", G2L["1d7"]);
G2L["1d8"]["CornerRadius"] = UDim.new(0, 4);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.UIStroke
G2L["1d9"] = Instance.new("UIStroke", G2L["1d7"]);
G2L["1d9"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1d9"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder
G2L["1da"] = Instance.new("Frame", G2L["1d7"]);
G2L["1da"]["ZIndex"] = 0;
G2L["1da"]["Size"] = UDim2.new(0, 273, 0, 35);
G2L["1da"]["Position"] = UDim2.new(-0.01894, 0, -0.16531, 0);
G2L["1da"]["Name"] = [[shadowHolder]];
G2L["1da"]["BackgroundTransparency"] = 1;


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.umbraShadow
G2L["1db"] = Instance.new("ImageLabel", G2L["1da"]);
G2L["1db"]["ZIndex"] = 0;
G2L["1db"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1db"]["BackgroundColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1db"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1db"]["ImageTransparency"] = 0.86;
G2L["1db"]["ImageColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1db"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1db"]["Image"] = [[rbxassetid://1316045217]];
G2L["1db"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1db"]["BackgroundTransparency"] = 1;
G2L["1db"]["Name"] = [[umbraShadow]];
G2L["1db"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.penumbraShadow
G2L["1dc"] = Instance.new("ImageLabel", G2L["1da"]);
G2L["1dc"]["ZIndex"] = 0;
G2L["1dc"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1dc"]["BackgroundColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1dc"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1dc"]["ImageTransparency"] = 0.88;
G2L["1dc"]["ImageColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1dc"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1dc"]["Image"] = [[rbxassetid://1316045217]];
G2L["1dc"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1dc"]["BackgroundTransparency"] = 1;
G2L["1dc"]["Name"] = [[penumbraShadow]];
G2L["1dc"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.shadowHolder.ambientShadow
G2L["1dd"] = Instance.new("ImageLabel", G2L["1da"]);
G2L["1dd"]["ZIndex"] = 0;
G2L["1dd"]["SliceCenter"] = Rect.new(10, 10, 118, 118);
G2L["1dd"]["BackgroundColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1dd"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["1dd"]["ImageTransparency"] = 0.88;
G2L["1dd"]["ImageColor3"] = Color3.fromRGB(255, 94, 94);
G2L["1dd"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["1dd"]["Image"] = [[rbxassetid://1316045217]];
G2L["1dd"]["Size"] = UDim2.new(1, 4, 1, 4);
G2L["1dd"]["BackgroundTransparency"] = 1;
G2L["1dd"]["Name"] = [[ambientShadow]];
G2L["1dd"]["Position"] = UDim2.new(0.5, 0, 0.5, 2);


-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.LocalScript
G2L["1de"] = Instance.new("LocalScript", G2L["1d7"]);



-- StarterGui.SSWorks.KeyConfig.ChangeKey.UIStroke
G2L["1df"] = Instance.new("UIStroke", G2L["1c8"]);
G2L["1df"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["1df"]["Color"] = Color3.fromRGB(101, 101, 101);


-- StarterGui.SSWorks.Loader
G2L["1e0"] = Instance.new("CanvasGroup", G2L["1"]);
G2L["1e0"]["GroupTransparency"] = 1;
G2L["1e0"]["BorderSizePixel"] = 0;
G2L["1e0"]["BackgroundColor3"] = Color3.fromRGB(36, 36, 36);
G2L["1e0"]["Size"] = UDim2.new(0, 400, 0, 400);
G2L["1e0"]["Position"] = UDim2.new(0.39594, 0, 0.31521, 0);
G2L["1e0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e0"]["Name"] = [[Loader]];


-- StarterGui.SSWorks.Loader.UICorner
G2L["1e1"] = Instance.new("UICorner", G2L["1e0"]);



-- StarterGui.SSWorks.Loader.UIStroke
G2L["1e2"] = Instance.new("UIStroke", G2L["1e0"]);
G2L["1e2"]["Transparency"] = 1;
G2L["1e2"]["Thickness"] = 2;
G2L["1e2"]["Color"] = Color3.fromRGB(50, 194, 255);


-- StarterGui.SSWorks.Loader.ImageLabel
G2L["1e3"] = Instance.new("ImageLabel", G2L["1e0"]);
G2L["1e3"]["BorderSizePixel"] = 0;
G2L["1e3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e3"]["ImageTransparency"] = 1;
G2L["1e3"]["Image"] = [[http://www.roblox.com/asset/?id=6031734907]];
G2L["1e3"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["1e3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e3"]["BackgroundTransparency"] = 1;
G2L["1e3"]["Position"] = UDim2.new(0.375, 0, 0.098, 0);


-- StarterGui.SSWorks.Loader.TextLabel
G2L["1e4"] = Instance.new("TextLabel", G2L["1e0"]);
G2L["1e4"]["TextWrapped"] = true;
G2L["1e4"]["BorderSizePixel"] = 0;
G2L["1e4"]["TextTransparency"] = 1;
G2L["1e4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e4"]["TextSize"] = 22;
G2L["1e4"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e4"]["BackgroundTransparency"] = 1;
G2L["1e4"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1e4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e4"]["Text"] = [[Loading Library]];
G2L["1e4"]["Position"] = UDim2.new(0.25, 0, 0.3475, 0);


-- Require G2L wrapper
local G2L_REQUIRE = require;
local G2L_MODULES = {};
local function require(Module:ModuleScript)
	local ModuleState = G2L_MODULES[Module];
	if ModuleState then
		if not ModuleState.Required then
			ModuleState.Required = true;
			ModuleState.Value = ModuleState.Closure();
		end
		return ModuleState.Value;
	end;
	return G2L_REQUIRE(Module);
end

G2L_MODULES[G2L["3"]] = {
	Closure = function()
		local script = G2L["3"];local TS = game:GetService('TweenService')
		local Template = script.Template
		local module = {}

		function module:Create(title, message, duration)
			task.spawn(function()
				-- Clone the template and set its text fields
				local Clone = Template:Clone()
				Clone.Title.Text = title
				Clone.Message.Text = message
				Clone.Parent = script.Parent.Parent.NList

				-- Play fade-in animations on the cloned instance
				TS:Create(Clone, TweenInfo.new(.4), {GroupTransparency = 0}):Play()
				TS:Create(Clone.UIStroke, TweenInfo.new(.4), {Transparency = 0}):Play()

				-- Wait for fade-in to complete
				wait(.4)

				-- Wait for the specified duration before starting fade-out
				wait(duration)

				-- Play fade-out animations on the cloned instance
				TS:Create(Clone, TweenInfo.new(.4), {GroupTransparency = 1}):Play()
				TS:Create(Clone.UIStroke, TweenInfo.new(.4), {Transparency = 1}):Play()

				-- Wait for fade-out to complete, then destroy the clone
				wait(.4)
				Clone:Destroy()
			end)
		end

		return module

	end;
};
G2L_MODULES[G2L["9"]] = {
	Closure = function()
		local script = G2L["9"];local module = {}

		function module:Bypass()
			local GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

			if GameName == "Jailbreak" then
				print('This AC Destroyer bypasses the systems but breaks them! Beware! Some mechanics will not work anymore!')
				game:GetService('Players').LocalPlayer.PlayerScripts.LocalScript:Destroy()
			end
		end

		return module
	end;
};
G2L_MODULES[G2L["a"]] = {
	Closure = function()
		local script = G2L["a"];local module = {}
		local GrabResponse = false
		local Keys = {
			"SW-rve8aw3Rd02sflIOQmRCi1Y7WfTxv7Fu", "SW-Yo9RXK7nL5apIE6PGZd5GCtCqSW8PnrJ",
			"SW-Oo3q7LOhfdNEOxrCzll7Bqjo7PnTV0lR", "SW-r4pWLRHjYXumPXFizS2secCKxYGAhWpE",
			"SW-x4pDLVJkqZ0Pv4kmCOxtmLKc2G8yZGv1", "SW-QD3fLmvWY3Pn7VBpIEsGmSKDRk8nFXsQ",
			"SW-Ck2rXLNmjHvQbzla7n5X2h3CRZW4r8xA", "SW-Y74zXGR9K2MvFwb1PIo9RLM8VhsDL7sq",
			"SW-Hd1nZEkDJn3Oo4vaESmNLFn2qCP8p3TZ", "SW-Lu9oXZNm5FqRIt2QsGOcVJL5GcVKr9sD",
			"SW-NK6aXFZ1kW5PoEwAsRnXC2ME7WpVHsCx", "SW-Rv3gYK7PLoQ8mz2NkCHzXgBJLW8qFNw5",
			"SW-Ao5pYH2LkW7PoXsCtSnDLQJM6XqG9RTk", "SW-Mv7sXBrLqN9Qn4y8ZdCmFLJ3TpCw7UoR",
			"SW-1LsXPlAm2Mn0YXx9fR7u9TCKoQP1ZkFt", "SW-2MvDLNj9YF7vGKm6cWpRM8ChPoW5rXsA",
			"SW-3OvJLKm2XG8zLNs9cFtVp7YLqQP4vTnF", "SW-4LvVKXm3ZF9yHOq7bRsJL9DhQpV6zAsG",
			"SW-5OvKRLn4BG0yINr8dUtKM0EjPoX7wYsH", "SW-6LvMLNm5CF1zJPq9eVwMN1FkRqW8xZtJ",
			"SW-7NvPLQn6EG2yKOs0fWvOP2GlSoX9aUtK", "SW-8OvQLRn7FG3zLPt1gXwQP3HmToX0bVsL",
			"SW-9PvSLUn8HG4zMQv2hYxRP4InUoY1cWsM", "SW-ALvTLVo9IG5zNRw3iZySP5JoVpY2dXtN",
			"SW-BMvULWo0JG6zOSx4jAyTQ6KpWpZ3eYuO", "SW-CLvVMPo1KG7zPTy5kByUR7LpXpZ4fZvP",
			"SW-DNvWNPp2LG8zQUz6lCyVS8MqYpZ5gAwQ", "SW-ELvXPQq3MH9zRV0nAzWT9NrZqZ6hBxR",
			"SW-FOvYQRr4NI0zSW1oBzXT0OrZqZ7iCyS", "SW-GPvZRSo5OJ1zTX2pCzYU1PrZrZ8jDzT",
			"SW-HQvASUp6PK2zUY3qDzZV2QrZsZ9kEzU", "SW-IRvBTVp7QL3zVZ4rEzAW3RrZtZ0lFaV",
			"SW-JSvCUWq8RM4zWZ5sFzBX4SrZtZ1mGbW", "SW-KTvDVXr9SN5zXZ6tGzCY5TrZuZ2nHcX",
			"SW-LUvEWBp0TO6zYZ7uHzDZ6UrZvZ3oIdY", "SW-MVvFXCq1UP7zZA8vIzE07VtZwZ4pJeZ",
			"SW-NWvGYCp2VQ8zAB9wJzF18WsZwZ5qKf0", "SW-OVvHZDq3WR9zBC0xKzG29XrZwZ6rLg1",
			"SW-PXvIAEp4XS0zCD1yLzH3AXsZzZ7sMh2", "SW-QYvJBFr5YT1zDE2zMzI4BYtZzZ8tNi3",
			"SW-RZvKCGp6ZU2zEF3AMzJ5CZtZzZ9uOj4", "SW-SAvLDHp7AV3zFG4BNzK6DYuZ0Z0vPk5",
			"SW-TBvMEIq8BW4zGH5COzL7EZvZ1Z1wQl6", "SW-UCvNFJr9CX5zHI6DPzM8FZuZ2Z2xRm7",
			"SW-VDvOGKr0DY6zIJ7EQzN9GZvZ3Z3ySn8", "SW-WEvPHLs1EZ7zJK8FRzO0HZvZ4Z4zTo9",
			"SW-XFvQIMr2FA8zKL9GSzP1IZvZ5Z5aUp0", "SW-w3TjVZbBLHlyjRqS2xmseJCxVdPfWsqhG",
		}

		function module:Post(key)
			-- Immediately return true when the correct key is found
			for _, v in pairs(Keys) do
				if key == v then
					GrabResponse = true
					script.Parent.Parent.Configurations.Key.Value = tostring(key)
					return -- stop further checking
				end
			end
			-- If no key matches, set GrabResponse to false
			GrabResponse = false
		end

		function module:Get()
			-- Return the GrabResponse status
			if GrabResponse ~= nil then
				return GrabResponse
			else
				warn('There is no key checked - GetMethod Key System')
				return false
			end
		end

		return module

	end;
};
G2L_MODULES[G2L["b"]] = {
	Closure = function()
		local script = G2L["b"];local module = {}
		local TextService = game:GetService("TextService")
		local Random = math.random

		-- Define expanded dynamic vocabulary and responses, including more casual phrases
		local wordChoices = {
			greetings = {"Hello!", "Hi!", "Hey there!", "Greetings!", "Howdy!", "Hey! Good to see you."},
			moodResponses = {"I'm feeling fantastic!", "I'm doing great, thanks for asking!", "Just here to assist you.", "Excited to help!", "Ready to dive into whatever you need."},
			names = {"You can call me AI.", "I'm your assistant here to help.", "I'm your code companion.", "Just think of me as your trusty helper."},
			farewells = {"Goodbye!", "See you later!", "Take care!", "Bye for now!", "Catch you later!", "Until next time!"},
			thinkingPhrases = {"Let me think for a moment...", "Hmm, let me process that...", "Thinking that through...", "Give me a second to ponder..."},
			failureResponses = {"I'm not quite sure what you mean.", "Hmm, can you clarify that for me?", "I'm not following you, can you rephrase?", "Sorry, I didn't catch that."},
			mathResponses = {"It looks like the answer is", "I've calculated that to be", "The result is", "I crunched the numbers and it's"},
			casualPhrases = {"Awh mate, what's going on?", "Hey, mate! How's it going?", "Awh, mate, what's new?", "What's up, mate?", "All good here, mate! You?"},
			additionalResponses = {"Anything else I can help with?", "How about you?", "What are you up to?", "Let me know if there's more!", "Need anything else?", "That reminds me, how are things on your end?"},
			funResponses = {"That's an interesting thought!", "You got me thinking!", "Wow, cool!", "That made me smile!", "Haha, I love that!", "Good one!", "Nice one!", "That's funny, mate!"},
			connectWords = {"and", "so", "but", "therefore", "then", "also", "by the way", "plus", "on that note"}
		}

		-- Function to evaluate a simple math expression safely
		local function evaluateMath(expression)
			local result = nil
			local operators = { ["+"] = true, ["-"] = true, ["*"] = true, ["/"] = true }

			local function safeEval(expr)
				local numbers, operator = expr:match("^(%-?%d+%.?%d*)%s*([%+%-%*/])%s*(%-?%d+%.?%d*)$")
				if numbers and operators[operator] then
					local a = tonumber(numbers)
					local b = tonumber(expr:match("%d+%.?%d*$"))
					if operator == "+" then
						return a + b
					elseif operator == "-" then
						return a - b
					elseif operator == "*" then
						return a * b
					elseif operator == "/" and b ~= 0 then
						return a / b
					end
				end
				return nil
			end

			result = safeEval(expression)
			return result
		end

		-- Function to adjust the size of UI elements based on text size (expand vertically but limit width)
		local function adjustSize(Extract, response)
			local font = Enum.Font.SourceSans
			local textSize = 18
			local maxAllowedWidth = 250 -- Set a maximum allowed width for the text and frame
			local padding = 20 -- Padding around the text

			-- Measure the size of the text and constrain the width
			local textBounds = TextService:GetTextSize(response, textSize, font, Vector2.new(maxAllowedWidth, 10000))

			-- Adjust the size of the TextLabel and its parent frames based on the calculated bounds
			local totalWidth = math.min(textBounds.X + padding, maxAllowedWidth + padding) -- Constrain width
			local totalHeight = textBounds.Y + padding -- Dynamically adjust height

			-- Set the sizes to make sure they are consistent
			Extract.Size = UDim2.new(0, totalWidth, 0, totalHeight)
			Extract.Main.Size = UDim2.new(0, totalWidth, 0, totalHeight)
			Extract.Main.ImageLabel.Size = UDim2.new(0, totalWidth, 0, totalHeight)
			Extract.Main.TextLabel.Size = UDim2.new(0, totalWidth, 0, totalHeight)

			-- Ensure text wrapping and centering are enabled
			Extract.Main.TextLabel.TextWrapped = true
			Extract.Main.TextLabel.TextXAlignment = Enum.TextXAlignment.Center -- Center horizontally
			Extract.Main.TextLabel.TextYAlignment = Enum.TextYAlignment.Center -- Center vertically
		end



		-- Function to pick a random word from a list of choices
		local function pickRandom(list)
			return list[Random(1, #list)]
		end

		-- Function to build a response dynamically with more sentences and diverse phrases
		local function buildResponse(message)
			local response = ""

			-- Check for greetings (including "hi")
			if string.match(string.lower(message), "hello") or string.match(string.lower(message), "hi") then
				response = pickRandom(wordChoices.greetings) .. " " .. pickRandom(wordChoices.moodResponses)

				-- Add additional mood responses or questions
				response = response .. " " .. pickRandom(wordChoices.connectWords) .. " " .. pickRandom(wordChoices.additionalResponses)

				-- Check for the AI's name
			elseif string.match(string.lower(message), "name") then
				response = pickRandom(wordChoices.names) .. " " .. pickRandom(wordChoices.connectWords) .. " I'm always ready to assist!"

				-- Check for farewell
			elseif string.match(string.lower(message), "bye") then
				response = pickRandom(wordChoices.farewells) .. " " .. pickRandom(wordChoices.connectWords) .. " if you need me, just ask."

				-- Check for casual phrases like 'mate'
			elseif string.match(string.lower(message), "mate") then
				response = pickRandom(wordChoices.casualPhrases) .. " " .. pickRandom(wordChoices.connectWords) .. " How's everything going with you?"

				-- Check if it's a math expression
			else
				local result = evaluateMath(message)

				if result then
					response = pickRandom(wordChoices.thinkingPhrases) .. " " .. pickRandom(wordChoices.mathResponses) .. ": " .. result
					response = response .. " " .. pickRandom(wordChoices.connectWords) .. " " .. pickRandom(wordChoices.additionalResponses)
				else
					response = pickRandom(wordChoices.failureResponses) .. " " .. pickRandom(wordChoices.connectWords) .. " " .. pickRandom(wordChoices.additionalResponses)
				end
			end

			-- Add a fun or quirky response at the end for more engagement
			response = response .. " " .. pickRandom(wordChoices.funResponses)

			return response
		end

		-- Faster response without heavy delays
		local function humanLikeThinking(message)
			-- Break down the response generation into smaller parts to simulate "thinking"
			local fullResponse = ""
			local parts = buildResponse(message):split(" ")

			-- A minimal delay between words to simulate quick thinking
			for _, word in ipairs(parts) do
				fullResponse = fullResponse .. word .. " "
			end

			return fullResponse
		end

		function module:Send(message)
			local response = humanLikeThinking(message)

			-- Instant typing animation
			local PlaceHolder = script.Holder:Clone()
			PlaceHolder.Parent = script.Parent.Parent.Main.ContentProvider.Executor.AI.ScrollingFrame
			PlaceHolder.Main.TextLabel.Text = ""
			task.wait(.1)
			PlaceHolder.Main.TextLabel.Text = ""
			task.wait(.2)
			PlaceHolder.Main.TextLabel.Text = ""
			task.wait(.3)
			PlaceHolder:Destroy()

			-- Create the response UI element instantly
			local ExactExtract = script.Holder:Clone()
			ExactExtract.Parent = script.Parent.Parent.Main.ContentProvider.Executor.AI.ScrollingFrame

			-- Ensure TextWrapped is enabled and Text is centered
			if ExactExtract:FindFirstChild("Main") and ExactExtract.Main:FindFirstChild("TextLabel") then
				ExactExtract.Main.TextLabel.Text = response
				ExactExtract.Main.TextLabel.TextWrapped = true
				ExactExtract.Main.TextLabel.TextXAlignment = Enum.TextXAlignment.Center -- Center horizontally
				ExactExtract.Main.TextLabel.TextYAlignment = Enum.TextYAlignment.Center -- Center vertically
			else
				print("Main or TextLabel not found. Structure: ", ExactExtract)
			end

			adjustSize(ExactExtract, response)
		end


		return module

	end;
};
G2L_MODULES[G2L["14"]] = {
	Closure = function()
		local script = G2L["14"];local module = {}
		local MPS = game:GetService('MarketplaceService')

		function module:GetPremium()
			if MPS:UserOwnsGamePassAsync(game:GetService('Players').LocalPlayer.UserId, 949226715) then
				return true
			else
				return false
			end
		end

		if module:GetPremium() then
			script.Parent.Parent.Main.KeySystem.Visible = false
		end

		return module
	end;
};
G2L_MODULES[G2L["194"]] = {
	Closure = function()
		local script = G2L["194"];--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



		-- SERVICES
		local LocalizationService = game:GetService("LocalizationService")
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		local TextService = game:GetService("TextService")
		local StarterGui = game:GetService("StarterGui")
		local GuiService = game:GetService("GuiService")
		local Players = game:GetService("Players")



		-- REFERENCE HANDLER
		-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
		-- therefore this ensures that the first required package becomes the dominant and only functioning module
		local iconModule = script
		local Reference = require(iconModule.Reference)
		local referenceObject = Reference.getObject()
		local leadPackage = referenceObject and referenceObject.Value
		if leadPackage and leadPackage ~= iconModule then
			return require(leadPackage)
		end
		if not referenceObject then
			Reference.addToReplicatedStorage()
		end



		-- MODULES
		local Signal = require(iconModule.Packages.GoodSignal)
		local Janitor = require(iconModule.Packages.Janitor)
		local Utility = require(iconModule.Utility)
		local Attribute = require(iconModule.Attribute)
		local Themes = require(iconModule.Features.Themes)
		local Gamepad = require(iconModule.Features.Gamepad)
		local Overflow = require(iconModule.Features.Overflow)
		local Icon = {}
		Icon.__index = Icon



		--- LOCAL
		local localPlayer = Players.LocalPlayer
		local themes = iconModule.Features.Themes
		local playerGui = localPlayer:WaitForChild("PlayerGui")
		local iconsDict = {}
		local anyIconSelected = Signal.new()
		local elements = iconModule.Elements
		local totalCreatedIcons = 0



		-- PRESETUP
		-- This is only used to determine if we need to apply the old topbar theme
		-- I'll be removing this and associated functions once all games have
		-- fully transitioned over to the new topbar
		if GuiService.TopbarInset.Height == 0 then
			GuiService:GetPropertyChangedSignal("TopbarInset"):Wait()
		end



		-- PUBLIC VARIABLES
		Icon.baseDisplayOrderChanged = Signal.new()
		Icon.baseDisplayOrder = 10
		Icon.baseTheme = require(themes.Default)
		Icon.isOldTopbar = GuiService.TopbarInset.Height == 36
		Icon.iconsDictionary = iconsDict
		Icon.container = require(elements.Container)(Icon)
		Icon.topbarEnabled = true
		Icon.iconAdded = Signal.new()
		Icon.iconRemoved = Signal.new()
		Icon.iconChanged = Signal.new()



		-- PUBLIC FUNCTIONS
		function Icon.getIcons()
			return Icon.iconsDictionary
		end

		function Icon.getIconByUID(UID)
			local match = Icon.iconsDictionary[UID]
			if match then
				return match
			end
		end

		function Icon.getIcon(nameOrUID)
			local match = Icon.getIconByUID(nameOrUID)
			if match then
				return match
			end
			for _, icon in pairs(iconsDict) do
				if icon.name == nameOrUID then
					return icon
				end
			end
		end

		function Icon.setTopbarEnabled(bool, isInternal)
			if typeof(bool) ~= "boolean" then
				bool = Icon.topbarEnabled
			end
			if not isInternal then
				Icon.topbarEnabled = bool
			end
			for _, screenGui in pairs(Icon.container) do
				screenGui.Enabled = bool
			end
		end

		function Icon.modifyBaseTheme(modifications)
			modifications = Themes.getModifications(modifications)
			for _, modification in pairs(modifications) do
				for _, detail in pairs(Icon.baseTheme) do
					Themes.merge(detail, modification)
				end
			end
			for _, icon in pairs(iconsDict) do
				icon:setTheme(Icon.baseTheme)
			end
		end

		function Icon.setDisplayOrder(int)
			Icon.baseDisplayOrder = int
			Icon.baseDisplayOrderChanged:Fire(int)
		end



		-- SETUP
		task.defer(Gamepad.start, Icon)
		task.defer(Overflow.start, Icon)
		for _, screenGui in pairs(Icon.container) do
			screenGui.Parent = playerGui
		end
		if Icon.isOldTopbar then
			Icon.modifyBaseTheme(require(themes.Classic))
		end



		-- CONSTRUCTOR
		function Icon.new()
			local self = {}
			setmetatable(self, Icon)

			--- Janitors (for cleanup)
			local janitor = Janitor.new()
			self.janitor = janitor
			self.themesJanitor = janitor:add(Janitor.new())
			self.singleClickJanitor = janitor:add(Janitor.new())
			self.captionJanitor = janitor:add(Janitor.new())
			self.joinJanitor = janitor:add(Janitor.new())
			self.menuJanitor = janitor:add(Janitor.new())
			self.dropdownJanitor = janitor:add(Janitor.new())

			-- Register
			local iconUID = Utility.generateUID()
			iconsDict[iconUID] = self
			janitor:add(function()
				iconsDict[iconUID] = nil
			end)

			-- Signals (events)
			self.selected = janitor:add(Signal.new())
			self.deselected = janitor:add(Signal.new())
			self.toggled = janitor:add(Signal.new())
			self.viewingStarted = janitor:add(Signal.new())
			self.viewingEnded = janitor:add(Signal.new())
			self.stateChanged = janitor:add(Signal.new())
			self.notified = janitor:add(Signal.new())
			self.noticeStarted = janitor:add(Signal.new())
			self.noticeChanged = janitor:add(Signal.new())
			self.endNotices = janitor:add(Signal.new())
			self.toggleKeyAdded = janitor:add(Signal.new())
			self.fakeToggleKeyChanged = janitor:add(Signal.new())
			self.alignmentChanged = janitor:add(Signal.new())
			self.updateSize = janitor:add(Signal.new())
			self.resizingComplete = janitor:add(Signal.new())
			self.joinedParent = janitor:add(Signal.new())
			self.menuSet = janitor:add(Signal.new())
			self.dropdownSet = janitor:add(Signal.new())
			self.updateMenu = janitor:add(Signal.new())
			self.startMenuUpdate = janitor:add(Signal.new())
			self.childThemeModified = janitor:add(Signal.new())
			self.indicatorSet = janitor:add(Signal.new())
			self.dropdownChildAdded = janitor:add(Signal.new())
			self.menuChildAdded = janitor:add(Signal.new())

			-- Properties
			self.iconModule = iconModule
			self.UID = iconUID
			self.isEnabled = true
			self.isSelected = false
			self.isViewing = false
			self.joinedFrame = false
			self.parentIconUID = false
			self.deselectWhenOtherIconSelected = true
			self.totalNotices = 0
			self.activeState = "Deselected"
			self.alignment = ""
			self.originalAlignment = ""
			self.appliedTheme = {}
			self.appearance = {}
			self.cachedInstances = {}
			self.cachedNamesToInstances = {}
			self.cachedCollectives = {}
			self.bindedToggleKeys = {}
			self.customBehaviours = {}
			self.toggleItems = {}
			self.bindedEvents = {}
			self.notices = {}
			self.menuIcons = {}
			self.dropdownIcons = {}
			self.childIconsDict = {}
			self.isOldTopbar = Icon.isOldTopbar
			self.creationTime = os.clock()

			-- Widget is the new name for an icon
			local widget = janitor:add(require(elements.Widget)(self, Icon))
			self.widget = widget
			self:setAlignment()

			-- It's important we set an order otherwise icons will not align
			-- correctly within menus
			totalCreatedIcons += 1
			local ourOrder = totalCreatedIcons
			self:setOrder(ourOrder)

			-- This applies the default them
			self:setTheme(Icon.baseTheme)

			-- Button Clicked (for states "Selected" and "Deselected")
			local clickRegion = self:getInstance("ClickRegion")
			local function handleToggle()
				if self.locked then
					return
				end
				if self.isSelected then
					self:deselect("User", self)
				else
					self:select("User", self)
				end
			end
			local isTouchTapping = false
			local isClicking = false
			clickRegion.MouseButton1Click:Connect(function()
				if isTouchTapping then
					return
				end
				isClicking = true
				task.delay(0.01, function()
					isClicking = false
				end)
				handleToggle()
			end)
			clickRegion.TouchTap:Connect(function()
				-- This resolves the bug report by @28Pixels:
				-- https://devforum.roblox.com/t/topbarplus/1017485/1104
				if isClicking then
					return
				end
				isTouchTapping = true
				task.delay(0.01, function()
					isTouchTapping = false
				end)
				handleToggle()
			end)

			-- Keys can be bound to toggle between Selected and Deselected
			janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
				if self.locked then
					return
				end
				if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
					handleToggle()
				end
			end))

			-- Button Hovering (for state "Viewing")
			-- Hovering is a state only for devices with keyboards
			-- and controllers (not touchpads)
			local function viewingStarted(dontSetState)
				if self.locked then
					return
				end
				self.isViewing = true
				self.viewingStarted:Fire(true)
				if not dontSetState then
					self:setState("Viewing", "User", self)
				end
			end
			local function viewingEnded()
				if self.locked then
					return
				end
				self.isViewing = false
				self.viewingEnded:Fire(true)
				self:setState(nil, "User", self)
			end
			self.joinedParent:Connect(function()
				if self.isViewing then
					viewingEnded()
				end
			end)
			clickRegion.MouseEnter:Connect(function()
				local dontSetState = not UserInputService.KeyboardEnabled
				viewingStarted(dontSetState)
			end)
			local touchCount = 0
			janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
			clickRegion.MouseLeave:Connect(viewingEnded)
			clickRegion.SelectionGained:Connect(viewingStarted)
			clickRegion.SelectionLost:Connect(viewingEnded)
			clickRegion.MouseButton1Down:Connect(function()
				if not self.locked and UserInputService.TouchEnabled then
					touchCount += 1
					local myTouchCount = touchCount
					task.delay(0.2, function()
						if myTouchCount == touchCount then
							viewingStarted()
						end
					end)
				end
			end)
			clickRegion.MouseButton1Up:Connect(function()
				touchCount += 1
			end)

			-- Handle overlay on viewing
			local iconOverlay = self:getInstance("IconOverlay")
			self.viewingStarted:Connect(function()
				iconOverlay.Visible = not self.overlayDisabled
			end)
			self.viewingEnded:Connect(function()
				iconOverlay.Visible = false
			end)

			-- Deselect when another icon is selected
			janitor:add(anyIconSelected:Connect(function(incomingIcon)
				if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
					self:deselect("AutoDeselect", incomingIcon)
				end
			end))

			-- This checks if the script calling this module is a descendant of a ScreenGui
			-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
			-- client respawns. This solves one of the most asked about questions on the post
			-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
			-- the LocalScript rests within
			local source =  debug.info(2, "s")
			local sourcePath = string.split(source, ".")
			local origin = game
			local originsScreenGui
			for i, sourceName in pairs(sourcePath) do
				origin = origin:FindFirstChild(sourceName)
				if not origin then
					break
				end
				if origin:IsA("ScreenGui") then
					originsScreenGui = origin
				end
			end
			if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
				Utility.localPlayerRespawned(function()
					self:destroy()
				end)
			end

			-- Additional children behaviour when toggled (mostly notices)
			local noticeLabel = self:getInstance("NoticeLabel")
			self.toggled:Connect(function(isSelected)
				self.noticeChanged:Fire(self.totalNotices)
				for childIconUID, _ in pairs(self.childIconsDict) do
					local childIcon = Icon.getIconByUID(childIconUID)
					childIcon.noticeChanged:Fire(childIcon.totalNotices)
					if not isSelected and childIcon.isSelected then
						-- If an icon within a menu or dropdown is also
						-- a dropdown or menu, then close it
						for _, _ in pairs(childIcon.childIconsDict) do
							childIcon:deselect("HideParentFeature", self)
						end
					end
				end
			end)

			-- This closes/reopens the chat or playerlist if the icon is a dropdown
			-- In the future I'd prefer to use the position+size of the chat
			-- to determine whether to close dropdown (instead of non-right-set)
			-- but for reasons mentioned here it's unreliable at the time of
			-- writing this: https://devforum.roblox.com/t/here/2794915
			-- I could also make this better by accounting for multiple
			-- dropdowns being open (not just this one) but this will work
			-- fine for almost every use case for now.
			self.selected:Connect(function()
				local isDropdown = #self.dropdownIcons > 0
				if isDropdown then
					if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
						self.chatWasPreviouslyActive = true
						StarterGui:SetCore("ChatActive", false)
					end
					if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
						self.playerlistWasPreviouslyActive = true
						StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
					end
				end
			end)
			self.deselected:Connect(function()
				if self.chatWasPreviouslyActive then
					self.chatWasPreviouslyActive = nil
					StarterGui:SetCore("ChatActive", true)
				end
				if self.playerlistWasPreviouslyActive then
					self.playerlistWasPreviouslyActive = nil
					StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
				end
			end)

			-- There's a rare occassion where the appearance is not
			-- fully set to deselected so this ensures the icons
			-- appearance is fully as it should be
			--print("self.activeState =", self.activeState)
			task.delay(0.1, function()
				if self.activeState == "Deselected" then
					self.stateChanged:Fire("Deselected")
					self:refresh()
				end
			end)

			-- Call icon added
			Icon.iconAdded:Fire(self)

			return self
		end



		-- METHODS
		function Icon:setName(name)
			self.widget.Name = name
			self.name = name
			return self
		end

		function Icon:setState(incomingStateName, fromSource, sourceIcon)
			-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
			-- a users mouse enters the widget), then informing other systems of this state change to then act upon
			-- (such as the theme handler applying the theme which corresponds to that state).
			if not incomingStateName then
				incomingStateName = (self.isSelected and "Selected") or "Deselected"
			end
			local stateName = Utility.formatStateName(incomingStateName)
			local previousStateName = self.activeState
			if previousStateName == stateName then
				return
			end
			local currentIsSelected = self.isSelected
			self.activeState = stateName
			if stateName == "Deselected" then
				self.isSelected = false
				if currentIsSelected then
					self.toggled:Fire(false, fromSource, sourceIcon)
					self.deselected:Fire(fromSource, sourceIcon)
				end
				self:_setToggleItemsVisible(false, fromSource, sourceIcon)
			elseif stateName == "Selected" then
				self.isSelected = true
				if not currentIsSelected then
					self.toggled:Fire(true, fromSource, sourceIcon)
					self.selected:Fire(fromSource, sourceIcon)
					anyIconSelected:Fire(self, fromSource, sourceIcon)
				end
				self:_setToggleItemsVisible(true, fromSource, sourceIcon)
			end
			self.stateChanged:Fire(stateName, fromSource, sourceIcon)
		end

		function Icon:getInstance(name)
			-- This enables us to easily retrieve instances located within the icon simply by passing its name.
			-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
			-- We cache the result for more performant retrieval in the future.
			local instance = self.cachedNamesToInstances[name]
			if instance then
				return instance
			end
			local function cacheInstance(childName, child)
				local currentCache = self.cachedInstances[child]
				if not currentCache then
					local collectiveName = child:GetAttribute("Collective")
					local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
					if cachedCollective then
						table.insert(cachedCollective, child)
					end
					self.cachedNamesToInstances[childName] = child
					self.cachedInstances[child] = true
					child.Destroying:Once(function()
						self.cachedNamesToInstances[childName] = nil
						self.cachedInstances[child] = nil
					end)
				end
			end
			local widget = self.widget
			cacheInstance("Widget", widget)
			if name == "Widget" then
				return widget
			end

			local returnChild
			local function scanChildren(parentInstance)
				for _, child in pairs(parentInstance:GetChildren()) do
					local widgetUID = child:GetAttribute("WidgetUID")
					if widgetUID and widgetUID ~= self.UID then
						-- This prevents instances within other icons from being recorded
						-- (for instance when other icons are added to this icons menu)
						continue
					end
					-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
					-- then its important we scan the real original instance instead of this clone
					local previousChild = child
					local realChild = Themes.getRealInstance(child)
					if realChild then
						child = realChild
					end
					-- Finally scan its children
					scanChildren(child)
					if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
						local childName = child.Name
						cacheInstance(childName, child)
						if childName == name then
							returnChild = child
						end
					end
				end
			end
			scanChildren(widget)
			return returnChild
		end

		function Icon:getCollective(name)
			-- A collective is an array of instances within the Widget that have been
			-- grouped together based on a given name. This just makes it easy
			-- to act on multiple instances at once which share similar behaviours.
			-- For instance, if we want to change the icons corner size, all corner instances
			-- with the attribute "Collective" and value "WidgetCorner" could be updated
			-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
			local collective = self.cachedCollectives[name]
			if collective then
				return collective
			end
			collective = {}
			for instance, _ in pairs(self.cachedInstances) do
				if instance:GetAttribute("Collective") == name then
					table.insert(collective, instance)
				end
			end
			self.cachedCollectives[name] = collective
			return collective
		end

		function Icon:getInstanceOrCollective(collectiveOrInstanceName)
			-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
			-- an array of instances instead of a single instance
			local instances = {}
			local instance = self:getInstance(collectiveOrInstanceName)
			if instance then
				table.insert(instances, instance)
			end
			if #instances == 0 then
				instances = self:getCollective(collectiveOrInstanceName)
			end
			return instances
		end

		function Icon:getStateGroup(iconState)
			local chosenState = iconState or self.activeState
			local stateGroup = self.appearance[chosenState]
			if not stateGroup then
				stateGroup = {}
				self.appearance[chosenState] = stateGroup
			end
			return stateGroup
		end

		function Icon:refreshAppearance(instance, specificProperty)
			Themes.refresh(self, instance, specificProperty)
			return self
		end

		function Icon:refresh()
			self:refreshAppearance(self.widget)
			self.updateSize:Fire()
			return self
		end

		function Icon:updateParent()
			local parentIcon = Icon.getIconByUID(self.parentIconUID)
			if parentIcon then
				parentIcon.updateSize:Fire()
			end
		end

		function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
			-- You can specify your own custom callback to handle custom logic just before
			-- an instances property is changed by using :setBehaviour()
			local key = collectiveOrInstanceName.."-"..property
			self.customBehaviours[key] = callback
			if refreshAppearance then
				local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
				for _, instance in pairs(instances) do
					self:refreshAppearance(instance, property)
				end
			end
		end

		function Icon:modifyTheme(modifications, modificationUID)
			local modificationUID = Themes.modify(self, modifications, modificationUID)
			return self, modificationUID
		end

		function Icon:modifyChildTheme(modifications, modificationUID)
			-- Same as modifyTheme except for its children (i.e. icons
			-- within its dropdown or menu)
			self.childModifications = modifications
			self.childModificationsUID = modificationUID
			for childIconUID, _ in pairs(self.childIconsDict) do
				local childIcon = Icon.getIconByUID(childIconUID)
				childIcon:modifyTheme(modifications, modificationUID)
			end
			self.childThemeModified:Fire()
			return self
		end

		function Icon:removeModification(modificationUID)
			Themes.remove(self, modificationUID)
			return self
		end

		function Icon:removeModificationWith(instanceName, property, state)
			Themes.removeWith(self, instanceName, property, state)
			return self
		end

		function Icon:setTheme(theme)
			Themes.set(self, theme)
			return self
		end

		function Icon:setEnabled(bool)
			self.isEnabled = bool
			self.widget.Visible = bool
			self:updateParent()
			return self
		end

		function Icon:select(fromSource, sourceIcon)
			self:setState("Selected", fromSource, sourceIcon)
			return self
		end

		function Icon:deselect(fromSource, sourceIcon)
			self:setState("Deselected", fromSource, sourceIcon)
			return self
		end

		function Icon:notify(customClearSignal, noticeId)
			-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
			-- users of changes/updates within your UI such as a Catalog
			-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
			-- Roblox event (e.g. Instance.new("BindableEvent").Event)
			local notice = self.notice
			if not notice then
				notice = require(elements.Notice)(self, Icon)
				self.notice = notice
			end
			self.noticeStarted:Fire(customClearSignal, noticeId)
			return self
		end

		function Icon:clearNotices()
			self.endNotices:Fire()
			return self
		end

		function Icon:disableOverlay(bool)
			self.overlayDisabled = bool
			return self
		end
		Icon.disableStateOverlay = Icon.disableOverlay

		function Icon:setImage(imageId, iconState)
			self:modifyTheme({"IconImage", "Image", imageId, iconState})
			return self
		end

		function Icon:setLabel(text, iconState)
			self:modifyTheme({"IconLabel", "Text", text, iconState})
			return self
		end

		function Icon:setOrder(int, iconState)
			self:modifyTheme({"Widget", "LayoutOrder", int, iconState})
			return self
		end

		function Icon:setCornerRadius(udim, iconState)
			self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
			return self
		end

		function Icon:align(leftCenterOrRight, isFromParentIcon)
			-- Determines the side of the screen the icon will be ordered
			local direction = tostring(leftCenterOrRight):lower()
			if direction == "mid" or direction == "centre" then
				direction = "center"
			end
			if direction ~= "left" and direction ~= "center" and direction ~= "right" then
				direction = "left"
			end
			local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
			local holders = screenGui.Holders
			local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
			if not isFromParentIcon then
				self.originalAlignment = finalDirection
			end
			local joinedFrame = self.joinedFrame
			local alignmentHolder = holders[finalDirection]
			self.screenGui = screenGui
			self.alignmentHolder = alignmentHolder
			if not self.isDestroyed then
				self.widget.Parent = joinedFrame or alignmentHolder
			end
			self.alignment = finalDirection
			self.alignmentChanged:Fire(finalDirection)
			Icon.iconChanged:Fire(self)
			return self
		end
		Icon.setAlignment = Icon.align

		function Icon:setLeft()
			self:setAlignment("Left")
			return self
		end

		function Icon:setMid()
			self:setAlignment("Center")
			return self
		end

		function Icon:setRight()
			self:setAlignment("Right")
			return self
		end

		function Icon:setWidth(offsetMinimum, iconState)
			-- This sets a minimum X offset size for the widget, useful
			-- for example if you're constantly changing the label
			-- but don't want the icon to resize every time
			local newSize = UDim2.fromOffset(offsetMinimum, self.widget.Size.Y.Offset)
			self:modifyTheme({"Widget", "Size", newSize, iconState})
			self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
			return self
		end

		function Icon:setImageScale(number, iconState)
			self:modifyTheme({"IconImageScale", "Value", number, iconState})
			return self
		end

		function Icon:setImageRatio(number, iconState)
			self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
			return self
		end

		function Icon:setTextSize(number, iconState)
			self:modifyTheme({"IconLabel", "TextSize", number, iconState})
			return self
		end

		function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
			fontWeight = fontWeight or Enum.FontWeight.Regular
			fontStyle = fontStyle or Enum.FontStyle.Normal
			local fontFace
			local fontType = typeof(font)
			if fontType == "number" then
				fontFace = Font.fromId(font, fontWeight, fontStyle)
			elseif fontType == "EnumItem" then
				fontFace = Font.fromEnum(font)
			elseif fontType == "string" then
				if not font:match("rbxasset") then
					fontFace = Font.fromName(font, fontWeight, fontStyle)
				end
			end
			if not fontFace then
				fontFace = Font.new(font, fontWeight, fontStyle)
			end
			self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
			return self
		end

		function Icon:bindToggleItem(guiObjectOrLayerCollector)
			if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
				error("Toggle item must be a GuiObject or LayerCollector!")
			end
			self.toggleItems[guiObjectOrLayerCollector] = true
			self:_updateSelectionInstances()
			return self
		end

		function Icon:unbindToggleItem(guiObjectOrLayerCollector)
			self.toggleItems[guiObjectOrLayerCollector] = nil
			self:_updateSelectionInstances()
			return self
		end

		function Icon:_updateSelectionInstances()
			-- This is to assist with controller navigation and selection
			-- It converts the value true to an array
			for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
				local buttonInstancesArray = {}
				for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
					if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
						table.insert(buttonInstancesArray, instance)
					end
				end
				self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
			end
		end

		function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
			for toggleItem, _ in pairs(self.toggleItems) do
				if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
					local property = "Visible"
					if toggleItem:IsA("LayerCollector") then
						property = "Enabled"
					end
					toggleItem[property] = bool
				end
			end
		end

		function Icon:bindEvent(iconEventName, eventFunction)
			local event = self[iconEventName]
			assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
			assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
			self.bindedEvents[iconEventName] = event:Connect(function(...)
				eventFunction(self, ...)
			end)
			return self
		end

		function Icon:unbindEvent(iconEventName)
			local eventConnection = self.bindedEvents[iconEventName]
			if eventConnection then
				eventConnection:Disconnect()
				self.bindedEvents[iconEventName] = nil
			end
			return self
		end

		function Icon:bindToggleKey(keyCodeEnum)
			assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
			self.bindedToggleKeys[keyCodeEnum] = true
			self.toggleKeyAdded:Fire(keyCodeEnum)
			self:setCaption("_hotkey_")
			return self
		end

		function Icon:unbindToggleKey(keyCodeEnum)
			assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
			self.bindedToggleKeys[keyCodeEnum] = nil
			return self
		end

		function Icon:call(callback, ...)
			local packedArgs = table.pack(...)
			task.spawn(function()
				callback(self, table.unpack(packedArgs))
			end)
			return self
		end

		function Icon:addToJanitor(callback)
			self.janitor:add(callback)
			return self
		end

		function Icon:lock()
			-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
			local clickRegion = self:getInstance("ClickRegion")
			clickRegion.Visible = false
			self.locked = true
			return self
		end

		function Icon:unlock()
			local clickRegion = self:getInstance("ClickRegion")
			clickRegion.Visible = true
			self.locked = false
			return self
		end

		function Icon:debounce(seconds)
			self:lock()
			task.wait(seconds)
			self:unlock()
			return self
		end

		function Icon:autoDeselect(bool)
			-- When set to true the icon will deselect itself automatically whenever
			-- another icon is selected
			if bool == nil then
				bool = true
			end
			self.deselectWhenOtherIconSelected = bool
			return self
		end

		function Icon:oneClick(bool)
			-- When set to true the icon will automatically deselect when selected, this creates
			-- the effect of a single click button
			local singleClickJanitor = self.singleClickJanitor
			singleClickJanitor:clean()
			if bool or bool == nil then
				singleClickJanitor:add(self.selected:Connect(function()
					self:deselect("OneClick", self)
				end))
			end
			self.oneClickEnabled = true
			return self
		end

		function Icon:setCaption(text)
			if text == "_hotkey_" and (self.captionText) then
				return self
			end
			local captionJanitor = self.captionJanitor
			self.captionJanitor:clean()
			if not text or text == "" then
				self.caption = nil
				self.captionText = nil
				return self
			end
			local caption = captionJanitor:add(require(elements.Caption)(self))
			caption:SetAttribute("CaptionText", text)
			self.caption = caption
			self.captionText = text
			return self
		end

		function Icon:setCaptionHint(keyCodeEnum)
			assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
			self.fakeToggleKey = keyCodeEnum
			self.fakeToggleKeyChanged:Fire(keyCodeEnum)
			self:setCaption("_hotkey_")
			return self
		end

		function Icon:leave()
			local joinJanitor = self.joinJanitor
			joinJanitor:clean()
			return self
		end

		function Icon:joinMenu(parentIcon)
			Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
			parentIcon.menuChildAdded:Fire(self)
			return self
		end

		function Icon:setMenu(arrayOfIcons)
			self.menuSet:Fire(arrayOfIcons)
			return self
		end

		function Icon:setFrozenMenu(arrayOfIcons)
			self:freezeMenu(arrayOfIcons)
			self:setMenu(arrayOfIcons)
		end

		function Icon:freezeMenu()
			-- A frozen menu is a menu which is permanently locked in the
			-- the selected state (with its toggle hidden)
			self:select("FrozenMenu", self)
			self:bindEvent("deselected", function(icon)
				icon:select("FrozenMenu", self)
			end)
			self:modifyTheme({"IconSpot", "Visible", false})
		end

		function Icon:joinDropdown(parentIcon)
			parentIcon:getDropdown()
			Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
			parentIcon.dropdownChildAdded:Fire(self)
			return self
		end

		function Icon:getDropdown()
			local dropdown = self.dropdown
			if not dropdown then
				dropdown = require(elements.Dropdown)(self)
				self.dropdown = dropdown
				self:clipOutside(dropdown)
			end
			return dropdown
		end

		function Icon:setDropdown(arrayOfIcons)
			self:getDropdown()
			self.dropdownSet:Fire(arrayOfIcons)
			return self
		end

		function Icon:clipOutside(instance)
			-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
			-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
			-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
			-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
			-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
			local instanceClone = Utility.clipOutside(self, instance)
			self:refreshAppearance(instance)
			return self, instanceClone
		end

		function Icon:setIndicator(keyCode)
			-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
			-- with controllers to show the user what button to press to highlight the topbar. You don't need
			-- to set an indicator for controllers as this is handled internally within the Gamepad module
			local indicator = self.indicator
			if not indicator then
				indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
				self.indicator = indicator
			end
			self.indicatorSet:Fire(keyCode)
		end



		-- DESTROY/CLEANUP
		function Icon:destroy()
			if self.isDestroyed then
				return
			end
			self:clearNotices()
			if self.parentIconUID then
				self:leave()
			end
			self.isDestroyed = true
			self.janitor:clean()
			Icon.iconRemoved:Fire(self)
		end
		Icon.Destroy = Icon.destroy



		return Icon
	end;
};
G2L_MODULES[G2L["197"]] = {
	Closure = function()
		local script = G2L["197"];return function(icon)

			-- Credit to lolmansReturn and Canary Software for
			-- retrieving these values
			local clickRegion = icon:getInstance("ClickRegion")
			local caption = Instance.new("CanvasGroup")
			caption.Name = "Caption"
			caption.AnchorPoint = Vector2.new(0.5, 0)
			caption.BackgroundTransparency = 1
			caption.BorderSizePixel = 0
			caption.GroupTransparency = 1
			caption.Position = UDim2.fromOffset(0, 0)
			caption.Visible = true
			caption.ZIndex = 30
			caption.Parent = clickRegion

			local box = Instance.new("Frame")
			box.Name = "Box"
			box.AutomaticSize = Enum.AutomaticSize.XY
			box.BackgroundColor3 = Color3.fromRGB(101, 102, 104)
			box.Position = UDim2.fromOffset(4, 7)
			box.ZIndex = 12
			box.Parent = caption

			local header = Instance.new("TextLabel")
			header.Name = "Header"
			header.FontFace = Font.new(
				"rbxasset://fonts/families/GothamSSm.json",
				Enum.FontWeight.Medium,
				Enum.FontStyle.Normal
			)
			header.Text = "Caption"
			header.TextColor3 = Color3.fromRGB(255, 255, 255)
			header.TextSize = 14
			header.TextTruncate = Enum.TextTruncate.None
			header.TextWrapped = false
			header.TextXAlignment = Enum.TextXAlignment.Left
			header.AutomaticSize = Enum.AutomaticSize.X
			header.BackgroundTransparency = 1
			header.LayoutOrder = 1
			header.Size = UDim2.fromOffset(0, 16)
			header.ZIndex = 18
			header.Parent = box

			local layout = Instance.new("UIListLayout")
			layout.Name = "Layout"
			layout.Padding = UDim.new(0, 8)
			layout.SortOrder = Enum.SortOrder.LayoutOrder
			layout.Parent = box

			local UICorner = Instance.new("UICorner")
			UICorner.Name = "CaptionCorner"
			UICorner.Parent = box

			local padding = Instance.new("UIPadding")
			padding.Name = "Padding"
			padding.PaddingBottom = UDim.new(0, 12)
			padding.PaddingLeft = UDim.new(0, 12)
			padding.PaddingRight = UDim.new(0, 12)
			padding.PaddingTop = UDim.new(0, 12)
			padding.Parent = box

			local hotkeys = Instance.new("Frame")
			hotkeys.Name = "Hotkeys"
			hotkeys.AutomaticSize = Enum.AutomaticSize.Y
			hotkeys.BackgroundTransparency = 1
			hotkeys.LayoutOrder = 3
			hotkeys.Size = UDim2.fromScale(1, 0)
			hotkeys.Visible = false
			hotkeys.Parent = box

			local layout1 = Instance.new("UIListLayout")
			layout1.Name = "Layout1"
			layout1.Padding = UDim.new(0, 6)
			layout1.FillDirection = Enum.FillDirection.Vertical
			layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
			layout1.HorizontalFlex = Enum.UIFlexAlignment.None
			layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
			layout1.VerticalFlex = Enum.UIFlexAlignment.None
			layout1.SortOrder = Enum.SortOrder.LayoutOrder
			layout1.Parent = hotkeys

			local keyTag1 = Instance.new("ImageLabel")
			keyTag1.Name = "Key1"
			keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
			keyTag1.ImageTransparency = 0.7
			keyTag1.ScaleType = Enum.ScaleType.Slice
			keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
			keyTag1.AutomaticSize = Enum.AutomaticSize.X
			keyTag1.BackgroundTransparency = 1
			keyTag1.LayoutOrder = 1
			keyTag1.Size = UDim2.fromOffset(0, 30)
			keyTag1.ZIndex = 15
			keyTag1.Parent = hotkeys

			local inset = Instance.new("UIPadding")
			inset.Name = "Inset"
			inset.PaddingLeft = UDim.new(0, 8)
			inset.PaddingRight = UDim.new(0, 8)
			inset.Parent = keyTag1

			local labelContent = Instance.new("TextLabel")
			labelContent.AutoLocalize = false
			labelContent.Name = "LabelContent"
			labelContent.FontFace = Font.new(
				"rbxasset://fonts/families/GothamSSm.json",
				Enum.FontWeight.Medium,
				Enum.FontStyle.Normal
			)
			labelContent.Text = ""
			labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
			labelContent.TextSize = 14
			labelContent.AutomaticSize = Enum.AutomaticSize.X
			labelContent.BackgroundTransparency = 1
			labelContent.Position = UDim2.fromOffset(0, -1)
			labelContent.Size = UDim2.fromScale(1, 1)
			labelContent.ZIndex = 16
			labelContent.Parent = keyTag1

			local caret = Instance.new("ImageLabel")
			caret.Name = "Caret"
			caret.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
			caret.ImageColor3 = Color3.fromRGB(101, 102, 104)
			caret.ImageRectOffset = Vector2.new(260, 440)
			caret.ImageRectSize = Vector2.new(16, 8)
			caret.AnchorPoint = Vector2.new(0, 0.5)
			caret.BackgroundTransparency = 1
			caret.Position = UDim2.new(0, 0, 0, 4)
			caret.Rotation = 180
			caret.Size = UDim2.fromOffset(16, 8)
			caret.ZIndex = 12
			caret.Parent = caption

			local dropShadow = Instance.new("ImageLabel")
			dropShadow.Name = "DropShadow"
			dropShadow.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
			dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
			dropShadow.ImageRectOffset = Vector2.new(217, 486)
			dropShadow.ImageRectSize = Vector2.new(25, 25)
			dropShadow.ImageTransparency = 0.45
			dropShadow.ScaleType = Enum.ScaleType.Slice
			dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
			dropShadow.BackgroundTransparency = 1
			dropShadow.Position = UDim2.fromOffset(0, 5)
			dropShadow.Size = UDim2.new(1, 0, 0, 48)
			dropShadow.Parent = caption
			box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
			end)

			-- It's important we match the sizes as this is not
			-- handles within clipOutside (as it assumes the sizes
			-- are already the same)
			local captionJanitor = icon.captionJanitor
			local _, captionClone = icon:clipOutside(caption)
			captionClone.AutomaticSize = Enum.AutomaticSize.None
			local function matchSize()
				local absolute = caption.AbsoluteSize
				captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
			end
			captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
			matchSize()



			local isCompletelyEnabled = false
			-- This handles the appearing/disappearing/positioning of the caption
			local captionHeader = caption.Box.Header
			local UserInputService = game:GetService("UserInputService")
			local function updateHotkey(keyCodeEnum)
				local hasKeyboard = UserInputService.KeyboardEnabled
				local text = caption:GetAttribute("CaptionText") or ""
				local hideHeader = text == "_hotkey_"
				if not hasKeyboard and hideHeader then
					icon:setCaption()
					return
				end
				captionHeader.Text = text
				captionHeader.Visible = not hideHeader
				if keyCodeEnum then
					labelContent.Text = keyCodeEnum.Name
					hotkeys.Visible = true
				end
				if not hasKeyboard then
					hotkeys.Visible = false
				end
			end
			caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

			local EASING_STYLE = Enum.EasingStyle.Quad
			local TWEEN_SPEED = 0.2
			local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
			local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
			local TweenService = game:GetService("TweenService")
			local RunService = game:GetService("RunService")
			local function getCaptionPosition(customEnabled)
				local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
				local yOut = 2
				local yIn = yOut + 8
				local yOffset = if enabled then yIn else yOut
				return UDim2.new(0.5, 0, 1, yOffset)
			end
			local function updatePosition(forcedEnabled)

				-- Ignore changes if not enabled to reduce redundant calls
				if not isCompletelyEnabled then
					return
				end

				-- Currently the one thing which isn't accounted for are the bounds of the screen
				-- This would be an issue if someone sets a long caption text for the left or
				-- right most icon
				local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
				local startPosition = getCaptionPosition(not enabled)
				local endPosition = getCaptionPosition(enabled)

				-- It's essential we reset the carets position to prevent the x sizing bounds
				-- of the caption from infinitely scaling up
				if enabled then
					local caretY = caret.Position.Y.Offset
					caret.Position = UDim2.fromOffset(0, caretY)
					caption.AutomaticSize = Enum.AutomaticSize.XY
					caption.Size = UDim2.fromOffset(32, 53)
				else
					local absolute = caption.AbsoluteSize
					caption.AutomaticSize = Enum.AutomaticSize.Y
					caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
				end

				-- We initially default to the opposite state
				local previousCaretX
				local function updateCaret()
					local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
					local caretY = caret.Position.Y.Offset
					local newCaretPosition = UDim2.fromOffset(caretX, caretY)
					if previousCaretX ~= caretX then
						-- Again, it's essential we reset the caret if
						-- a difference in X position is detected otherwise
						-- a slight quirk with AutomaticCanvas can cause
						-- the caption to infinitely scale
						previousCaretX = caretX
						caret.Position = UDim2.fromOffset(0, caretY)
						task.wait()
					end
					caret.Position = newCaretPosition
				end
				captionClone.Position = startPosition
				updateCaret()

				-- Now we tween into the new state
				local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
				local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
				local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
				tween:Play()
				tween.Completed:Once(function()
					updateCaretConnection:Disconnect()
				end)

			end
			captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePosition()
			end))
			updatePosition(false)

			captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
			for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
				updateHotkey(keyCodeEnum)
				break
			end
			captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
			local fakeToggleKey = icon.fakeToggleKey
			if fakeToggleKey then
				updateHotkey(fakeToggleKey)
			end

			local function setCaptionEnabled(enabled)
				if isCompletelyEnabled == enabled then
					return
				end
				local joinedFrame = icon.joinedFrame
				if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
					enabled = false
				end
				isCompletelyEnabled = enabled
				local newTransparency = (enabled and 0) or 1
				local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
				local tweenTransparency = TweenService:Create(caption, tweenInfo, {
					GroupTransparency = newTransparency
				})
				tweenTransparency:Play()
				updatePosition()
				updateHotkey()
			end

			local WAIT_DURATION = 0.5
			local RECOVER_PERIOD = 0.3
			local Icon = require(icon.iconModule)
			captionJanitor:add(icon.stateChanged:Connect(function(stateName)
				if stateName == "Viewing" then
					local lastClock = Icon.captionLastClosedClock
					local clockDifference = (lastClock and os.clock() - lastClock) or 999
					local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
					task.delay(waitDuration, function()
						if icon.activeState == "Viewing" then
							setCaptionEnabled(true)
						end
					end)
				else
					Icon.captionLastClosedClock = os.clock()
					setCaptionEnabled(false)
				end
			end))

			return caption
		end
	end;
};
G2L_MODULES[G2L["198"]] = {
	Closure = function()
		local script = G2L["198"];return function(Icon)

			local GuiService = game:GetService("GuiService")
			local isOldTopbar = Icon.isOldTopbar
			local container = {}
			local guiInset = GuiService:GetGuiInset()
			local isConsoleScreen = GuiService:IsTenFootInterface()
			local startInset = if isOldTopbar then 12 else guiInset.Y - (44 + 2)
			if isConsoleScreen then
				startInset = 10
			end
			local screenGui = Instance.new("ScreenGui")
			screenGui:SetAttribute("StartInset", startInset)
			screenGui.Name = "TopbarStandard"
			screenGui.Enabled = true
			screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			screenGui.IgnoreGuiInset = true
			screenGui.ResetOnSpawn = false
			screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
			container[screenGui.Name] = screenGui
			screenGui.DisplayOrder = Icon.baseDisplayOrder
			Icon.baseDisplayOrderChanged:Connect(function()
				screenGui.DisplayOrder = Icon.baseDisplayOrder
			end)

			local holders = Instance.new("Frame")
			local yDownOffset = if isOldTopbar then 2 else 0
			local ySizeOffset = -2
			if isConsoleScreen then
				yDownOffset += 13
				ySizeOffset = 50
			end
			holders.Name = "Holders"
			holders.BackgroundTransparency = 1
			holders.Position = UDim2.new(0, 0, 0, yDownOffset)
			holders.Size = UDim2.new(1, 0, 1, ySizeOffset)
			holders.Visible = true
			holders.ZIndex = 1
			holders.Parent = screenGui

			local screenGuiCenter = screenGui:Clone()
			local holdersCenter = screenGuiCenter.Holders
			local GuiService = game:GetService("GuiService")
			local function updateCenteredHoldersHeight()
				holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
			end
			screenGuiCenter.Name = "TopbarCentered"
			screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
			Icon.baseDisplayOrderChanged:Connect(function()
				screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
			end)
			container[screenGuiCenter.Name] = screenGuiCenter
			GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(updateCenteredHoldersHeight)
			updateCenteredHoldersHeight()

			local screenGuiClipped = screenGui:Clone()
			screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
			screenGuiClipped.DisplayOrder += 1
			Icon.baseDisplayOrderChanged:Connect(function()
				screenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1
			end)
			container[screenGuiClipped.Name] = screenGuiClipped

			local screenGuiCenterClipped = screenGuiCenter:Clone()
			screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
			screenGuiCenterClipped.DisplayOrder += 1
			Icon.baseDisplayOrderChanged:Connect(function()
				screenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1
			end)
			container[screenGuiCenterClipped.Name] = screenGuiCenterClipped

			if isOldTopbar then
				task.defer(function()
					local function decideToHideTopbar()
						if GuiService.MenuIsOpen then
							Icon.setTopbarEnabled(false, true)
						else
							Icon.setTopbarEnabled()
						end
					end
					GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
					decideToHideTopbar()
				end)
			end

			local holderReduction = -24
			local left = Instance.new("ScrollingFrame")
			left:SetAttribute("IsAHolder", true)
			left.Name = "Left"
			left.Position = UDim2.fromOffset(startInset, 0)
			left.Size = UDim2.new(1, holderReduction, 1, 0)
			left.BackgroundTransparency = 1
			left.Visible = true
			left.ZIndex = 1
			left.Active = false
			left.ClipsDescendants = true
			left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
			left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
			left.AutomaticCanvasSize = Enum.AutomaticSize.X
			left.ScrollingDirection = Enum.ScrollingDirection.X
			left.ScrollBarThickness = 0
			left.BorderSizePixel = 0
			left.Selectable = false
			left.ScrollingEnabled = false--true
			left.ElasticBehavior = Enum.ElasticBehavior.Never
			left.Parent = holders

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Padding = UDim.new(0, startInset)
			UIListLayout.FillDirection = Enum.FillDirection.Horizontal
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
			UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
			UIListLayout.Parent = left

			local center = left:Clone()
			center.ScrollingEnabled = false
			center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
			center.Name = "Center"
			center.Parent = holdersCenter

			local right = left:Clone()
			right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
			right.Name = "Right"
			right.AnchorPoint = Vector2.new(1, 0)
			right.Position = UDim2.new(1, -12, 0, 0)
			right.Parent = holders

			return container
		end
	end;
};
G2L_MODULES[G2L["199"]] = {
	Closure = function()
		local script = G2L["199"];return function(icon)

			local dropdown = Instance.new("Frame")
			dropdown.Name = "Dropdown"
			dropdown.AutomaticSize = Enum.AutomaticSize.XY
			dropdown.BackgroundTransparency = 1
			dropdown.BorderSizePixel = 0
			dropdown.AnchorPoint = Vector2.new(0.5, 0)
			dropdown.Position = UDim2.new(0.5, 0, 1, 10)
			dropdown.ZIndex = -2
			dropdown.ClipsDescendants = true
			dropdown.Parent = icon.widget

			local UICorner = Instance.new("UICorner")
			UICorner.Name = "DropdownCorner"
			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = dropdown

			local dropdownScroller = Instance.new("ScrollingFrame")
			dropdownScroller.Name = "DropdownScroller"
			dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
			dropdownScroller.BackgroundTransparency = 1
			dropdownScroller.BorderSizePixel = 0
			dropdownScroller.AnchorPoint = Vector2.new(0, 0)
			dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
			dropdownScroller.ZIndex = -1
			dropdownScroller.ClipsDescendants = true
			dropdownScroller.Visible = true
			dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
			dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
			dropdownScroller.Active = false
			dropdownScroller.ScrollingEnabled = true
			dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
			dropdownScroller.ScrollBarThickness = 5
			dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
			dropdownScroller.ScrollBarImageTransparency = 0.8
			dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
			dropdownScroller.Selectable = false
			dropdownScroller.Active = true
			dropdownScroller.Parent = dropdown

			local dropdownPadding = Instance.new("UIPadding")
			dropdownPadding.Name = "DropdownPadding"
			dropdownPadding.PaddingTop = UDim.new(0, 8)
			dropdownPadding.PaddingBottom = UDim.new(0, 8)
			dropdownPadding.Parent = dropdownScroller

			local dropdownList = Instance.new("UIListLayout")
			dropdownList.Name = "DropdownList"
			dropdownList.FillDirection = Enum.FillDirection.Vertical
			dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
			dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
			dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
			dropdownList.Parent = dropdownScroller

			local dropdownJanitor = icon.dropdownJanitor
			local Icon = require(icon.iconModule)
			icon.dropdownChildAdded:Connect(function(childIcon)
				-- Modify appearance of child when joined
				local _, modificationUID = childIcon:modifyTheme({
					{"Widget", "BorderSize", 0},
					{"IconCorners", "CornerRadius", UDim.new(0, 4)},
					{"Widget", "MinimumWidth", 190},
					{"Widget", "MinimumHeight", 56},
					{"IconLabel", "TextSize", 19},
					{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
					{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
					{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
					{"Selection", "Size", UDim2.new(1, -8, 1, -8)},
					{"Selection", "Position", UDim2.new(0, 4, 0, 4)},
				})
				task.defer(function()
					childIcon.joinJanitor:add(function()
						childIcon:removeModification(modificationUID)
					end)
				end)
			end)
			icon.dropdownSet:Connect(function(arrayOfIcons)
				-- Destroy any previous icons
				for i, otherIconUID in pairs(icon.dropdownIcons) do
					local otherIcon = Icon.getIconByUID(otherIconUID)
					otherIcon:destroy()
				end
				-- Add new icons
				local totalNewIcons = #arrayOfIcons
				if type(arrayOfIcons) == "table" then
					for i, otherIcon in pairs(arrayOfIcons) do
						otherIcon:joinDropdown(icon)
					end
				end
			end)

			-- Update visibiliy of dropdown
			local Utility = require(script.Parent.Parent.Utility)
			local function updateVisibility()
				--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
				Utility.setVisible(dropdown, icon.isSelected, "InternalDropdown")
			end
			dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
			updateVisibility()
			--task.delay(0.2, updateVisibility)

			-- This updates the scrolling frame to only display a scroll
			-- length equal to the distance produced by its MaxIcons
			local updateCount = 0
			local isUpdating = false
			local function updateMaxIcons()

				-- This prevents more than 1 update occurring every frame
				updateCount += 1
				if isUpdating then
					return
				end
				local myUpdateCount = updateCount
				isUpdating = true
				task.defer(function()
					isUpdating = false
					if updateCount ~= myUpdateCount then
						updateMaxIcons()
					end
				end)

				local maxIcons = dropdown:GetAttribute("MaxIcons")
				if not maxIcons then
					return
				end
				local orderedInstances = {}
				for _, child in pairs(dropdownScroller:GetChildren()) do
					if child:IsA("GuiObject") then
						table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
					end
				end
				table.sort(orderedInstances, function(groupA, groupB)
					return groupA[2] < groupB[2]
				end)
				local totalHeight = 0
				local hasSetNextSelection = false
				for i = 1, maxIcons do
					local group = orderedInstances[i]
					if not group then
						break
					end
					local child = group[1]
					local height = child.AbsoluteSize.Y
					totalHeight += height
					local iconUID = child:GetAttribute("WidgetUID")
					local childIcon = iconUID and Icon.getIconByUID(iconUID)
					if childIcon then
						local nextSelection = nil
						if not hasSetNextSelection then
							hasSetNextSelection = true
							nextSelection = icon:getInstance("ClickRegion")
						end
						childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
					end
				end
				totalHeight += dropdownPadding.PaddingTop.Offset
				totalHeight += dropdownPadding.PaddingBottom.Offset
				dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)
			end
			dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIcons))
			dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIcons))
			dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIcons))
			dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIcons))
			dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIcons))
			updateMaxIcons()

			return dropdown
		end
	end;
};
G2L_MODULES[G2L["19a"]] = {
	Closure = function()
		local script = G2L["19a"];return function(icon, Icon)

			local widget = icon.widget
			local contents = icon:getInstance("Contents")
			local indicator = Instance.new("Frame")
			indicator.Name = "Indicator"
			indicator.LayoutOrder = 9999999
			indicator.ZIndex = 6
			indicator.Size = UDim2.new(0, 42, 0, 42)
			indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
			indicator.BackgroundTransparency = 1
			indicator.Position = UDim2.new(1, 0, 0.5, 0)
			indicator.BorderSizePixel = 0
			indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			indicator.Parent = contents

			local indicatorButton = Instance.new("Frame")
			indicatorButton.Name = "IndicatorButton"
			indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
			indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
			indicatorButton.BorderSizePixel = 0
			indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			indicatorButton.Parent = indicator

			local GuiService = game:GetService("GuiService")
			local GamepadService = game:GetService("GamepadService")
			local ourClickRegion = icon:getInstance("ClickRegion")
			local function selectionChanged()
				local selectedClickRegion = GuiService.SelectedObject
				if selectedClickRegion == ourClickRegion then
					indicatorButton.BackgroundTransparency = 1
					indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
					indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
				else
					indicatorButton.BackgroundTransparency = 0.75
					indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
					indicatorButton.Size = UDim2.fromScale(1, 1)
				end
			end
			icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
			selectionChanged()

			local imageLabel = Instance.new("ImageLabel")
			imageLabel.LayoutOrder = 2
			imageLabel.ZIndex = 15
			imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
			imageLabel.BackgroundTransparency = 1
			imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
			imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
			imageLabel.Parent = indicatorButton

			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(1, 0)
			UICorner.Parent = indicatorButton

			local UserInputService = game:GetService("UserInputService")
			local function setIndicatorVisible(visibility)
				if visibility == nil then
					visibility = indicator.Visible
				end
				if GamepadService.GamepadCursorEnabled then
					visibility = false
				end
				if visibility then
					icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
				elseif indicator.Visible then
					icon:removeModification("IndicatorPadding")
				end
				icon:modifyTheme({"Indicator", "Visible", visibility})
				icon.updateSize:Fire()
			end
			icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
			icon.indicatorSet:Connect(function(keyCode)
				local visibility = false
				if keyCode then
					imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
					visibility = true
				end
				setIndicatorVisible(visibility)
			end)

			local function updateSize()
				local ySize = widget.AbsoluteSize.Y*0.96
				indicator.Size = UDim2.new(0, ySize, 0, ySize)
			end
			widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
			updateSize()

			return indicator
		end
	end;
};
G2L_MODULES[G2L["19b"]] = {
	Closure = function()
		local script = G2L["19b"];return function(icon)

			local menu = Instance.new("ScrollingFrame")
			menu.Name = "Menu"
			menu.BackgroundTransparency = 1
			menu.Visible = true
			menu.ZIndex = 1
			menu.Size = UDim2.fromScale(1, 1)
			menu.ClipsDescendants = true
			menu.TopImage = ""
			menu.BottomImage = ""
			menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
			menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
			menu.ScrollingEnabled = true
			menu.ScrollingDirection = Enum.ScrollingDirection.X
			menu.ZIndex = 20
			menu.ScrollBarThickness = 3
			menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
			menu.ScrollBarImageTransparency = 0.8
			menu.BorderSizePixel = 0
			menu.Selectable = false

			local Icon = require(icon.iconModule)
			local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
			menuUIListLayout.Name = "MenuUIListLayout"
			menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
			menuUIListLayout.Parent = menu

			local menuGap = Instance.new("Frame")
			menuGap.Name = "MenuGap"
			menuGap.BackgroundTransparency = 1
			menuGap.Visible = false
			menuGap.AnchorPoint = Vector2.new(0, 0.5)
			menuGap.ZIndex = 5
			menuGap.Parent = menu

			local hasStartedMenu = false
			local Themes = require(script.Parent.Parent.Features.Themes)
			local function totalChildrenChanged()

				local menuJanitor = icon.menuJanitor
				local totalIcons = #icon.menuIcons
				if hasStartedMenu then
					if totalIcons <= 0 then
						menuJanitor:clean()
						hasStartedMenu = false
					end
					return
				end
				hasStartedMenu = true

				-- Listen for changes
				menuJanitor:add(icon.toggled:Connect(function()
					if #icon.menuIcons > 0 then
						icon.updateSize:Fire()
					end
				end))

				-- Modify appearance of menu icon when joined
				local _, modificationUID = icon:modifyTheme({
					{"Menu", "Active", true},
				})
				task.defer(function()
					menuJanitor:add(function()
						icon:removeModification(modificationUID)
					end)
				end)

				-- For right-aligned icons, this ensures their menus
				-- close button appear instantly when selected (instead
				-- of partially hidden from view)
				local previousCanvasX = menu.AbsoluteCanvasSize.X
				local function rightAlignCanvas()
					if icon.alignment == "Right" then
						local newCanvasX = menu.AbsoluteCanvasSize.X
						local difference = previousCanvasX - newCanvasX
						previousCanvasX = newCanvasX
						menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
					end
				end
				menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
				menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))

				-- Apply a close selected image if the user hasn't applied thier own
				local stateGroup = icon:getStateGroup()
				local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
				local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
				if imageDeselected == imageSelected then
					local fontLink = "rbxasset://fonts/families/FredokaOne.json"
					local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
					icon:removeModificationWith("IconLabel", "Text", "Viewing")
					icon:removeModificationWith("IconLabel", "Image", "Viewing")
					icon:modifyTheme({
						{"IconLabel", "FontFace", fontFace, "Selected"},
						{"IconLabel", "Text", "X", "Selected"},
						{"IconLabel", "TextSize", 20, "Selected"},
						{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
						{"IconImage", "Image", "", "Selected"},
					})
				end

				-- Change order of spot when alignment changes
				local iconSpot = icon:getInstance("IconSpot")
				local menuGap = icon:getInstance("MenuGap")
				local function updateAlignent()
					local alignment = icon.alignment
					if alignment == "Right" then
						iconSpot.LayoutOrder = 99999
						menuGap.LayoutOrder = 99998
					else
						iconSpot.LayoutOrder = -99999
						menuGap.LayoutOrder = -99998
					end
				end
				menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
				updateAlignent()

				-- This updates the scrolling frame to only display a scroll
				-- length equal to the distance produced by its MaxIcons
				menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
					local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
					local canvasY = menu.CanvasSize.Y
					menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
				end)
				menuJanitor:add(icon.updateMenu:Connect(function()
					local maxIcons = menu:GetAttribute("MaxIcons")
					if not maxIcons then
						return
					end
					local orderedInstances = {}
					for _, child in pairs(menu:GetChildren()) do
						local widgetUID = child:GetAttribute("WidgetUID")
						if widgetUID and child.Visible then
							table.insert(orderedInstances, {child, child.AbsolutePosition.X})
						end
					end
					table.sort(orderedInstances, function(groupA, groupB)
						return groupA[2] < groupB[2]
					end)
					local totalWidth = 0
					for i = 1, maxIcons do
						local group = orderedInstances[i]
						if not group then
							break
						end
						local child = group[1]
						local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
						totalWidth += width
					end
					menu:SetAttribute("MenuWidth", totalWidth)
				end))
				local function startMenuUpdate()
					task.delay(0.1, function()
						icon.startMenuUpdate:Fire()
					end)
				end
				local iconButton = icon:getInstance("IconButton")
				local previousButtonWidth = iconButton.AbsoluteSize.X
				menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
				menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
				menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
				menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
				startMenuUpdate()
			end

			icon.menuChildAdded:Connect(totalChildrenChanged)
			icon.menuSet:Connect(function(arrayOfIcons)
				-- Reset any previous icons
				for i, otherIconUID in pairs(icon.menuIcons) do
					local otherIcon = Icon.getIconByUID(otherIconUID)
					otherIcon:destroy()
				end
				-- Apply new icons
				local totalNewIcons = #arrayOfIcons
				if type(arrayOfIcons) == "table" then
					for i, otherIcon in pairs(arrayOfIcons) do
						otherIcon:joinMenu(icon)
					end
				end
			end)

			return menu
		end
	end;
};
G2L_MODULES[G2L["19c"]] = {
	Closure = function()
		local script = G2L["19c"];return function(Icon)

			-- Credit to lolmansReturn and Canary Software for
			-- retrieving these values
			local selectionContainer = Instance.new("Frame")
			selectionContainer.Name = "SelectionContainer"
			selectionContainer.Visible = false

			local selection = Instance.new("Frame")
			selection.Name = "Selection"
			selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			selection.BackgroundTransparency = 1
			selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
			selection.BorderSizePixel = 0
			selection.Parent = selectionContainer

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(255, 255, 255)
			UIStroke.Thickness = 3
			UIStroke.Parent = selection

			local selectionGradient = Instance.new("UIGradient")
			selectionGradient.Name = "SelectionGradient"
			selectionGradient.Parent = UIStroke

			local UICorner = Instance.new("UICorner")
			UICorner:SetAttribute("Collective", "IconCorners")
			UICorner.Name = "UICorner"
			UICorner.CornerRadius = UDim.new(1, 0)
			UICorner.Parent = selection

			local RunService = game:GetService("RunService")
			local GuiService = game:GetService("GuiService")
			local rotationSpeed = 1
			selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
				rotationSpeed = selection:GetAttribute("RotationSpeed")
			end)
			RunService.Heartbeat:Connect(function()
				if not GuiService.SelectedObject then
					return
				end
				selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
			end)

			return selectionContainer

		end
	end;
};
G2L_MODULES[G2L["19d"]] = {
	Closure = function()
		local script = G2L["19d"];-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
		-- the icon (aka Widget) instance.
		-- This contains the core components of the icon such as the button, image, label and notice. It's
		-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

		return function(icon, Icon)

			local widget = Instance.new("Frame")
			widget:SetAttribute("WidgetUID", icon.UID)
			widget.Name = "Widget"
			widget.BackgroundTransparency = 1
			widget.Visible = true
			widget.ZIndex = 20
			widget.Active = false
			widget.ClipsDescendants = true

			local button = Instance.new("Frame")
			button.Name = "IconButton"
			button.Visible = true
			button.ZIndex = 2
			button.BorderSizePixel = 0
			button.Parent = widget
			button.ClipsDescendants = true
			button.Active = false -- This is essential for mobile scrollers to work when dragging
			icon.deselected:Connect(function()
				button.ClipsDescendants = true
			end)
			icon.selected:Connect(function()
				task.defer(function()
					icon.resizingComplete:Once(function()
						if icon.isSelected then
							button.ClipsDescendants = false
						end
					end)
				end)
			end)

			local iconCorner = Instance.new("UICorner")
			iconCorner:SetAttribute("Collective", "IconCorners")
			iconCorner.Parent = button

			local menu = require(script.Parent.Menu)(icon)
			local menuUIListLayout = menu.MenuUIListLayout
			local menuGap = menu.MenuGap
			menu.Parent = button

			local iconSpot = Instance.new("Frame")
			iconSpot.Name = "IconSpot"
			iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
			iconSpot.BackgroundTransparency = 0.9
			iconSpot.Visible = true
			iconSpot.AnchorPoint = Vector2.new(0, 0.5)
			iconSpot.ZIndex = 5
			iconSpot.Parent = menu

			local iconSpotCorner = iconCorner:Clone()
			iconSpotCorner.Parent = iconSpot

			local overlay = iconSpot:Clone()
			overlay.Name = "IconOverlay"
			overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			overlay.ZIndex = iconSpot.ZIndex + 1
			overlay.Size = UDim2.new(1, 0, 1, 0)
			overlay.Position = UDim2.new(0, 0, 0, 0)
			overlay.AnchorPoint = Vector2.new(0, 0)
			overlay.Visible = false
			overlay.Parent = iconSpot

			local clickRegion = Instance.new("TextButton")
			clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
			clickRegion.Name = "ClickRegion"
			clickRegion.BackgroundTransparency = 1
			clickRegion.Visible = true
			clickRegion.Text = ""
			clickRegion.ZIndex = 20
			clickRegion.Selectable = true
			clickRegion.SelectionGroup = true
			clickRegion.Parent = iconSpot

			local Gamepad = require(script.Parent.Parent.Features.Gamepad)
			Gamepad.registerButton(clickRegion)

			local clickRegionCorner = iconCorner:Clone()
			clickRegionCorner.Parent = clickRegion

			local contents = Instance.new("Frame")
			contents.Name = "Contents"
			contents.BackgroundTransparency = 1
			contents.Size = UDim2.fromScale(1, 1)
			contents.Parent = iconSpot

			local contentsList = Instance.new("UIListLayout")
			contentsList.Name = "ContentsList"
			contentsList.FillDirection = Enum.FillDirection.Horizontal
			contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
			contentsList.SortOrder = Enum.SortOrder.LayoutOrder
			contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
			contentsList.Padding = UDim.new(0, 3)
			contentsList.Parent = contents

			local paddingLeft = Instance.new("Frame")
			paddingLeft.Name = "PaddingLeft"
			paddingLeft.LayoutOrder = 1
			paddingLeft.ZIndex = 5
			paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
			paddingLeft.BackgroundTransparency = 1
			paddingLeft.BorderSizePixel = 0
			paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			paddingLeft.Parent = contents

			local paddingCenter = Instance.new("Frame")
			paddingCenter.Name = "PaddingCenter"
			paddingCenter.LayoutOrder = 3
			paddingCenter.ZIndex = 5
			paddingCenter.Size = UDim2.new(0, 0, 1, 0)
			paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
			paddingCenter.BackgroundTransparency = 1
			paddingCenter.BorderSizePixel = 0
			paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			paddingCenter.Parent = contents

			local paddingRight = Instance.new("Frame")
			paddingRight.Name = "PaddingRight"
			paddingRight.LayoutOrder = 5
			paddingRight.ZIndex = 5
			paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
			paddingRight.BackgroundTransparency = 1
			paddingRight.BorderSizePixel = 0
			paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			paddingRight.Parent = contents

			local iconLabelContainer = Instance.new("Frame")
			iconLabelContainer.Name = "IconLabelContainer"
			iconLabelContainer.LayoutOrder = 4
			iconLabelContainer.ZIndex = 3
			iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
			iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
			iconLabelContainer.BackgroundTransparency = 1
			iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
			iconLabelContainer.Parent = contents

			local iconLabel = Instance.new("TextLabel")
			local viewportX = workspace.CurrentCamera.ViewportSize.X+200
			iconLabel.Name = "IconLabel"
			iconLabel.LayoutOrder = 4
			iconLabel.ZIndex = 15
			iconLabel.AnchorPoint = Vector2.new(0, 0)
			iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
			iconLabel.ClipsDescendants = false
			iconLabel.BackgroundTransparency = 1
			iconLabel.Position = UDim2.fromScale(0, 0)
			iconLabel.RichText = true
			iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			iconLabel.TextXAlignment = Enum.TextXAlignment.Left
			iconLabel.Text = ""
			iconLabel.TextWrapped = true
			iconLabel.TextWrap = true
			iconLabel.TextScaled = false
			iconLabel.Active = false
			iconLabel.AutoLocalize = true
			iconLabel.Parent = iconLabelContainer

			local iconImage = Instance.new("ImageLabel")
			iconImage.Name = "IconImage"
			iconImage.LayoutOrder = 2
			iconImage.ZIndex = 15
			iconImage.AnchorPoint = Vector2.new(0, 0.5)
			iconImage.Size = UDim2.new(0, 0, 0.5, 0)
			iconImage.BackgroundTransparency = 1
			iconImage.Position = UDim2.new(0, 11, 0.5, 0)
			iconImage.ScaleType = Enum.ScaleType.Stretch
			iconImage.Active = false
			iconImage.Parent = contents

			local iconImageCorner = iconCorner:Clone()
			iconImageCorner:SetAttribute("Collective", nil)
			iconImageCorner.CornerRadius = UDim.new(0, 0)
			iconImageCorner.Name = "IconImageCorner"
			iconImageCorner.Parent = iconImage

			local TweenService = game:GetService("TweenService")
			local resizingCount = 0
			local repeating = false
			local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

				-- We defer changes by a frame to eliminate all but 1 requests which
				-- could otherwise stack up to 20+ requests in a single frame
				-- We then repeat again once to account for any final changes
				-- Deferring is also essential because properties are set immediately
				-- afterwards (therefore calculations will use the correct values)
				task.defer(function()
					local indicator = icon.indicator
					local usingIndicator = indicator and indicator.Visible
					local usingText = usingIndicator or iconLabel.Text ~= ""
					local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
					local alignment = Enum.HorizontalAlignment.Center
					local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
					local buttonSize = NORMAL_BUTTON_SIZE
					if usingImage and not usingText then
						iconLabelContainer.Visible = false
						iconImage.Visible = true
						paddingLeft.Visible = false
						paddingCenter.Visible = false
						paddingRight.Visible = false
					elseif not usingImage and usingText then
						iconLabelContainer.Visible = true
						iconImage.Visible = false
						paddingLeft.Visible = true
						paddingCenter.Visible = false
						paddingRight.Visible = true
					elseif usingImage and usingText then
						iconLabelContainer.Visible = true
						iconImage.Visible = true
						paddingLeft.Visible = true
						paddingCenter.Visible = not usingIndicator
						paddingRight.Visible = not usingIndicator
						alignment = Enum.HorizontalAlignment.Left
					end
					button.Size = buttonSize

					local function getItemWidth(item)
						local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
						return targetWidth
					end
					local contentsPadding = contentsList.Padding.Offset
					local initialWidgetWidth = contentsPadding --0
					local textWidth = iconLabel.TextBounds.X
					iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
					for _, child in pairs(contents:GetChildren()) do
						if child:IsA("GuiObject") and child.Visible == true then
							local itemWidth = getItemWidth(child)
							initialWidgetWidth += itemWidth + contentsPadding
						end
					end
					local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
					local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
					local widgetBorderSize = widget:GetAttribute("BorderSize")
					local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
					local menuIcons = icon.menuIcons
					local additionalWidth = 0
					local hasMenu = #menuIcons > 0
					local showMenu = hasMenu and icon.isSelected
					if showMenu then
						for _, frame in pairs(menu:GetChildren()) do
							if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
								additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
							end
						end
						if not iconSpot.Visible then
							widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
						end
						additionalWidth -= (widgetBorderSize*0.5)
						widgetWidth += additionalWidth - (widgetBorderSize*0.75)
					end
					menuGap.Visible = showMenu and iconSpot.Visible
					local desiredWidth = widget:GetAttribute("DesiredWidth")
					if desiredWidth and widgetWidth < desiredWidth then
						widgetWidth = desiredWidth
					end

					icon.updateMenu:Fire()
					local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
					local spotWidth = preWidth-(widgetBorderSize*2)
					local menuWidth = menu:GetAttribute("MenuWidth")
					local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
					if totalMenuWidth then
						local maxWidth = menu:GetAttribute("MaxWidth")
						if maxWidth then
							totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
						end
						menu:SetAttribute("MenuCanvasWidth", widgetWidth)
						if totalMenuWidth < widgetWidth then
							widgetWidth = totalMenuWidth
						end
					end

					local style = Enum.EasingStyle.Quint
					local direction = Enum.EasingDirection.Out
					local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
					local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
					local SPEED = 750
					local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
					local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
					TweenService:Create(iconSpot, spotTweenInfo, {
						Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
						Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
					}):Play()
					TweenService:Create(clickRegion, spotTweenInfo, {
						Size = UDim2.new(0, spotWidth, 1, 0),
					}):Play()
					local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
					local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
					if updateInstantly then
						widget.Size = newWidgetSize
					end
					widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
					local movingTween = TweenService:Create(widget, widgetTweenInfo, {
						Size = newWidgetSize,
					})
					movingTween:Play()
					resizingCount += 1
					for i = 1, widgetTweenInfo.Time * 100 do
						task.delay(i/100, function()
							Icon.iconChanged:Fire(icon)
						end)
					end
					task.delay(widgetTweenInfo.Time-0.2, function()
						resizingCount -= 1
						task.defer(function()
							if resizingCount == 0 then
								icon.resizingComplete:Fire()
							end
						end)
					end)
					icon:updateParent()
				end)
			end
			local Utility = require(script.Parent.Parent.Utility)
			local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
			local firstTimeSettingFontFace = true
			icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
			icon:setBehaviour("IconLabel", "FontFace", function(value)
				local previousFontFace = iconLabel.FontFace
				if previousFontFace == value then
					return
				end
				task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
				print("FONT LOADED!!!")
			end--]]

					-- Afaik there's no way to determine when a Font Family has
					-- loaded (even with ContentProvider), so we just have to try
					-- a few times and hope it loads within the refresh period
					handleLabelAndImageChanges()
					if firstTimeSettingFontFace then
						firstTimeSettingFontFace = false
						for i = 1, 10 do
							task.wait(1)
							handleLabelAndImageChanges()
						end
					end
				end)
			end)
			local function updateBorderSize()
				task.defer(function()
					local borderOffset = widget:GetAttribute("BorderSize")
					local alignment = icon.alignment
					local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
					menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
					menuGap.Size = UDim2.fromOffset(borderOffset, 0)
					menuUIListLayout.Padding = UDim.new(0, 0)
					handleLabelAndImageChanges()
				end)
			end
			icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
			icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
			icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
			icon.updateSize:Connect(handleLabelAndImageChanges)
			icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
			icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
			icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
			icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
			icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
			icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
			icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
			icon:setBehaviour("IconImage", "Image", function(value)
				local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
				if iconImage.Image ~= textureId then
					handleLabelAndImageChanges()
				end
				return textureId
			end)
			icon.alignmentChanged:Connect(function(newAlignment)
				if newAlignment == "Center" then
					newAlignment = "Left"
				end
				menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
				updateBorderSize()
			end)

			local iconImageScale = Instance.new("NumberValue")
			iconImageScale.Name = "IconImageScale"
			iconImageScale.Parent = iconImage
			iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
				iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
			end)

			local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
			UIAspectRatioConstraint.Name = "IconImageRatio"
			UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
			UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
			UIAspectRatioConstraint.Parent = iconImage

			local iconGradient = Instance.new("UIGradient")
			iconGradient.Name = "IconGradient"
			iconGradient.Enabled = true
			iconGradient.Parent = button

			local iconSpotGradient = Instance.new("UIGradient")
			iconSpotGradient.Name = "IconSpotGradient"
			iconSpotGradient.Enabled = true
			iconSpotGradient.Parent = iconSpot

			return widget
		end
	end;
};
G2L_MODULES[G2L["19e"]] = {
	Closure = function()
		local script = G2L["19e"];return function(icon, Icon)

			local notice = Instance.new("Frame")
			notice.Name = "Notice"
			notice.ZIndex = 25
			notice.AutomaticSize = Enum.AutomaticSize.X
			notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
			notice.BorderSizePixel = 0
			notice.BackgroundTransparency = 0.1
			notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			notice.Visible = false
			notice.Parent = icon.widget

			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(1, 0)
			UICorner.Parent = notice

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Parent = notice

			local noticeLabel = Instance.new("TextLabel")
			noticeLabel.Name = "NoticeLabel"
			noticeLabel.ZIndex = 26
			noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			noticeLabel.AutomaticSize = Enum.AutomaticSize.X
			noticeLabel.Size = UDim2.new(1, 0, 1, 0)
			noticeLabel.BackgroundTransparency = 1
			noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
			noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			noticeLabel.FontSize = Enum.FontSize.Size14
			noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
			noticeLabel.Text = "1"
			noticeLabel.TextWrapped = true
			noticeLabel.TextWrap = true
			noticeLabel.Font = Enum.Font.Arial
			noticeLabel.Parent = notice

			local iconModule = script.Parent.Parent
			local packages = iconModule.Packages
			local Janitor = require(packages.Janitor)
			local Signal = require(packages.GoodSignal)
			local Utility = require(iconModule.Utility)
			icon.noticeChanged:Connect(function(totalNotices)

				-- Notice amount
				if not totalNotices then
					return
				end
				local exceeded99 = totalNotices > 99
				local noticeDisplay = (exceeded99 and "99+") or totalNotices
				noticeLabel.Text = noticeDisplay
				if exceeded99 then
					noticeLabel.TextSize = 11
				end

				-- Should enable
				local enabled = true
				if totalNotices < 1 then
					enabled = false
				end
				local parentIcon = Icon.getIconByUID(icon.parentIconUID)
				local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
				if icon.isSelected and dropdownOrMenuActive then
					enabled = false
				elseif parentIcon and not parentIcon.isSelected then
					enabled = false
				end
				Utility.setVisible(notice, enabled, "NoticeHandler")

			end)
			icon.noticeStarted:Connect(function(customClearSignal, noticeId)

				if not customClearSignal then
					customClearSignal = icon.deselected
				end
				local parentIcon = Icon.getIconByUID(icon.parentIconUID)
				if parentIcon then
					parentIcon:notify(customClearSignal)
				end

				local noticeJanitor = icon.janitor:add(Janitor.new())
				local noticeComplete = noticeJanitor:add(Signal.new())
				noticeJanitor:add(icon.endNotices:Connect(function()
					noticeComplete:Fire()
				end))
				noticeJanitor:add(customClearSignal:Connect(function()
					noticeComplete:Fire()
				end))
				noticeId = noticeId or Utility.generateUID()
				icon.notices[noticeId] = {
					completeSignal = noticeComplete,
					clearNoticeEvent = customClearSignal,
				}
				local noticeLabel = icon:getInstance("NoticeLabel")
				local function updateNotice()
					icon.noticeChanged:Fire(icon.totalNotices)
				end
				icon.notified:Fire(noticeId)
				icon.totalNotices += 1
				updateNotice()
				noticeComplete:Once(function()
					noticeJanitor:destroy()
					icon.totalNotices -= 1
					icon.notices[noticeId] = nil
					updateNotice()
				end)
			end)

			-- Establish the notice
			notice:SetAttribute("ClipToJoinedParent", true)
			icon:clipOutside(notice)

			return notice
		end
	end;
};
G2L_MODULES[G2L["19f"]] = {
	Closure = function()
		local script = G2L["19f"];-- v3 alone has taken 250+ hours so please consider keeping this
		-- required attribute and linking to TopbarPlus within your games
		-- description or devforum post. An in-game readable version also
		-- makes it easier for me to debug and compare differences betewen
		-- live places. Thanks! ~Ben

		local RunService = game:GetService("RunService")
		local GroupService = game:GetService("GroupService")
		local Players = game:GetService("Players")
		if not RunService:IsStudio() then
			print(` Running TopbarPlus {require(script.Parent.VERSION)} by ForeverHD`)
		end

		return {}
	end;
};
G2L_MODULES[G2L["1a1"]] = {
	Closure = function()
		local script = G2L["1a1"];-- As the name suggests, this handles everything related to gamepads
		-- (i.e. Xbox or Playstation controllers) and their navigation
		-- I created a separate module for gamepads (and not touchpads or
		-- keyboards) because gamepads are greatly more unqiue and require
		-- additional tailored programming



		-- SERVICES
		local GamepadService = game:GetService("GamepadService")
		local UserInputService = game:GetService("UserInputService")
		local GuiService = game:GetService("GuiService")



		-- LOCAL
		local Gamepad = {}
		local Icon



		-- FUNCTIONS
		-- This is called upon the Icon initializing
		function Gamepad.start(incomingIcon)

			-- Public variables
			Icon = incomingIcon
			Icon.highlightKey = Enum.KeyCode.DPadUp -- What controller key to highlight the topbar (or set to false to disable)
			Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most

			-- We defer so the developer can make changes before the
			-- gamepad controls are initialized
			task.delay(1, function()
				-- Some local utility
				local iconsDict = Icon.iconsDictionary
				local function getIconFromSelectedObject()
					local clickRegion = GuiService.SelectedObject
					local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
					local icon = iconUID and iconsDict[iconUID]
					return icon
				end

				-- This enables users to instantly open up their last selected icon
				local previousHighlightedIcon
				local iconDisplayingHighlightKey
				local usedIndicatorOnce = false
				local usedBOnce = false
				local Utility = require(script.Parent.Parent.Utility)
				local Selection = require(script.Parent.Parent.Elements.Selection)
				local function updateSelectedObject()
					local icon = getIconFromSelectedObject()
					local gamepadEnabled = UserInputService.GamepadEnabled
					if icon then
						if gamepadEnabled then
							local clickRegion = icon:getInstance("ClickRegion")
							local selection = icon.selection
							if not selection then
								selection = icon.janitor:add(Selection(Icon))
								selection:SetAttribute("IgnoreVisibilityUpdater", true)
								selection.Parent = icon.widget
								icon.selection = selection
								icon:refreshAppearance(selection) --icon:clipOutside(selection)
							end
							clickRegion.SelectionImageObject = selection.Selection
						end
						if previousHighlightedIcon and previousHighlightedIcon ~= icon then
							previousHighlightedIcon:setIndicator()
						end
						local newIndicator = if gamepadEnabled and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
						previousHighlightedIcon = icon
						Icon.lastHighlightedIcon = icon
						icon:setIndicator(newIndicator)
					else
						local newIndicator = if gamepadEnabled and not usedIndicatorOnce then Icon.highlightKey else nil
						if not previousHighlightedIcon then
							previousHighlightedIcon = Gamepad.getIconToHighlight()
						end
						if newIndicator == Icon.highlightKey then
							-- We only display the highlightKey once to show
							-- the user how to highlight the topbar icon
							usedIndicatorOnce = true
						else
							--usedBOnce = true
						end
						if previousHighlightedIcon then
							previousHighlightedIcon:setIndicator(newIndicator)
						end
					end
				end
				GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

				-- This listens for a gamepad being present/added/removed
				local function checkGamepadEnabled()
					local gamepadEnabled = UserInputService.GamepadEnabled
					if not gamepadEnabled then
						usedIndicatorOnce = false
						usedBOnce = false
					end
					updateSelectedObject()
				end
				UserInputService:GetPropertyChangedSignal("GamepadEnabled"):Connect(checkGamepadEnabled)
				checkGamepadEnabled()

				-- This allows for easy highlighting of the topbar when the
				-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
				-- If you'd like to disable, do ``Icon.highlightKey = false``
				UserInputService.InputBegan:Connect(function(input, touchingAnObject)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						-- Sometimes the Roblox gamepad glitches when combined with a cursor
						-- This fixes that by unhighlighting if the cursor is pressed down
						-- (i.e. a mouse click)
						local icon = getIconFromSelectedObject()
						if icon then
							GuiService.SelectedObject = nil
						end
						return
					end
					if input.KeyCode ~= Icon.highlightKey then
						return
					end
					local iconToHighlight = Gamepad.getIconToHighlight()
					if iconToHighlight then
						if GamepadService.GamepadCursorEnabled then
							task.wait(0.2)
							GamepadService:DisableGamepadCursor()
						end
						local clickRegion = iconToHighlight:getInstance("ClickRegion")
						GuiService.SelectedObject = clickRegion
					end
				end)
			end)
		end

		function Gamepad.getIconToHighlight()
			-- If an icon has already been selected, returns the last selected icon
			-- Else if more than 0 icons, it selects the left-most icon
			local iconsDict = Icon.iconsDictionary
			local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
			if not iconToHighlight then
				local currentX
				for _, icon in pairs(iconsDict) do
					if icon.parentIconUID then
						continue
					end
					local thisX = icon.widget.AbsolutePosition.X
					if not currentX or thisX < currentX then
						iconToHighlight = icon
						currentX = iconToHighlight.widget.AbsolutePosition.X
					end
				end
			end
			return iconToHighlight
		end

		-- This called when the icon's ClickRegion is created
		function Gamepad.registerButton(buttonInstance)
			-- This provides a basic level of support for controllers by making
			-- the icons easy to highlight via the virtual cursor, then
			-- when selected, focuses in on the selected icon and hops
			-- between other nearby icons simply by toggling the joystick
			local inputBegan = false
			buttonInstance.InputBegan:Connect(function(input)
				-- Two wait frames required to ensure inputBegan is detected within
				-- UserInputService.InputBegan. We do this because object.InputBegan
				-- does not return the correct input objects (unlike the service)
				inputBegan = true
				task.wait()
				task.wait()
				inputBegan = false
			end)
			local connection = UserInputService.InputBegan:Connect(function(input)
				task.wait()
				if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
					-- We focus on an icon when selected via the virtual cursor
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
					GuiService.SelectedObject = buttonInstance
					return
				end
				local isSelected = GuiService.SelectedObject == buttonInstance
				local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
				local keyName = input.KeyCode.Name
				if table.find(unselectKeyCodes, keyName) and isSelected then
					-- We unfocus when back button is pressed, but ignore
					-- if the virtual cursor is disabled otherwise it will be
					-- impossible to select the topbar
					if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
						GuiService.SelectedObject = nil
					end
				end
			end)
			buttonInstance.Destroying:Once(function()
				connection:Disconnect()
			end)
		end



		return Gamepad
	end;
};
G2L_MODULES[G2L["1a2"]] = {
	Closure = function()
		local script = G2L["1a2"];-- When designing your game for many devices and screen sizes, icons may occasionally
		-- particularly for smaller devices like phones, overlap with other icons or the bounds
		-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
		-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



		-- LOCAL
		local Overflow = {}
		local holders = {}
		local orderedAvailableIcons = {}
		local iconsDict
		local currentCamera = workspace.CurrentCamera
		local overflowIcons = {}
		local overflowIconUIDs = {}
		local Utility = require(script.Parent.Parent.Utility)
		local Icon



		-- FUNCTIONS
		-- This is called upon the Icon initializing
		function Overflow.start(incomingIcon)
			Icon = incomingIcon
			iconsDict = Icon.iconsDictionary
			local primaryScreenGui
			for _, screenGui in pairs(Icon.container) do
				if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
					primaryScreenGui = screenGui
				end
				for _, holder in pairs(screenGui.Holders:GetChildren()) do
					if holder:GetAttribute("IsAHolder") then
						holders[holder.Name] = holder
					end
				end
			end

			-- We listen for changes in icons (such as them being added, removed,
			-- the setting of a different alignment, the widget size changing, etc)
			local beginOverflow = false
			local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
				if not beginOverflow then
					return
				end
				if not ignoreAvailable then
					Overflow.updateAvailableIcons("Center")
				end
				Overflow.updateBoundary("Left")
				Overflow.updateBoundary("Right")
			end)
			task.delay(1, function()
				-- This is essential to prevent central icons begin added
				-- left or right due to incomplete UIListLayout calculations
				-- within the first few frames
				beginOverflow = true
				updateBoundaries()
			end)
			Icon.iconAdded:Connect(updateBoundaries)
			Icon.iconRemoved:Connect(updateBoundaries)
			Icon.iconChanged:Connect(updateBoundaries)
			currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				updateBoundaries(true)
			end)
			primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updateBoundaries(true)
			end)
		end

		function Overflow.getWidth(icon, getMaxWidth)
			local widget = icon.widget
			return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
		end

		function Overflow.getAvailableIcons(alignment)
			local ourOrderedIcons = orderedAvailableIcons[alignment]
			if not ourOrderedIcons then
				ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
			end
			return ourOrderedIcons
		end

		function Overflow.updateAvailableIcons(alignment)

			-- We only track items that are directly on the topbar (i.e. not within a parent icon)
			local ourTotal = 0
			local holder = holders[alignment]
			local holderUIList = holder.UIListLayout
			local ourOrderedIcons = {}
			for _, icon in pairs(iconsDict) do
				local parentUID = icon.parentIconUID
				local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
				local isOverflow = overflowIconUIDs[icon.UID]
				if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow then
					table.insert(ourOrderedIcons, icon)
					ourTotal += 1
				end
			end

			-- Ignore if no icons are available
			if ourTotal <= 0 then
				return {}
			end

			-- This sorts these icons by smallest order, or if equal, left-most position
			-- (even for the right alignment because all icons are sorted left-to-right)
			table.sort(ourOrderedIcons, function(iconA, iconB)
				local orderA = iconA.widget.LayoutOrder
				local orderB = iconB.widget.LayoutOrder
				local hasParentA = iconA.parentIconUID
				local hasParentB = iconB.parentIconUID
				if hasParentA == hasParentB then
					if orderA < orderB then
						return true
					end
					if orderA > orderB then
						return false
					end
					return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
				elseif hasParentB then
					return false
				elseif hasParentA then
					return true
				end
			end)

			-- Finish up
			orderedAvailableIcons[alignment] = ourOrderedIcons
			return ourOrderedIcons

		end

		function Overflow.getRealXPositions(alignment, orderedIcons)
			-- We calculate the the absolute position of icons instead of reading
			-- directly to determine where they would be if not within an overflow
			local joinOverflow = false
			local isLeft = alignment == "Left"
			local holder = holders[alignment]
			local holderXPos = holder.AbsolutePosition.X
			local holderXSize = holder.AbsoluteSize.X
			local holderUIList = holder.UIListLayout
			local topbarInset = holderUIList.Padding.Offset
			local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
			local realXPositions = {}
			if isLeft then
				Utility.reverseTable(orderedIcons)
			end
			for i = #orderedIcons, 1, -1 do
				local icon = orderedIcons[i]
				local sizeX = Overflow.getWidth(icon)
				if not isLeft then
					absoluteX -= sizeX
				end
				realXPositions[icon.UID] = absoluteX
				if isLeft then
					absoluteX += sizeX
				end
				absoluteX += (isLeft and topbarInset) or -topbarInset
			end
			return realXPositions
		end

		function Overflow.updateBoundary(alignment)

			-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
			local holder = holders[alignment]
			local holderUIList = holder.UIListLayout
			local holderXPos = holder.AbsolutePosition.X
			local holderXSize = holder.AbsoluteSize.X
			local topbarInset = holderUIList.Padding.Offset
			local topbarPadding = holderUIList.Padding.Offset
			local BOUNDARY_GAP = topbarInset
			local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
			local boundWidth = 0
			local ourTotal = 0
			for _, icon in pairs(ourOrderedIcons) do
				boundWidth += Overflow.getWidth(icon) + topbarPadding
				ourTotal += 1
			end
			if ourTotal <= 0 then
				return
			end

			-- These are the icons with menus which icons will be moved into
			-- when overflowing
			local isCentral = alignment == "Central"
			local isLeft = alignment == "Left"
			local isRight = not isLeft
			local overflowIcon = overflowIcons[alignment]
			if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
				local order = (isLeft and -9999999) or 9999999
				overflowIcon = Icon.new()--:setLabel(`{alignment}`)
				overflowIcon:setImage(6069276526, "Deselected")
				overflowIcon:setName("Overflow"..alignment)
				overflowIcon:setOrder(order)
				overflowIcon:setAlignment(alignment)
				overflowIcon:autoDeselect(false)
				overflowIcon.isAnOverflow = true
				--overflowIcon:freezeMenu()
				overflowIcon:select("OverflowStart", overflowIcon)
				overflowIcon:setEnabled(false)
				overflowIcons[alignment] = overflowIcon
				overflowIconUIDs[overflowIcon.UID] = true
			end

			-- The default boundary is the point where both the left-most-right-icon
			-- and left-most-right-icon meet OR the opposite side of the screen
			local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
			local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
			local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
			local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
			local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
			if nearestOppositeIcon then
				local oppositeEndWidget = nearestOppositeIcon.widget
				local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
				local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
				local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
				boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
			end

			-- We get the left-most icon (if left alignment) or right-most-icon (if
			-- right alignment) of the central icons group to see if we need to change
			-- the boundary (if the central icon boundary is smaller than the alignment
			-- boundary then we use the central)
			local centerOrderedIcons = Overflow.getAvailableIcons("Center")
			local centerPos = (isLeft and 1) or #centerOrderedIcons
			local nearestCenterIcon = centerOrderedIcons[centerPos]
			local usingNearestCenter = false
			if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
				local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
				local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
				local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
				local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
				local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
				local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
				if isLeft then
					if centerBoundary < removeBoundary then
						nearestCenterIcon:align("Left")
						nearestCenterIcon.hasRelocatedInOverflow = true
					end
				elseif isRight then
					if centerBoundary > removeBoundary then
						nearestCenterIcon:align("Right")
						nearestCenterIcon.hasRelocatedInOverflow = true
					end
				end
			end

	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
			if overflowIcon then
				local menuBoundary = boundary
				local menu = overflowIcon:getInstance("Menu")
				local holderXEndPos = holderXPos + holderXSize
				local menuWidth = holderXSize
				if menu and oppositeOverflowIcon then
					local oppositeWidget = oppositeOverflowIcon.widget
					local oppositeXPos = oppositeWidget.AbsolutePosition.X
					local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
					local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
					local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
					local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
					if not usingNearestCenter then
						local halfwayXPos = holderXPos + holderXSize/2
						local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
						menuBoundary = halfwayBoundary
						if isDominant then
							menuBoundary = oppositeBoundary
						end
					end
					menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
				end
				local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
				menuWidth = Utility.round(menuWidth)
				if menu and currentMaxWidth ~= menuWidth then
					menu:SetAttribute("MaxWidth", menuWidth)
				end
			end

			-- Parent ALL icons of that alignment into the overflow if at least on
			-- sibling exceeds the bounds.
			-- We calculate the the absolute position of icons instead of reading
			-- directly to determine where they would be if not within an overflow
			local joinOverflow = false
			local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
			for i = #ourOrderedIcons, 1, -1 do
				local icon = ourOrderedIcons[i]
				local widgetX = Overflow.getWidth(icon)
				local xPos = realXPositions[icon.UID]
				if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
					joinOverflow = true
				end
			end
			for i = #ourOrderedIcons, 1, -1 do
				local icon = ourOrderedIcons[i]
				local isOverflow = overflowIconUIDs[icon.UID]
				if not isOverflow then
					if joinOverflow and not icon.parentIconUID then
						icon:joinMenu(overflowIcon)
					elseif not joinOverflow and icon.parentIconUID then
						icon:leave()
					end
				end
			end

			-- Hide the overflows when not in use
			if overflowIcon.isEnabled ~= joinOverflow then
				overflowIcon:setEnabled(joinOverflow)
			end

			-- Have the menus auto selected
			if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
				overflowIcon.overflowAlreadyOpened = true
				overflowIcon:select()
			end

		end



		return Overflow
	end;
};
G2L_MODULES[G2L["1a3"]] = {
	Closure = function()
		local script = G2L["1a3"];-- The functions here are dedicated solely to managing theme state
		-- and updating the appearance of instances to match that state.
		-- You don't need to use any of these functions, the useful ones
		-- have been abstracted as icon methods



		-- LOCAL
		local Themes = {}
		local Utility = require(script.Parent.Parent.Utility)
		local baseTheme = require(script.Default)



		-- FUNCTIONS
		function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
			if stateGroup then
				for _, detail in pairs(stateGroup) do
					local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
					if instanceName == checkingInstanceName and property == checkingPropertyName then
						return checkingValue
					end
				end
			end
		end

		function Themes.getInstanceValue(instance, property)
			local success, value = pcall(function()
				return instance[property]
			end)
			if not success then
				value = instance:GetAttribute(property)
			end
			return value
		end

		function Themes.getRealInstance(instance)
			if not instance:GetAttribute("IsAClippedClone") then
				return
			end
			local originalInstance = instance:FindFirstChild("OriginalInstance")
			if not originalInstance then
				return
			end
			return originalInstance.Value
		end

		function Themes.getClippedClone(instance)
			if not instance:GetAttribute("HasAClippedClone") then
				return
			end
			local clippedClone = instance:FindFirstChild("ClippedClone")
			if not clippedClone then
				return
			end
			return clippedClone.Value
		end

		function Themes.refresh(icon, instance, specificProperty)
			-- Some instances such as notices need immediate refreshing upon creation as
			-- they're added in after the initial refresh period
			if specificProperty then
				local stateGroup = icon:getStateGroup()
				local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
				Themes.apply(icon, instance, specificProperty, value, true)
				return
			end
			-- If no property is specified we update all properties that exist within
			-- the applied theme appearance
			local stateGroup = icon:getStateGroup()
			if not stateGroup then
				return
			end
			local validInstances = {[instance.Name] = instance}
			for _, child in pairs(instance:GetDescendants()) do
				local collective = child:GetAttribute("Collective")
				if collective then
					validInstances[collective] = child
				end
				validInstances[child.Name] = child
			end
			for _, detail in pairs(stateGroup) do
				local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
				local instanceToUpdate = validInstances[checkingInstanceName]
				if instanceToUpdate then
					Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
				end
			end
			return
		end

		function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
			-- This is responsible for **applying** appearance changes to instances within the icon
			-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
			-- This also calls callbacks given by :setBehaviour before applying these property changes
			-- to the given instances
			if icon.isDestroyed then
				return
			end
			local instances
			local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
			if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
				instances = {collectiveOrInstanceNameOrInstance}
				collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
			else
				instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
			end
			local key = collectiveOrInstanceName.."-"..property
			local customBehaviour = icon.customBehaviours[key]
			for _, instance in pairs(instances) do
				local clippedClone = Themes.getClippedClone(instance)
				if clippedClone then
					-- This means theme effects are applied to both the original
					-- instance and its clone (instead of just the instance).
					-- This is important for some properties such as position
					-- and size which might be dictated by the clone
					table.insert(instances, clippedClone)
				end
			end
			for _, instance in pairs(instances) do
				if property == "Position" and Themes.getClippedClone(instance) then
					-- The clone manages the position of the real instance so ignore
					continue
				elseif property == "Size" and Themes.getRealInstance(instance) then
					-- The real instance manages the size of the clone so ignore
					continue
				end
				local currentValue = Themes.getInstanceValue(instance, property)
				if not forceApply and value == currentValue then
					continue
				end
				if customBehaviour then
					local newValue = customBehaviour(value, instance, property)
					if newValue ~= nil then
						value = newValue
					end
				end
				local success = pcall(function()
					instance[property] = value
				end)
				if not success then
					-- If property is not a real property, we set
					-- the value as an attribute instead. This is useful
					-- for instance in :setWidth where we also want to
					-- specify a desired width for every state which can
					-- then be easily read by the widget element
					instance:SetAttribute(property, value)
				end
			end
		end

		function Themes.getModifications(modifications)
			if typeof(modifications[1]) ~= "table" then
				-- This enables users to do :modifyTheme({a,b,c,d})
				-- in addition of :modifyTheme({{a,b,c,d}})
				modifications = {modifications}
			end
			return modifications
		end

		function Themes.merge(detail, modification, callback)
			local instanceName, property, value, stateName = table.unpack(modification)
			local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
				detail[3] = value
				if callback then
					callback(detail)
				end
				return true
			end
			return false
		end

		function Themes.modify(icon, modifications, modificationsUID)
			-- This is what the 'old set' used to do (although for clarity that behaviour has now been
			-- split into two methods, .modifyTheme and .apply).
			-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
			-- state, then checking to see if the appearance of the icon needs to be updated.
			-- If no iconState is specified, the change is applied to both Deselected and Selected
			-- A modification can also be 'undone' using :removeModification and passing in
			-- the UID returned from this method
			task.spawn(function()
				modificationsUID = modificationsUID or Utility.generateUID()
				modifications = Themes.getModifications(modifications)
				for _, modification in pairs(modifications) do
					local instanceName, property, value, iconState = table.unpack(modification)
					if iconState == nil then
						-- If no state specified, apply to all states
						Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
						Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
					end
					local chosenState = Utility.formatStateName(iconState or "Deselected")
					local stateGroup = icon:getStateGroup(chosenState)
					local function nowSetIt()
						if chosenState == icon.activeState then
							Themes.apply(icon, instanceName, property, value)
						end
					end
					local function updateRecord()
						for stateName, detail in pairs(stateGroup) do
							local didMerge = Themes.merge(detail, modification, function(detail)
								detail[5] = modificationsUID
								nowSetIt()
							end)
							if didMerge then
								return
							end
						end
						local detail = {instanceName, property, value, chosenState, modificationsUID}
						table.insert(stateGroup, detail)
						nowSetIt()
					end
					updateRecord()
				end
			end)
			return modificationsUID
		end

		function Themes.remove(icon, modificationsUID)
			for iconState, stateGroup in pairs(icon.appearance) do
				for i = #stateGroup, 1, -1 do
					local detail = stateGroup[i]
					local checkingUID = detail[5]
					if checkingUID == modificationsUID then
						table.remove(stateGroup, i)
					end
				end
			end
			Themes.rebuild(icon)
		end

		function Themes.removeWith(icon, instanceName, property, state)
			for iconState, stateGroup in pairs(icon.appearance) do
				if state == iconState or not state then
					for i = #stateGroup, 1, -1 do
						local detail = stateGroup[i]
						local detailName = detail[1]
						local detailProperty = detail[2]
						if detailName == instanceName and detailProperty == property then
							table.remove(stateGroup, i)
						end
					end
				end
			end
			Themes.rebuild(icon)
		end

		function Themes.change(icon)
			-- This changes the theme to the appearance of whatever
			-- state is currently active
			local stateGroup = icon:getStateGroup()
			for _, detail in pairs(stateGroup) do
				local instanceName, property, value = unpack(detail)
				Themes.apply(icon, instanceName, property, value)
			end
		end

		function Themes.set(icon, theme)
			-- This is responsible for processing the final appearance of a given theme (such as
			-- ensuring Deselected merge into missing Selected, saving that internal state,
			-- then checking to see if the appearance of the icon needs to be updated
			local themesJanitor = icon.themesJanitor
			themesJanitor:clean()
			themesJanitor:add(icon.stateChanged:Connect(function()
				Themes.change(icon)
			end))
			if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
				theme = require(theme)
			end
			icon.appliedTheme = theme
			Themes.rebuild(icon)
		end

		function Themes.statesMatch(state1, state2)
			-- States match if they have the same name OR if nil (because unspecified represents all states)
			local state1lower = (state1 and string.lower(state1))
			local state2lower = (state2 and string.lower(state2))
			return state1lower == state2lower or not state1 or not state2
		end

		function Themes.rebuild(icon)
			-- A note for my future self: this code can be optimised further by
			-- converting appearance into a instanceName-property dictionary
			-- as apposed to an array of every potential change. When converting
			-- in the future, .modify and .apply would also have to be updated.
			local appliedTheme = icon.appliedTheme
			local statesArray = {"Deselected", "Selected", "Viewing"}
			local function generateTheme()
				for _, stateName in pairs(statesArray) do
					-- This applies themes in layers
					-- The last layers take higher priority as they overwrite
					-- any duplicate earlier applied effects
					local stateAppearance = {}
					local function updateDetails(theme, incomingStateName)
						-- This ensures there's always a base 'default' layer
						if not theme then
							return
						end
						for _, detail in pairs(theme) do
							local modificationsUID = detail[5]
							local detailStateName = detail[4]
							if Themes.statesMatch(incomingStateName, detailStateName) then
								local key = detail[1].."-"..detail[2]
								local newDetail = Utility.copyTable(detail)
								newDetail[5] = modificationsUID
								stateAppearance[key] = newDetail
							end
						end
					end
					-- First we apply the base theme (i.e. the Default module)
					if stateName == "Selected" then
						updateDetails(baseTheme, "Deselected")
					end
					updateDetails(baseTheme, "Empty")
					updateDetails(baseTheme, stateName)
					-- Next we apply any custom themes by the games developer
					if appliedTheme ~= baseTheme then
						if stateName == "Selected" then
							updateDetails(appliedTheme, "Deselected")
						end
						updateDetails(baseTheme, "Empty")
						updateDetails(appliedTheme, stateName)
					end
					-- Finally we apply any modifications that have already been made
					-- Modifiers are all the changes made using icon:modifyTheme(...)
					local alreadyAppliedTheme = {}
					local alreadyAppliedGroup = icon.appearance[stateName]
					if alreadyAppliedGroup then
						for _, modifier in pairs(alreadyAppliedGroup) do
							local modificationsUID = modifier[5]
							if modificationsUID ~= nil then
								local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
								table.insert(alreadyAppliedTheme, modification)
							end
						end
					end
					updateDetails(alreadyAppliedTheme, stateName)
					-- This now converts it into our final appearance
					local finalStateAppearance = {}
					for _, detail in pairs(stateAppearance) do
						table.insert(finalStateAppearance, detail)
					end
					icon.appearance[stateName] = finalStateAppearance
				end
				Themes.change(icon)
			end
			generateTheme()
		end



		return Themes
	end;
};
G2L_MODULES[G2L["1a4"]] = {
	Closure = function()
		local script = G2L["1a4"];-- This is to provide backwards compatability with the old Roblox
		-- topbar while experiences transition over to the new topbar
		-- You don't need to apply this yourself, topbarplus automatically
		-- applies it if the old roblox topbar is detected


		return {
			{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
			{"Selection", "Position", UDim2.new(0, 3, 0, 3)},

			{"Widget", "MinimumWidth", 32, "Deselected"},
			{"Widget", "MinimumHeight", 32, "Deselected"},
			{"Widget", "BorderSize", 0, "Deselected"},
			{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
			{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
			{"IconLabel", "TextSize", 14, "Deselected"},
			{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
			{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
			{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
			{"NoticeLabel", "TextSize", 11, "Deselected"},

			{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
			{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
			{"IconSpotGradient", "Enabled", false, "Selected"},
			{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},

		}
	end;
};
G2L_MODULES[G2L["1a5"]] = {
	Closure = function()
		local script = G2L["1a5"];-- Themes in v3 work simply by applying the value (agument[3])
		-- to the property (agument[2]) of an instance within the icon which
		-- matches the name of argument[1]. Argument[1] can also be used to
		-- specify a collection of instances with a corresponding 'collective'
		-- value. A colletive is simply an attribute applied to some instances
		-- within the icon to group them together (such as "IconCorners").
		-- If the property (argument[2]) does not exist within the instance,
		-- it will instead be applied as an attribute on the instance:
		-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
		-- Use argument[4] to specify a state: "Deselected", "Selected"
		-- or "Viewing". If argument[4] is empty the state will default
		-- to "Deselected".
		-- I've designed themes this way so you have full control over
		-- the appearance of the widget and its descendants


		return {

			-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
			{"IconCorners", "CornerRadius", UDim.new(1, 0)},
			{"Selection", "RotationSpeed", 1},
			{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
			{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
			{"SelectionGradient", "Color", ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
			})},

			-- When the icon is deselected
			{"IconImage", "Image", "", "Deselected"},
			{"IconLabel", "Text", "", "Deselected"},
			{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
			{"Widget", "MinimumWidth", 44, "Deselected"},
			{"Widget", "MinimumHeight", 44, "Deselected"},
			{"Widget", "BorderSize", 4, "Deselected"},
			{"IconButton", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
			{"IconButton", "BackgroundTransparency", 0.3, "Deselected"},
			{"IconImageScale", "Value", 0.5, "Deselected"},
			{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
			{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
			{"IconImage", "ImageTransparency", 0, "Deselected"},
			{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/GothamSSm.json", Enum.FontWeight.Medium, Enum.FontStyle.Normal), "Deselected"},
			{"IconLabel", "TextSize", 16, "Deselected"},
			{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
			{"IconOverlay", "BackgroundTransparency", 0.925, "Deselected"},
			{"IconSpotGradient", "Enabled", false, "Deselected"},
			{"IconGradient", "Enabled", false, "Deselected"},
			{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
			{"Menu", "Active", false, "Deselected"},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
			{"Dropdown", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
			{"Dropdown", "BackgroundTransparency", 0.3, "Deselected"},
			{"Dropdown", "MaxIcons", 4, "Deselected"},
			{"Menu", "MaxIcons", 4, "Deselected"},
			{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
			{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
			{"NoticeLabel", "TextSize", 13, "Deselected"},
			{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
			{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},

			-- When the icon is selected
			-- Selected also inherits everything from Deselected if nothing is set
			{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
			{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
			{"IconSpotGradient", "Enabled", true, "Selected"},
			{"IconSpotGradient", "Rotation", 45, "Selected"},
			{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},


			-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
			--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},

		}
	end;
};
G2L_MODULES[G2L["1a6"]] = {
	Closure = function()
		local script = G2L["1a6"];-- This module enables you to place Icon wherever you like within the data model while
		-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
		-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
		-- cause icons to overlap with each other

		local replicatedStorage = game:GetService("ReplicatedStorage")
		local Reference = {}
		Reference.objectName = "TopbarPlusReference"

		function Reference.addToReplicatedStorage()
			local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
			if existingItem then
				return false
			end
			local objectValue = Instance.new("ObjectValue")
			objectValue.Name = Reference.objectName
			objectValue.Value = script.Parent
			objectValue.Parent = replicatedStorage
			return objectValue
		end

		function Reference.getObject()
			local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
			if objectValue then
				return objectValue
			end
			return false
		end

		return Reference
	end;
};
G2L_MODULES[G2L["1a7"]] = {
	Closure = function()
		local script = G2L["1a7"];return "v3.0.2"
	end;
};
G2L_MODULES[G2L["1a8"]] = {
	Closure = function()
		local script = G2L["1a8"];-- Just generic utility functions which I use and repeat across all my projects



		-- LOCAL
		local Utility = {}
		local Players = game:GetService("Players")
		local localPlayer = Players.LocalPlayer



		-- FUNCTIONS
		function Utility.createStagger(delayTime, callback, delayInitially)
			-- This creates and returns a function which when called
			-- acts identically to callback, however will only be called
			-- for a maximum of once per delayTime. If the returned function
			-- is called more than once during the delayTime, then it will
			-- wait until the expiryTime then perform another recall.
			-- This is useful for visual interfaces and effects which may be
			-- triggered multiple times within a frame or short period, but which
			-- we don't necessary need to (for performance reasons).
			local staggerActive = false
			local multipleCalls = false
			if not delayTime or delayTime == 0 then
				-- We make 0.01 instead of 0 because devices can now run at
				-- different frame rates
				delayTime = 0.01
			end
			local function staggeredCallback(...)
				if staggerActive then
					multipleCalls = true
					return
				end
				local packedArgs = table.pack(...)
				staggerActive = true
				multipleCalls = false
				task.spawn(function()
					if delayInitially then
						task.wait(delayTime)
					end
					callback(table.unpack(packedArgs))
				end)
				task.delay(delayTime, function()
					staggerActive = false
					if multipleCalls then
						-- This means it has been called at least once during
						-- the stagger period, so call again
						staggeredCallback(table.unpack(packedArgs))
					end
				end)
			end
			return staggeredCallback
		end

		function Utility.round(n)
			-- Credit to Darkmist101 for this
			return math.floor(n + 0.5)
		end

		function Utility.reverseTable(t)
			for i = 1, math.floor(#t/2) do
				local j = #t - i + 1
				t[i], t[j] = t[j], t[i]
			end
		end

		function Utility.copyTable(t)
			-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
			assert(type(t) == "table", "First argument must be a table")
			local tCopy = table.create(#t)
			for k,v in pairs(t) do
				if (type(v) == "table") then
					tCopy[k] = Utility.copyTable(v)
				else
					tCopy[k] = v
				end
			end
			return tCopy
		end

		local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
		function Utility.generateUID(length)
			length = length or 8
			local UID = ""
			local list = validCharacters
			local total = #list
			for i = 1, length do
				local randomCharacter = list[math.random(1, total)]
				UID = UID..randomCharacter
			end
			return UID
		end

		local instanceTrackers = {}
		function Utility.setVisible(instance, bool, sourceUID)
			-- This effectively works like a buff object but
			-- incredibly simplified. It stacks false values
			-- so that if there is more than more than, the 
			-- instance remains hidden even if set visible true
			local tracker = instanceTrackers[instance]
			if not tracker then
				tracker = {}
				instanceTrackers[instance] = tracker
				instance.Destroying:Once(function()
					instanceTrackers[instance] = nil
				end)
			end
			if not bool then
				tracker[sourceUID] = true
			else
				tracker[sourceUID] = nil
			end
			local isVisible = bool
			if bool then
				for sourceUID, _ in pairs(tracker) do
					isVisible = false
					break
				end
			end
			instance.Visible = isVisible
		end

		function Utility.formatStateName(incomingStateName)
			return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
		end

		function Utility.localPlayerRespawned(callback)
			-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
			-- In these scenarios, traditional methods like CharacterAdded won't be called by the
			-- time the localscript has been destroyed, therefore we listen for removing instead
			-- If humanoid and health == 0, then reset/died normally, else was
			-- forcefully reset via a method such as LoadCharacter
			-- We wrap this behaviour in case any additional quirks need to be accounted for
			localPlayer.CharacterRemoving:Connect(callback)
		end

		function Utility.getClippedContainer(screenGui)
			-- We always want clipped items to display in front hence
			-- why we have this
			local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
			if not clippedContainer then
				clippedContainer = Instance.new("Folder")
				clippedContainer.Name = "ClippedContainer"
				clippedContainer.Parent = screenGui
			end
			return clippedContainer
		end

		local Janitor = require(script.Parent.Packages.Janitor)
		local GuiService = game:GetService("GuiService")
		function Utility.clipOutside(icon, instance)
			local cloneJanitor = icon.janitor:add(Janitor.new())
			instance.Destroying:Once(function()
				cloneJanitor:Destroy()
			end)
			icon.janitor:add(instance)

			local originalParent = instance.Parent
			local clone = cloneJanitor:add(Instance.new("Frame"))
			clone:SetAttribute("IsAClippedClone", true)
			clone.Name = instance.Name
			clone.AnchorPoint = instance.AnchorPoint
			clone.Size = instance.Size
			clone.Position = instance.Position
			clone.BackgroundTransparency = 1
			clone.LayoutOrder = instance.LayoutOrder
			clone.Parent = originalParent

			local valueInstance = Instance.new("ObjectValue")
			valueInstance.Name = "OriginalInstance"
			valueInstance.Value = instance
			valueInstance.Parent = clone

			local valueInstanceCopy = valueInstance:Clone()
			instance:SetAttribute("HasAClippedClone", true)
			valueInstanceCopy.Name = "ClippedClone"
			valueInstanceCopy.Value = clone
			valueInstanceCopy.Parent = instance

			local screenGui
			local function updateScreenGui()
				local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
				screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else originalScreenGui.Parent[originalScreenGui.Name.."Clipped"]
				instance.AnchorPoint = Vector2.new(0, 0)
				instance.Parent = Utility.getClippedContainer(screenGui)
			end
			cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
			updateScreenGui()

			-- Lets copy over children that modify size
			for _, child in pairs(instance:GetChildren()) do
				if child:IsA("UIAspectRatioConstraint") then
					child:Clone().Parent = clone
				end
			end

			-- If the icon is hidden, its important we are too (as
			-- setting a parent to visible = false no longer makes
			-- this hidden)
			local widget = icon.widget
			local isOutsideParent = false
			local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
			local function updateVisibility()
				if ignoreVisibilityUpdater then
					return
				end
				local isVisible = widget.Visible

				if isOutsideParent then
					isVisible = false
				end
				Utility.setVisible(instance, isVisible, "ClipHandler")
			end
			cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

			local previousScroller
			local Icon = require(icon.iconModule)
			local function checkIfOutsideParentXBounds()
				-- Defer so that roblox's properties reflect their true values
				task.defer(function()
					-- If the instance is within a parent item (such as a dropdown or menu)
					-- then we hide it if it exceeds the bounds of that parent
					local parentInstance
					local ourUID = icon.UID
					local nextIconUID = ourUID
					local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
					if shouldClipToParent then
						for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
							local nextIcon = Icon.getIconByUID(nextIconUID)
							if not nextIcon then
								break
							end
							local nextParentInstance = nextIcon.joinedFrame
							nextIconUID = nextIcon.parentIconUID
							if not nextParentInstance then
								break
							end
							parentInstance = nextParentInstance
						end
					end
					if not parentInstance then
						isOutsideParent = false
						updateVisibility()
						return
					end
					local pos = instance.AbsolutePosition
					local halfSize = instance.AbsoluteSize/2
					local parentPos = parentInstance.AbsolutePosition
					local parentSize = parentInstance.AbsoluteSize
					local posHalf = (pos + halfSize)
					local exceededLeft = posHalf.X < parentPos.X
					local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
					local exceededTop = posHalf.Y < parentPos.Y
					local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
					local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
					if hasExceeded ~= isOutsideParent then
						isOutsideParent = hasExceeded
						updateVisibility()
					end
					if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
						previousScroller = parentInstance
						local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
							checkIfOutsideParentXBounds()
						end)
						cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
					end
				end)
			end

			local camera = workspace.CurrentCamera
			local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
			local function trackProperty(property)
				local absoluteProperty = "Absolute"..property
				local function updateProperty()
					local cloneValue = clone[absoluteProperty]
					local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
					if property == "Position" then

						-- This binds the instances within the bounds of the screen
						local SIDE_PADDING = 4
						local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
						local inputX = absoluteValue.X.Offset
						if inputX < SIDE_PADDING then
							inputX = SIDE_PADDING
						elseif inputX > limitX then
							inputX = limitX
						end
						absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

						-- AbsolutePosition does not perfectly match with TopbarInsets enabled
						-- This corrects this
						local topbarInset = GuiService.TopbarInset
						local viewportWidth = workspace.CurrentCamera.ViewportSize.X
						local guiWidth = screenGui.AbsoluteSize.X
						local guiOffset = screenGui.AbsolutePosition.X
						local widthDifference = guiOffset - topbarInset.Min.X
						local oldTopbarCenterOffset = 0--widthDifference/30 -- I have no idea why this works, it just does
						local offsetX = if icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset

						-- Also add additionalOffset
						offsetX -= additionalOffsetX
						absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

						-- Finally check if within its direct parents bounds
						checkIfOutsideParentXBounds()

					end
					instance[property] = absoluteValue
				end

				-- This defer is essential as the listener may be in a different screenGui to the actor
				local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
				cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))

				-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
				-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
				-- within this type of screenGui DO NOT accurately update to match their new
				-- real world position; instead they jump around almost randomly for a few frames.
				-- I have spent way too many hours trying to solve this bug, I think the only way
				-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
				-- have time to redesign the entire system around that at the moment.
				-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
				local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
				cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))

			end
			task.delay(0.1, checkIfOutsideParentXBounds)
			checkIfOutsideParentXBounds()
			updateVisibility()
			trackProperty("Position")

			-- Track visiblity changes
			cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
				--print("Visiblity changed:", instance, clone, instance.Visible)
				--clone.Visible = instance.Visible
			end))

			-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
			local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
			if shouldTrackCloneSize then
				trackProperty("Size")
			else
				cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
					local absolute = instance.AbsoluteSize
					clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
				end))
			end

			return clone
		end

		function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

			-- This is resonsible for moving the icon under a feature like a dropdown
			local joinJanitor = originalIcon.joinJanitor
			joinJanitor:clean()
			if not scrollingFrameOrFrame then
				originalIcon:leave()
				return
			end
			originalIcon.parentIconUID = parentIcon.UID
			originalIcon.joinedFrame = scrollingFrameOrFrame
			local function updateAlignent()
				local parentAlignment = parentIcon.alignment
				if parentAlignment == "Center" then
					parentAlignment = "Left"
				end
				originalIcon:setAlignment(parentAlignment, true)
			end
			joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
			updateAlignent()
			originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
			originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
			if parentIcon.childModifications then
				-- We defer so that the default values (such as dropdown
				-- minimum width can be applied before any custom
				-- child modifications from the user)
				task.defer(function()
					originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
				end)
			end
			--
			local clickRegion = originalIcon:getInstance("ClickRegion")
			local function makeSelectable()
				clickRegion.Selectable = parentIcon.isSelected
			end
			joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
			task.defer(makeSelectable)
			joinJanitor:add(function()
				clickRegion.Selectable = true
			end)
			--

			-- We track icons in arrays and dictionaries using their UID instead of the icon
			-- itself to prevent heavy cyclical tables when printing the icons
			local originalIconUID = originalIcon.UID
			table.insert(iconsArray, originalIconUID)
			parentIcon:autoDeselect(false)
			parentIcon.childIconsDict[originalIconUID] = true
			if not parentIcon.isEnabled then
				parentIcon:setEnabled(true)
			end
			originalIcon.joinedParent:Fire(parentIcon)

			-- This is responsible for removing it from that feature and updating
			-- their parent icon so its informed of the icon leaving it
			joinJanitor:add(function()
				local joinedFrame = originalIcon.joinedFrame
				if not joinedFrame then
					return
				end
				for i, iconUID in pairs(iconsArray) do
					if iconUID == originalIconUID then
						table.remove(iconsArray, i)
						break
					end
				end
				local Icon = require(originalIcon.iconModule)
				local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
				if not parentIcon then
					return
				end
				originalIcon:setAlignment(originalIcon.originalAlignment)
				originalIcon.parentIconUID = false
				originalIcon.joinedFrame = false
				originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
				originalIcon:removeModification("JoinModification")

				local parentHasNoChildren = true
				local parentChildIcons = parentIcon.childIconsDict
				parentChildIcons[originalIconUID] = nil
				for childIconUID, _ in pairs(parentChildIcons) do
					parentHasNoChildren = false
					break
				end
				if parentHasNoChildren and not parentIcon.isAnOverflow then
					parentIcon:setEnabled(false)
				end
				updateAlignent()

			end)

		end



		return Utility
	end;
};
G2L_MODULES[G2L["1aa"]] = {
	Closure = function()
		local script = G2L["1aa"];--------------------------------------------------------------------------------
		--               Batched Yield-Safe Signal Implementation                     --
		-- This is a Signal class which has effectively identical behavior to a       --
		-- normal RBXScriptSignal, with the only difference being a couple extra      --
		-- stack frames at the bottom of the stack trace when an error is thrown.     --
		-- This implementation caches runner coroutines, so the ability to yield in   --
		-- the signal handlers comes at minimal extra cost over a naive signal        --
		-- implementation that either always or never spawns a thread.                --
		--                                                                            --
		-- API:                                                                       --
		--   local Signal = require(THIS MODULE)                                      --
		--   local sig = Signal.new()                                                 --
		--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
		--   sig:Fire(arg1, arg2, ...)                                                --
		--   connection:Disconnect()                                                  --
		--   sig:DisconnectAll()                                                      --
		--   local arg1, arg2, ... = sig:Wait()                                       --
		--                                                                            --
		-- Licence:                                                                   --
		--   Licenced under the MIT licence.                                          --
		--                                                                            --
		-- Authors:                                                                   --
		--   stravant - July 31st, 2021 - Created the file.                           --
		--------------------------------------------------------------------------------

		-- The currently idle thread to run the next handler on
		local freeRunnerThread = nil

		-- Function which acquires the currently idle handler runner thread, runs the
		-- function fn on it, and then releases the thread, returning it to being the
		-- currently idle one.
		-- If there was a currently idle runner thread already, that's okay, that old
		-- one will just get thrown and eventually GCed.
		local function acquireRunnerThreadAndCallEventHandler(fn, ...)
			local acquiredRunnerThread = freeRunnerThread
			freeRunnerThread = nil
			fn(...)
			-- The handler finished running, this runner thread is free again.
			freeRunnerThread = acquiredRunnerThread
		end

		-- Coroutine runner that we create coroutines of. The coroutine can be 
		-- repeatedly resumed with functions to run followed by the argument to run
		-- them with.
		local function runEventHandlerInFreeThread()
			-- Note: We cannot use the initial set of arguments passed to
			-- runEventHandlerInFreeThread for a call to the handler, because those
			-- arguments would stay on the stack for the duration of the thread's
			-- existence, temporarily leaking references. Without access to raw bytecode
			-- there's no way for us to clear the "..." references from the stack.
			while true do
				acquireRunnerThreadAndCallEventHandler(coroutine.yield())
			end
		end

		-- Connection class
		local Connection = {}
		Connection.__index = Connection

		function Connection.new(signal, fn)
			return setmetatable({
				_connected = true,
				_signal = signal,
				_fn = fn,
				_next = false,
			}, Connection)
		end

		function Connection:Disconnect()
			self._connected = false

			-- Unhook the node, but DON'T clear it. That way any fire calls that are
			-- currently sitting on this node will be able to iterate forwards off of
			-- it, but any subsequent fire calls will not hit it, and it will be GCed
			-- when no more fire calls are sitting on it.
			if self._signal._handlerListHead == self then
				self._signal._handlerListHead = self._next
			else
				local prev = self._signal._handlerListHead
				while prev and prev._next ~= self do
					prev = prev._next
				end
				if prev then
					prev._next = self._next
				end
			end
		end
		Connection.Destroy = Connection.Disconnect

		-- Make Connection strict
		setmetatable(Connection, {
			__index = function(tb, key)
				error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
			end,
			__newindex = function(tb, key, value)
				error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
			end
		})

		-- Signal class
		local Signal = {}
		Signal.__index = Signal

		function Signal.new()
			return setmetatable({
				_handlerListHead = false,
			}, Signal)
		end

		function Signal:Connect(fn)
			local connection = Connection.new(self, fn)
			if self._handlerListHead then
				connection._next = self._handlerListHead
				self._handlerListHead = connection
			else
				self._handlerListHead = connection
			end
			return connection
		end

		-- Disconnect all handlers. Since we use a linked list it suffices to clear the
		-- reference to the head handler.
		function Signal:DisconnectAll()
			self._handlerListHead = false
		end
		Signal.Destroy = Signal.DisconnectAll

		-- Signal:Fire(...) implemented by running the handler functions on the
		-- coRunnerThread, and any time the resulting thread yielded without returning
		-- to us, that means that it yielded to the Roblox scheduler and has been taken
		-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
		function Signal:Fire(...)
			local item = self._handlerListHead
			while item do
				if item._connected then
					if not freeRunnerThread then
						freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
						-- Get the freeRunnerThread to the first yield
						coroutine.resume(freeRunnerThread)
					end
					task.spawn(freeRunnerThread, item._fn, ...)
				end
				item = item._next
			end
		end

		-- Implement Signal:Wait() in terms of a temporary connection using
		-- a Signal:Connect() which disconnects itself.
		function Signal:Wait()
			local waitingCoroutine = coroutine.running()
			local cn;
			cn = self:Connect(function(...)
				cn:Disconnect()
				task.spawn(waitingCoroutine, ...)
			end)
			return coroutine.yield()
		end

		-- Implement Signal:Once() in terms of a connection which disconnects
		-- itself before running the handler.
		function Signal:Once(fn)
			local cn;
			cn = self:Connect(function(...)
				if cn._connected then
					cn:Disconnect()
				end
				fn(...)
			end)
			return cn
		end

		-- Make signal strict
		setmetatable(Signal, {
			__index = function(tb, key)
				error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
			end,
			__newindex = function(tb, key, value)
				error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
			end
		})

		return Signal
	end;
};
G2L_MODULES[G2L["1ab"]] = {
	Closure = function()
		local script = G2L["1ab"];--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
-------------------------------------
--]]



		-- Janitor
		-- Original by Validark
		-- Modifications by pobammer
		-- roblox-ts support by OverHash and Validark
		-- LinkToInstance fixed by Elttob.

		local RunService = game:GetService("RunService")
		local Heartbeat = RunService.Heartbeat
		local function getPromiseReference()
			if RunService:IsRunning() then
				local main = require(game:GetService("ReplicatedStorage").Framework)
				return main.modules.Promise
			end
		end

		local IndicesReference = newproxy(true)
		getmetatable(IndicesReference).__tostring = function()
			return "IndicesReference"
		end

		local LinkToInstanceIndex = newproxy(true)
		getmetatable(LinkToInstanceIndex).__tostring = function()
			return "LinkToInstanceIndex"
		end

		local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
		local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

		local Janitor = {
			IGNORE_MEMORY_DEBUG = true,
			ClassName = "Janitor";
			__index = {
				CurrentlyCleaning = true;
				[IndicesReference] = nil;
			};
		}

		local TypeDefaults = {
			["function"] = true;
			["Promise"] = "cancel";
			RBXScriptConnection = "Disconnect";
		}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
		function Janitor.new()
			return setmetatable({
				CurrentlyCleaning = false;
				[IndicesReference] = nil;
			}, Janitor)
		end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
		function Janitor.Is(Object)
			return type(Object) == "table" and getmetatable(Object) == Janitor
		end

		Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
		function Janitor.__index:Add(Object, MethodName, Index)
			if Index then
				self:Remove(Index)

				local This = self[IndicesReference]
				if not This then
					This = {}
					self[IndicesReference] = This
				end

				This[Index] = Object
			end

			local objectType = typeof(Object)
			if objectType == "table" and string.match(tostring(Object), "Promise") then
				objectType = "Promise"
				--local status = Object:getStatus()
				--print("status =", status, status == "Rejected")
			end
			MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
			if type(Object) ~= "function" and not Object[MethodName] then
				warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
			end

			local OriginalTraceback = debug.traceback("")
			self[Object] = {MethodName, OriginalTraceback}
			return Object
		end
		Janitor.__index.Give = Janitor.__index.Add

		-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
		function Janitor.__index:AddPromise(PromiseObject)
			local Promise = getPromiseReference()
			if Promise then
				if not Promise.is(PromiseObject) then
					error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
				end
				if PromiseObject:getStatus() == Promise.Status.Started then
					local Id = newproxy(false)
					local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
						if OnCancel(function()
								PromiseObject:cancel()
							end) then
							return
						end

						Resolve(PromiseObject)
					end), "cancel", Id)

					NewPromise:finallyCall(self.Remove, self, Id)
					return NewPromise
				else
					return PromiseObject
				end
			else
				return PromiseObject
			end
		end
		Janitor.__index.GivePromise = Janitor.__index.AddPromise

		-- This will assume whether or not the object is a Promise or a regular object.
		function Janitor.__index:AddObject(Object)
			local Id = newproxy(false)
			local Promise = getPromiseReference()
			if Promise and Promise.is(Object) then
				if Object:getStatus() == Promise.Status.Started then
					local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
					NewPromise:finallyCall(self.Remove, self, Id)
					return NewPromise, Id
				else
					return Object
				end
			else
				return self:Add(Object, false, Id), Id
			end
		end

		Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
		function Janitor.__index:Remove(Index)
			local This = self[IndicesReference]
			if This then
				local Object = This[Index]

				if Object then
					local ObjectDetail = self[Object]
					local MethodName = ObjectDetail and ObjectDetail[1]

					if MethodName then
						if MethodName == true then
							Object()
						else
							local ObjectMethod = Object[MethodName]
							if ObjectMethod then
								ObjectMethod(Object)
							end
						end

						self[Object] = nil
					end

					This[Index] = nil
				end
			end

			return self
		end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
		function Janitor.__index:Get(Index)
			local This = self[IndicesReference]
			if This then
				return This[Index]
			end
		end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
		function Janitor.__index:Cleanup()
			if not self.CurrentlyCleaning then
				self.CurrentlyCleaning = nil
				for Object, ObjectDetail in next, self do
					if Object == IndicesReference then
						continue
					end

					-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
					local TypeOf = type(Object)
					if TypeOf == "string" or TypeOf == "number" then
						self[Object] = nil
						continue
					end

					local MethodName = ObjectDetail[1]
					local OriginalTraceback = ObjectDetail[2]
					local function warnUser(warning)
						local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
						local addedLine = OriginalTraceback
						warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
					end
					if MethodName == true then
						local success, warning = pcall(Object)
						if not success then
							warnUser(warning)
						end
					else
						local ObjectMethod = Object[MethodName]
						if ObjectMethod then
							local success, warning = pcall(ObjectMethod, Object)
							local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
							if not success and not isAnInstanceBeingDestroyed then
								warnUser(warning)
							end
						end
					end

					self[Object] = nil
				end

				local This = self[IndicesReference]
				if This then
					for Index in next, This do
						This[Index] = nil
					end

					self[IndicesReference] = {}
				end

				self.CurrentlyCleaning = false
			end
		end

		Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
		function Janitor.__index:Destroy()
			self:Cleanup()
			--table.clear(self)
			--setmetatable(self, nil)
		end

		Janitor.__call = Janitor.__index.Cleanup

		--- Makes the Janitor clean up when the instance is destroyed
		-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
		-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
		-- @author Corecii
		local Disconnect = {Connected = true}
		Disconnect.__index = Disconnect
		function Disconnect:Disconnect()
			if self.Connected then
				self.Connected = false
				self.Connection:Disconnect()
			end
		end

		function Disconnect:__tostring()
			return "Disconnect<" .. tostring(self.Connected) .. ">"
		end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
		function Janitor.__index:LinkToInstance(Object, AllowMultiple)
			local Connection
			local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
			local IsNilParented = Object.Parent == nil
			local ManualDisconnect = setmetatable({}, Disconnect)

			local function ChangedFunction(_DoNotUse, NewParent)
				if ManualDisconnect.Connected then
					_DoNotUse = nil
					IsNilParented = NewParent == nil

					if IsNilParented then
						coroutine.wrap(function()
							Heartbeat:Wait()
							if not ManualDisconnect.Connected then
								return
							elseif not Connection.Connected then
								self:Cleanup()
							else
								while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
									Heartbeat:Wait()
								end

								if ManualDisconnect.Connected and IsNilParented then
									self:Cleanup()
								end
							end
						end)()
					end
				end
			end

			Connection = Object.AncestryChanged:Connect(ChangedFunction)
			ManualDisconnect.Connection = Connection

			if IsNilParented then
				ChangedFunction(nil, Object.Parent)
			end

			Object = nil
			return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
		end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
		function Janitor.__index:LinkToInstances(...)
			local ManualCleanup = Janitor.new()
			for _, Object in ipairs({...}) do
				ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
			end

			return ManualCleanup
		end

		for FunctionName, Function in next, Janitor.__index do
			local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
			Janitor.__index[NewFunctionName] = Function
		end

		return Janitor
	end;
};
-- StarterGui.SSWorks.Main.Topbar.ImageButton.LocalScript
local function C_1b()
	local script = G2L["1b"];
	local Value = script.Parent.Parent.Parent.Parent.isOpen
	local TS = game:GetService('TweenService')

	script.Parent.Activated:Connect(function()
		TS:Create(script.Parent.Parent.Parent.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 1}):Play()
		wait(.4)
		script.Parent.Parent.Parent.Parent.Main.Visible = false
		Value.Value = false
	end)
end;
task.spawn(C_1b);
-- StarterGui.SSWorks.Main.KeySystem.Manager
local function C_29()
	local script = G2L["29"];
	local NotifyAPI = require(script.Parent.Parent.Parent.Modules.NotificationAPI)
	local Box = script.Parent.InputBox
	local Submit = script.Parent.TextButton
	local KSAPI = require(script.Parent.Parent.Parent.Modules.KeyAPI)

	Submit.Activated:Connect(function()
		-- Get the user input from the InputBox and check it using Post
		KSAPI:Post(Box.Text)

		-- Wait 1 second (simulate delay)
		task.wait(1)

		-- Retrieve the response from the API module
		local GetMethod = KSAPI:Get()

		-- If the key is correct, display a notification
		if GetMethod == true then
			NotifyAPI:Create('Key', "The Key is correct", 3)
			script.Parent.Visible = false
		else
			NotifyAPI:Create('Key', "The Key is incorrect", 3) -- Add feedback for incorrect key
		end
	end)

end;
task.spawn(C_29);
-- StarterGui.SSWorks.Main.KeySystem.UpdLogBtn.LocalScript
local function C_2d()
	local script = G2L["2d"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Parent.UpdateLogs.Visible = true
	end)
end;
task.spawn(C_2d);
-- StarterGui.SSWorks.Main.Menu.Button.ExecButton.LocalScript
local function C_35()
	local script = G2L["35"];
	local TS = game:GetService('TweenService')
	local Indicator = script.Parent.Indicator
	local ContentProvider = script.Parent.Parent.Parent.Parent.ContentProvider

	script.Parent.Activated:Connect(function()
		for _,v in pairs(ContentProvider:GetChildren()) do
			if v:IsA('Frame') then
				v.Visible = false
				ContentProvider:FindFirstChild("Executor").Visible = true
			end
		end

		for _,v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('ImageButton') then
				TS:Create(v.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 1}):Play()
			end
		end

		TS:Create(script.Parent.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 0}):Play()
	end)
end;
task.spawn(C_35);
-- StarterGui.SSWorks.Main.Menu.Button.ScriptButton.LocalScript
local function C_3a()
	local script = G2L["3a"];
	local TS = game:GetService('TweenService')
	local Indicator = script.Parent.Indicator
	local ContentProvider = script.Parent.Parent.Parent.Parent.ContentProvider

	script.Parent.Activated:Connect(function()
		for _,v in pairs(ContentProvider:GetChildren()) do
			if v:IsA('Frame') then
				v.Visible = false
				ContentProvider:FindFirstChild("ScriptHub").Visible = true
			end
		end

		for _,v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('ImageButton') then
				TS:Create(v.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 1}):Play()
			end
		end

		TS:Create(script.Parent.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 0}):Play()
	end)
end;
task.spawn(C_3a);
-- StarterGui.SSWorks.Main.Menu.Button.SettingButton.LocalScript
local function C_3f()
	local script = G2L["3f"];
	local TS = game:GetService('TweenService')
	local Indicator = script.Parent.Indicator
	local ContentProvider = script.Parent.Parent.Parent.Parent.ContentProvider

	script.Parent.Activated:Connect(function()
		for _,v in pairs(ContentProvider:GetChildren()) do
			if v:IsA('Frame') then
				v.Visible = false
				ContentProvider:FindFirstChild("Settings").Visible = true
			end
		end

		for _,v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('ImageButton') then
				TS:Create(v.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 1}):Play()
			end
		end

		TS:Create(script.Parent.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 0}):Play()
	end)
end;
task.spawn(C_3f);
-- StarterGui.SSWorks.Main.Menu.Button.ExternalButton.LocalScript
local function C_44()
	local script = G2L["44"];
	local TS = game:GetService('TweenService')
	local Indicator = script.Parent.Indicator
	local ContentProvider = script.Parent.Parent.Parent.Parent.ContentProvider

	script.Parent.Activated:Connect(function()
		for _,v in pairs(ContentProvider:GetChildren()) do
			if v:IsA('Frame') then
				v.Visible = false
				ContentProvider:FindFirstChild("External").Visible = true
			end
		end

		for _,v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('ImageButton') then
				TS:Create(v.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 1}):Play()
			end
		end

		TS:Create(script.Parent.Indicator, TweenInfo.new(.4), {BackgroundTransparency = 0}):Play()
	end)
end;
task.spawn(C_44);
-- StarterGui.SSWorks.Main.SmoothDrag
local function C_45()
	local script = G2L["45"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));

	local gui = script.Parent

	local dragging
	local dragInput
	local dragStart
	local startPos

	function Lerp(a, b, m)
		return a + (b - a) * m
	end;

	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;

		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_45);
-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Vote.LocalScript
local function C_5d()
	local script = G2L["5d"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Exclude.UIStroke.Transparency = 1
		script.Parent.UIStroke.Transparency = 0
	end)
end;
task.spawn(C_5d);
-- StarterGui.SSWorks.Main.UpdateLogs.Poll.Exclude.LocalScript
local function C_63()
	local script = G2L["63"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Vote.UIStroke.Transparency = 1
		script.Parent.UIStroke.Transparency = 0
	end)
end;
task.spawn(C_63);
-- StarterGui.SSWorks.Main.UpdateLogs.ImageButton.LocalScript
local function C_65()
	local script = G2L["65"];
	script.Parent.Activated:Connect(function()
		if script.Parent.Parent.Parent.Parent.Configurations.Key.Value ~= "" then
			script.Parent.Parent.Visible = false
		else
			script.Parent.Parent.Visible = false
			if game:GetService('Players').LocalPlayer.Name == "OldestRaidAccount" then
				script.Parent.Parent.Parent.KeySystem.Visible = false
			else
				script.Parent.Parent.Parent.KeySystem.Visible = true
			end
		end
	end)
end;
task.spawn(C_65);
-- StarterGui.SSWorks.Main.ContentProvider.Executor.AI.Input.Manager
local function C_76()
	local script = G2L["76"];
	local AIModule = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Modules.AIModule)
	local NotifyModule = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TextBox = script.Parent.TextBox
	local Button = script.Parent.ImageButton

	function Activate()
		if TextBox.Text ~= nil then
			task.spawn(function()
				AIModule:Send(TextBox.Text)
			end)
			TextBox.Text = ""
		else
			NotifyModule:Create("AI", "Could get nil as an response", 5)
		end
	end

	TextBox.FocusLost:Connect(Activate)
	Button.Activated:Connect(Activate)
end;
task.spawn(C_76);
-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Execute.LocalScript
local function C_7a()
	local script = G2L["7a"];
	local textBox = script.Parent.Parent.Parent.CurrentTab

	script.Parent.Activated:Connect(function()
		loadstring(textBox.Value.Text)()
	end)
end;
task.spawn(C_7a);
-- StarterGui.SSWorks.Main.ContentProvider.Executor.Options.Clear.LocalScript
local function C_7c()
	local script = G2L["7c"];
	local textBox = script.Parent.Parent.Parent.CurrentTab

	script.Parent.Activated:Connect(function()
		textBox.Value.Text = ""
	end)
end;
task.spawn(C_7c);
-- StarterGui.SSWorks.Main.ContentProvider.Executor.Tabs.TabManager
local function C_83()
	local script = G2L["83"];
	local TabCount = 0
	local Tabs = script.Parent
	local TabsHolder = script.Parent.Parent.TabHolder
	local currentActiveTab = script.Parent.Parent.CurrentTab  -- Start with no active tab initially
	local PreviousTab = nil

	-- Create a new tab
	function createTab()
		TabCount += 1

		-- Clone the tab template and set its properties
		local CloneTabTemplate = script.Tab0:Clone()
		CloneTabTemplate.TextLabel.Text = "Tab #" .. TabCount
		CloneTabTemplate.Name = "Tab" .. TabCount

		-- Clone the content tab and set its properties
		local ClonedTextTab = TabsHolder.Tab0:Clone()
		ClonedTextTab.Name = "TabContent" .. TabCount
		ClonedTextTab.Visible = false -- Initially hidden
		ClonedTextTab.Parent = TabsHolder -- Add to the TabsHolder

		-- Connect the Close button to remove the tab
		CloneTabTemplate.Close.Activated:Connect(function()
			removeTab(CloneTabTemplate, ClonedTextTab)
		end)

		-- Connect the TextButton to select this tab
		CloneTabTemplate.TextButton.Activated:Connect(function()
			selectTab(ClonedTextTab)
		end)

		-- Add the newly created tab to the Tabs frame
		CloneTabTemplate.Parent = Tabs

		-- Automatically select the newly created tab
		selectTab(ClonedTextTab)
	end

	-- Select a tab and show its content
	function selectTab(tabToSelect)
		-- Hide all other tabs' content
		for _, v in pairs(TabsHolder:GetChildren()) do
			if v:IsA("TextBox") then  -- Ensure you're hiding only Frames (Tab content)
				v.Visible = false
			end
		end

		-- Set the new active tab and show its content
		if currentActiveTab.Value then
			PreviousTab = currentActiveTab.Value -- Store the current tab as the previous one
		end
		currentActiveTab.Value = tabToSelect
		currentActiveTab.Value.Visible = true
	end

	-- Remove a tab and handle active tab switching
	function removeTab(tabButton, tabContent)
		-- Destroy the tab button and content
		tabButton:Destroy()
		tabContent:Destroy()

		TabCount -= 1 -- Update the tab count

		-- Handle switching to another tab (either previous or the first one)
		if TabCount > 0 then
			if PreviousTab and PreviousTab.Parent then
				selectTab(PreviousTab)  -- Select the previous tab if it exists and hasn't been removed
			else
				-- If no previous tab or it's removed, select the first available tab
				local firstTab = TabsHolder:FindFirstChild("TabContent1")
				if firstTab then
					selectTab(firstTab)
				else
					currentActiveTab.Value = nil -- No active tab if none left
				end
			end
		else
			currentActiveTab.Value = nil -- Reset the active tab if no tabs are left
		end
	end

	-- Create the initial tab when the script runs
	createTab()

	-- Connect the "Add Tab" button to create new tabs
	script.Parent.Parent.Options.Tab.Activated:Connect(createTab)
end;
task.spawn(C_83);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Manager
local function C_90()
	local script = G2L["90"];
	local searchBar = script.Parent.Box.TextBox
	local items = script.Parent.Value.Value.ScrollingFrame

	function updateResults()
		local search = string.lower(searchBar.Text)
		for i,v in pairs(items:GetChildren()) do
			if v:IsA("Frame") then
				if search ~= "" then
					local item = string.lower(v.Title.Text)
					if string.find(item, search) then
						v.Visible = true
					else
						v.Visible = false
					end
				else
					v.Visible = true
				end
			end
		end
	end

	game:GetService('UserInputService').InputBegan:Connect(function(input, isTyping)
		if isTyping then return end

		if input.KeyCode == Enum.KeyCode.Z then
			if searchBar.Text ~= "" then
				updateResults()
			end
		end
	end)

	searchBar.Changed:Connect(updateResults)
end;
task.spawn(C_90);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.controlPage.PagesManager
local function C_9e()
	local script = G2L["9e"];
	local IncreaseButton = script.Parent.IncreasePage.ImageButton
	local DecreaseButton = script.Parent.DecreasePage.ImageButton
	local PageCountDisplay = script.Parent.PageCount.TextLabel
	local PagesFolder = script.Parent.Parent.Pages
	local PageCount = #PagesFolder:GetChildren()
	local Count = 1

	local NotifyModule = require(script.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)

	function updateCount()
		PageCountDisplay.Text = Count.." / "..PageCount
	end

	function pageVisibility()
		-- Set all pages to invisible
		for _,v in pairs(PagesFolder:GetChildren()) do
			v.Visible = false
		end

		-- Show the correct page based on Count
		local currentPage = PagesFolder:FindFirstChild('Page' .. Count)
		if currentPage then
			currentPage.Visible = true
			script.Parent.Parent.Value.Value = currentPage
		end
	end

	IncreaseButton.Activated:Connect(function()
		-- Increment Count but ensure it doesn't exceed PageCount
		if Count < PageCount then
			Count += 1
		end
		updateCount()
		pageVisibility()
	end)

	DecreaseButton.Activated:Connect(function()
		-- Decrement Count but ensure it doesn't go below 1
		if Count > 1 then
			Count -= 1
		end
		updateCount()
		pageVisibility()
	end)

	-- Initial setup
	updateCount()
	pageVisibility()

end;
task.spawn(C_9e);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_ab()
	local script = G2L["ab"];
	script.Parent.Activated:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
end;
task.spawn(C_ab);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_b9()
	local script = G2L["b9"];
	script.Parent.Activated:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
end;
task.spawn(C_b9);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_c7()
	local script = G2L["c7"];
	script.Parent.Activated:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
end;
task.spawn(C_c7);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page1.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_d5()
	local script = G2L["d5"];
	script.Parent.Activated:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
end;
task.spawn(C_d5);
-- StarterGui.SSWorks.Main.ContentProvider.ScriptHub.Pages.Page2.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_e5()
	local script = G2L["e5"];
	script.Parent.Activated:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
end;
task.spawn(C_e5);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.TextButton.LocalScript
local function C_f4()
	local script = G2L["f4"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TS = game:GetService('TweenService')
	local isOn = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn
		if isOn == true then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			script.Parent.Parent.SelectedValue.Changed:Connect(function()
				if script.Parent.Parent.SelectedValue.Value == "Red" then
					script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(255, 117, 117)
				elseif script.Parent.Parent.SelectedValue.Value == "Cyan" then
					script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(35, 237, 255)
				elseif script.Parent.Parent.SelectedValue.Value == "Blue" then
					script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(39, 122, 255)
				elseif script.Parent.Parent.SelectedValue.Value == "Default" then
					script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(255, 255, 255)
				else
					script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(script.Parent.Parent.SelectedValue.Value, script.Parent.Parent.SelectedValue.Value, script.Parent.Parent.SelectedValue.Value)
				end
			end)
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			script.Parent.Parent.Parent.Parent.Parent.Parent.GroupColor3 = Color3.fromRGB(255, 255, 255)
		end
	end)
end;
task.spawn(C_f4);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
local function C_fb()
	local script = G2L["fb"];
	local isChosen = false

	script.Parent.Activated:Connect(function()
		-- Toggle the selected state
		isChosen = not isChosen

		-- Loop through all GUI buttons in the same parent to reset their colors
		for _, v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('GuiButton') then
				v.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Reset color of all buttons
			end
		end

		if isChosen then
			-- Change background color of the selected button and set SelectedValue
			script.Parent.BackgroundColor3 = Color3.fromRGB(29, 61, 109)
			script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
		else
			-- If not chosen, reset to default state
			script.Parent.Parent.Parent.SelectedValue.Value = "Default"
			script.Parent.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			isChosen = false
		end
	end)

end;
task.spawn(C_fb);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
local function C_ff()
	local script = G2L["ff"];
	local isChosen = false

	script.Parent.Activated:Connect(function()
		-- Toggle the selected state
		isChosen = not isChosen

		-- Loop through all GUI buttons in the same parent to reset their colors
		for _, v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('GuiButton') then
				v.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Reset color of all buttons
			end
		end

		if isChosen then
			-- Change background color of the selected button and set SelectedValue
			script.Parent.BackgroundColor3 = Color3.fromRGB(29, 61, 109)
			script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
		else
			-- If not chosen, reset to default state
			script.Parent.Parent.Parent.SelectedValue.Value = "Default"
			script.Parent.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			isChosen = false
		end
	end)

end;
task.spawn(C_ff);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
local function C_102()
	local script = G2L["102"];
	local isChosen = false

	script.Parent.Activated:Connect(function()
		-- Toggle the selected state
		isChosen = not isChosen

		-- Loop through all GUI buttons in the same parent to reset their colors
		for _, v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('GuiButton') then
				v.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Reset color of all buttons
			end
		end

		if isChosen then
			-- Change background color of the selected button and set SelectedValue
			script.Parent.BackgroundColor3 = Color3.fromRGB(29, 61, 109)
			script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
		else
			-- If not chosen, reset to default state
			script.Parent.Parent.Parent.SelectedValue.Value = "Default"
			script.Parent.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			isChosen = false
		end
	end)

end;
task.spawn(C_102);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.TextBox.LocalScript
local function C_105()
	local script = G2L["105"];
	script.Parent.FocusLost:Connect(function()
		script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
	end)
end;
task.spawn(C_105);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_108()
	local script = G2L["108"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Dropdown.Visible = not script.Parent.Parent.Dropdown.Visible
		if script.Parent.Parent.Dropdown.ZIndex == 1 then
			script.Parent.Parent.Dropdown.ZIndex = 0
		else
			script.Parent.Parent.Dropdown.ZIndex = 1
		end
	end)
end;
task.spawn(C_108);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
local function C_117()
	local script = G2L["117"];
	local Config = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Configurations

	script.Parent.FocusLost:Connect(function()
		Config["AimAssistSmoothness"].Value = script.Parent.Text
	end)
end;
task.spawn(C_117);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
local function C_11d()
	local script = G2L["11d"];
	local Config = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Configurations

	script.Parent.FocusLost:Connect(function()
		Config["AimAssistPart"].Value = script.Parent.Text
	end)
end;
task.spawn(C_11d);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
local function C_123()
	local script = G2L["123"];
	local AimAssistColor = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.AimAssistFrame

	script.Parent.FocusLost:Connect(function()
		if script.Parent.Text == "Red" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(255, 139, 139)
		elseif script.Parent.Text == "Blue" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(49, 159, 255)
		elseif script.Parent.Text == "Green" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(86, 255, 67)	
		elseif script.Parent.Text == "Purple" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(152, 61, 255)	
		elseif script.Parent.Text == "Black" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(0, 0, 0)	
		elseif script.Parent.Text == "Default" then
			AimAssistColor.UIStroke.Color = Color3.fromRGB(255, 255, 255)	
		end
	end)
end;
task.spawn(C_123);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
local function C_129()
	local script = G2L["129"];
	local Config = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Configurations

	script.Parent.FocusLost:Connect(function()
		if script.Parent.Text == "Hold" then
			Config["AATrigger"].Value = "Hold"
		elseif script.Parent.Text == "Activate" then
			Config["AATrigger"].Value = "Activate"
		else
			script.Parent.Text = "Response invalid!"
			script.Parent.TextColor3 = Color3.fromRGB(255, 228, 21)
			task.wait(2)
			script.Parent.Text = ""
			script.Parent.TextColor3 = Color3.fromRGB(255, 255, 255)
		end
	end)
end;
task.spawn(C_129);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.ScrollingFrame.Frame.TextBox.LocalScript
local function C_12f()
	local script = G2L["12f"];
	local Config = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Configurations

	script.Parent.FocusLost:Connect(function()
		if script.Parent.Text == "MouseButton1" then
			Config["AAKeyHoldMethod"].Value = "MouseButton1"
		elseif script.Parent.Text == "MouseButton2" then
			Config["AAKeyHoldMethod"].Value = "MouseButton2"
		else
			script.Parent.Text = "Response invalid!"
			script.Parent.TextColor3 = Color3.fromRGB(255, 228, 21)
			task.wait(2)
			script.Parent.Text = ""
			script.Parent.TextColor3 = Color3.fromRGB(255, 255, 255)
		end
	end)
end;
task.spawn(C_12f);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_133()
	local script = G2L["133"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Dropdown.Visible = not script.Parent.Parent.Dropdown.Visible
		if script.Parent.Parent.ZIndex ~= 2 then
			script.Parent.Parent.ZIndex = 2
		else
			script.Parent.Parent.ZIndex = 1
		end
	end)
end;
task.spawn(C_133);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.LocalScript
local function C_13f()
	local script = G2L["13f"];
	local isChosen = false
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)

	script.Parent.Activated:Connect(function()
		NotifyService:Create('Key Configuration', "Prompt was shown.", 3)
		script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.KeyConfig.ChangeKey.Visible = true
	end)
end;
task.spawn(C_13f);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.Dropdown.Frame.TextButton.LocalScript
local function C_146()
	local script = G2L["146"];
	local isChosen = false
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local Players = game:GetService("Players")
	local MarketplaceService = game:GetService("MarketplaceService")
	local TeleportService = game:GetService("TeleportService")
	local isAvalible = false

	script.Parent.Activated:Connect(function()
		if isAvalible then
			-- Show the notification
			NotifyService:Create('Buy Premium', "Prompt was shown.", 3)

			-- Check if player is in the specific game place
			if game.PlaceId == 107008868220828 then
				-- Prompt Game Pass purchase for the player
				isChosen = true
				MarketplaceService:PromptGamePassPurchase(Players.LocalPlayer, 949226715)
				NotifyService:Create('Buy Premium (IMPORTANT)', "After purchase, rejoin the game or re-activate the utility", 8)
			else
				-- Teleport player to the target place
				isChosen = true
				local success, err = pcall(function()
					TeleportService:TeleportAsync(107008868220828, {Players.LocalPlayer})
				end)

				if not success then
					-- Optional: handle teleportation failure
					NotifyService:Create('Error', err, 5)
				end
			end
		else
			NotifyService:Create("Premium", "Feature is currently in development", 3)
		end
	end)

end;
task.spawn(C_146);
-- StarterGui.SSWorks.Main.ContentProvider.Settings.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_14a()
	local script = G2L["14a"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Dropdown.Visible = not script.Parent.Parent.Dropdown.Visible
		if script.Parent.Parent.ZIndex ~= 2 then
			script.Parent.Parent.ZIndex = 2
		else
			script.Parent.Parent.ZIndex = 1
		end
	end)
end;
task.spawn(C_14a);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_154()
	local script = G2L["154"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TS = game:GetService('TweenService')
	local isOn = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn
		if isOn == true then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "Noclip was triggered", 3)
			for _,v in pairs(game:GetService('Players'):GetChildren()) do
				for _, part in pairs(v:GetChildren()) do
					if part:IsA('BasePart') then
						part.CanCollide = false
					end
				end
			end
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			for _,v in pairs(game:GetService('Players'):GetChildren()) do
				for _, part in pairs(v:GetChildren()) do
					if part:IsA('BasePart') then
						part.CanCollide = true
						game:GetService('Players').LocalPlayer.Character:WaitForChild('HumanoidRootPart').CanCollide = false
					end
				end
			end
		end
	end)
end;
task.spawn(C_154);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_15b()
	local script = G2L["15b"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TS = game:GetService('TweenService')
	local isOn = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn
		if isOn == true then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "Status UI was triggered", 3)
			script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.FPlayerUI.Visible = true
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.FPlayerUI.Visible = false
		end
	end)
end;
task.spawn(C_15b);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_162()
	local script = G2L["162"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local BypassService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.BModule)
	local TS = game:GetService('TweenService')
	local isOn = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn
		if isOn == true then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "BBypass was triggered", 3)
			BypassService:Bypass()
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
		end
	end)
end;
task.spawn(C_162);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_169()
	local script = G2L["169"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local BypassService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.BModule)
	local TS = game:GetService('TweenService')
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")

	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	-- Configuration variables
	local Config = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Configurations
	local ActivationMethod = Config.AATrigger
	local AAKeyHoldMethod = Config.AAKeyHoldMethod
	local aimAssistSmoothness = Config.AimAssistSmoothness.Value  -- Speed of aim adjustment
	local targetPart = Config.AimAssistPart.Value        -- Part of the enemy to aim at
	local aimUI = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.AimAssistFrame  -- UI frame (crosshair/reticle)
	local isHold = false

	local isOn = false
	local currentTarget = nil  -- Variable to keep track of the current target

	-- Update aim assist configurations based on the Config values
	RunService.Heartbeat:Connect(function()
		aimAssistSmoothness = Config.AimAssistSmoothness.Value
		targetPart = Config.AimAssistPart.Value
	end)

	-- Function to check if a world position is within the aim UI
	local function isInAimUI(worldPosition)
		local screenPoint, onScreen = camera:WorldToViewportPoint(worldPosition)

		if onScreen then
			local uiPosition = aimUI.AbsolutePosition
			local uiSize = aimUI.AbsoluteSize

			-- Check if the screen point falls inside the aim UI
			return screenPoint.X > uiPosition.X and screenPoint.X < (uiPosition.X + uiSize.X) and
				screenPoint.Y > uiPosition.Y and screenPoint.Y < (uiPosition.Y + uiSize.Y)
		end
		return false
	end

	-- Function to find the closest enemy that is valid for targeting
	local function findTargetInAimUI()
		local closestTarget = nil
		local closestDistance = math.huge  -- Start with a large distance

		for _, targetPlayer in pairs(Players:GetPlayers()) do
			if targetPlayer ~= player then
				local character = targetPlayer.Character
				if character then
					local humanoidRootPart = character:FindFirstChild(targetPart)

					if humanoidRootPart and isInAimUI(humanoidRootPart.Position) then
						local distance = (humanoidRootPart.Position - camera.CFrame.Position).Magnitude

						-- Determine the closest target
						if distance < closestDistance then
							closestDistance = distance
							closestTarget = humanoidRootPart
						end
					end
				end
			end
		end
		return closestTarget
	end

	-- Function to aim at the current target
	local function aimAtTarget(target)
		if target then
			local targetPosition = target.Position + Vector3.new(0, 0, 0)  -- Adjust aim to be slightly above
			local direction = (targetPosition - camera.CFrame.Position).unit
			local targetCFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + direction)

			-- Smoothly adjust the aim toward the enemy
			camera.CFrame = camera.CFrame:Lerp(targetCFrame, aimAssistSmoothness)
		end
	end

	script.Parent.Activated:Connect(function()
		isOn = not isOn

		if isOn then
			TS:Create(script.Parent, TweenInfo.new(0.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "AimAssist was triggered", 3)
			aimUI.Visible = true

			-- Continuously update the target and aim
			RunService.Heartbeat:Connect(function()
				if ActivationMethod.Value == "Activate" then
					if isOn then
						-- Find a new target
						local newTarget = findTargetInAimUI()

						-- Reset currentTarget if the new target is nil
						if not newTarget then
							currentTarget = nil
						else
							-- Update currentTarget if it has changed
							if newTarget ~= currentTarget then
								currentTarget = newTarget  -- Update the current target
							end
						end

						-- Aim at the current target if it exists
						if currentTarget then
							local getT = Players:GetPlayerFromCharacter(currentTarget.Parent)
							if getT.Team == player.Team then
								local TeamCount = #game:GetService('Teams'):GetChildren()
								if TeamCount <= 1 or TeamCount <= 2 then
									aimAtTarget(currentTarget)
								end
							else
								aimAtTarget(currentTarget)
							end
						end
					end
				elseif ActivationMethod.Value == "Hold" then
					if isHold then
						-- Find a new target
						local newTarget = findTargetInAimUI()

						-- Reset currentTarget if the new target is nil
						if not newTarget then
							currentTarget = nil
						else
							-- Update currentTarget if it has changed
							if newTarget ~= currentTarget then
								currentTarget = newTarget  -- Update the current target
							end
						end

						-- Aim at the current target if it exists
						if currentTarget then
							local getT = Players:GetPlayerFromCharacter(currentTarget.Parent)
							if getT.Team == player.Team then
								local TeamCount = #game:GetService('Teams'):GetChildren()
								if TeamCount <= 1 or TeamCount <= 2 then
									aimAtTarget(currentTarget)
								end
							else
								aimAtTarget(currentTarget)
							end
						end
					else
						aimAtTarget(nil)
					end
				end
			end)
		else
			TS:Create(script.Parent, TweenInfo.new(0.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			aimUI.Visible = false
			currentTarget = nil  -- Reset the current target when disabled
		end
	end)

	local UserInputService = game:GetService('UserInputService')

	UserInputService.InputBegan:Connect(function(input)
		if AAKeyHoldMethod.Value == "MouseButton1" then
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				isHold = true
			end
		elseif AAKeyHoldMethod.Value == "MouseButton2" then
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				isHold = true
			end
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		if AAKeyHoldMethod.Value == "MouseButton1" then
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				isHold = false
			end
		elseif AAKeyHoldMethod.Value == "MouseButton2" then
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				isHold = false
			end
		end
	end)

end;
task.spawn(C_169);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_170()
	local script = G2L["170"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local ESP = script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Resources.ESP
	local TS = game:GetService('TweenService')
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")

	local isOn = false
	local espConnection

	-- Function to toggle ESP for all players
	local function toggleESP(state)
		for _, player in pairs(Players:GetPlayers()) do
			if player.Character then
				local espInstance = player.Character:FindFirstChild("ESP")

				if state then
					-- Add ESP if it doesn't exist
					if not espInstance then
						ESP:Clone().Parent = player.Character
					end
				else
					-- Remove ESP if it exists
					if espInstance then
						espInstance:Destroy()
					end
				end
			end
		end
	end

	-- Heartbeat connection, only set once
	espConnection = RunService.Heartbeat:Connect(function()
		if isOn then
			toggleESP(true)
		end
	end)

	-- Button activation logic
	script.Parent.Activated:Connect(function()
		isOn = not isOn

		-- Tween effect for button color
		if isOn then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "ESP was triggered", 3)
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			toggleESP(false) -- Remove ESP from all players when turned off
		end
	end)

end;
task.spawn(C_170);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_177()
	local script = G2L["177"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TS = game:GetService('TweenService')
	local isOn = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn
		if isOn == true then
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()
			NotifyService:Create('External', "XRay was triggered", 3)
			for _, v in pairs(game:GetService('Workspace'):GetDescendants()) do
				-- Check if it's a BasePart and not inside an Accessory or HumanoidRootPart
				if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and not v:IsDescendantOf(game:GetService("Players")) then
					local parentAccessory = v:FindFirstAncestorWhichIsA('Accessory')
					if not parentAccessory then
						v.Transparency = 0.5
					end
				end
			end
			for _, plrs in pairs(game:GetService("Players"):GetPlayers()) do
				if plrs.Character then
					for _, chars in pairs(plrs.Character:GetChildren()) do
						if chars:IsA("BasePart") and chars.Name ~= "HumanoidRootPart" then
							chars.Transparency = 0
						end
					end
				end
			end
		else
			TS:Create(script.Parent, TweenInfo.new(.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
			for _, v in pairs(game:GetService('Workspace'):GetDescendants()) do
				-- Reset the transparency for all BasePart objects except HumanoidRootPart
				if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and not v:IsDescendantOf(game:GetService("Players")) then
					local parentAccessory = v:FindFirstAncestorWhichIsA('Accessory')
					if not parentAccessory then
						v.Transparency = 0
					end
				end
			end
			for _, plrs in pairs(game:GetService("Players"):GetPlayers()) do
				if plrs.Character then
					for _, chars in pairs(plrs.Character:GetChildren()) do
						if chars:IsA("BasePart") and chars.Name ~= "HumanoidRootPart" then
							chars.Transparency = 0
						end
					end
				end
			end
		end
	end)

end;
task.spawn(C_177);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.TextButton.LocalScript
local function C_17e()
	local script = G2L["17e"];
	local NotifyService = require(script.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Modules.NotificationAPI)
	local TS = game:GetService('TweenService')
	local Players = game:GetService('Players')
	local RunService = game:GetService("RunService")
	local isOn = false
	local isWalking = false

	script.Parent.Activated:Connect(function()
		isOn = not isOn

		local localPlayer = Players.LocalPlayer
		local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
		local humanoid = character:WaitForChild('Humanoid')

		if isOn then
			-- Change the button color when activated
			TS:Create(script.Parent, TweenInfo.new(0.5), {BackgroundColor3 = Color3.fromRGB(51, 160, 255)}):Play()

			-- Move logic based on selected value
			local function updateMovement()
				local selectedValue = script.Parent.Parent.SelectedValue.Value
				local speed = tonumber(script.Parent.Parent.TextBox.Text) or 16 -- Fallback to default speed

				local delta = RunService.Heartbeat:Wait() -- Get delta once for this update

				if selectedValue == "Normal" then
					humanoid.WalkSpeed = speed
				elseif selectedValue == "CFrame" then
					if humanoid.MoveDirection.Magnitude > 0 then
						isWalking = true
					else
						isWalking = true
					end
					game["Run Service"].Heartbeat:Connect(function()
						if isWalking then
							character:TranslateBy(humanoid.MoveDirection * speed * delta * 5)
						else
							character:TranslateBy(humanoid.MoveDirection * 1 * delta * 5)
						end
					end)
				end
			end

			-- Connect to SelectedValue changed event to update movement
			script.Parent.Parent.SelectedValue.Changed:Connect(updateMovement)

			-- Call immediately to set initial movement based on selected value
			updateMovement()
		else
			-- Revert the button color when deactivated
			TS:Create(script.Parent, TweenInfo.new(0.5), {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()

			-- Reset speed when deactivated
			local selectedValue = script.Parent.Parent.SelectedValue.Value

			if selectedValue == "Normal" then
				humanoid.WalkSpeed = 16
			elseif selectedValue == "CFrame" then
				if humanoid.MoveDirection.Magnitude > 0 then
					local delta = RunService.Heartbeat:Wait() -- Get delta again for consistent movement
					character:TranslateBy(humanoid.MoveDirection * delta * 0)
				end
			end
		end
	end)

end;
task.spawn(C_17e);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
local function C_185()
	local script = G2L["185"];
	local isChosen = false

	script.Parent.Activated:Connect(function()
		-- Toggle the selected state
		isChosen = not isChosen

		-- Loop through all GUI buttons in the same parent to reset their colors
		for _, v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('GuiButton') then
				v.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Reset color of all buttons
			end
		end

		if isChosen then
			-- Change background color of the selected button and set SelectedValue
			script.Parent.BackgroundColor3 = Color3.fromRGB(29, 61, 109)
			script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
		else
			-- If not chosen, reset to default state
			script.Parent.Parent.Parent.SelectedValue.Value = "Default"
			script.Parent.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			isChosen = false
		end
	end)

end;
task.spawn(C_185);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.Dropdown.TextButton.LocalScript
local function C_189()
	local script = G2L["189"];
	local isChosen = false

	script.Parent.Activated:Connect(function()
		-- Toggle the selected state
		isChosen = not isChosen

		-- Loop through all GUI buttons in the same parent to reset their colors
		for _, v in pairs(script.Parent.Parent:GetChildren()) do
			if v:IsA('GuiButton') then
				v.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Reset color of all buttons
			end
		end

		if isChosen then
			-- Change background color of the selected button and set SelectedValue
			script.Parent.BackgroundColor3 = Color3.fromRGB(29, 61, 109)
			script.Parent.Parent.Parent.SelectedValue.Value = script.Parent.Text
		else
			-- If not chosen, reset to default state
			script.Parent.Parent.Parent.SelectedValue.Value = "Default"
			script.Parent.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
			isChosen = false
		end
	end)

end;
task.spawn(C_189);
-- StarterGui.SSWorks.Main.ContentProvider.External.ScrollingFrame.Frame.ImageButton.LocalScript
local function C_18d()
	local script = G2L["18d"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Dropdown.Visible = not script.Parent.Parent.Dropdown.Visible
	end)
end;
task.spawn(C_18d);
-- StarterGui.SSWorks.OpenManager
local function C_193()
	local script = G2L["193"];
	-- Services
	local UIS = game:GetService('UserInputService')
	local TS = game:GetService('TweenService')
	local NotifyService = require(script.Parent.Modules.NotificationAPI)

	local isLoader = true

	local Icon = require(script.Icon)

	-- Variables
	local isOpen = false  -- Define as a boolean initially

	-- Auto-run
	Icon.new()
		:setImage(123505499274865)
		:align("Right")
		:bindEvent("deselected", function()
			if isLoader == false then
				isOpen = not isOpen

				if isOpen then
					script.Parent.Main.Visible = true
					TS:Create(script.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 0}):Play()
				else
					task.spawn(function()
						TS:Create(script.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 1}):Play()
						wait(.4)
						script.Parent.Main.Visible = false
						NotifyService:Create('Interface', "Press Left ALT To Open the Interface.", 3)
					end)
				end
			else
				NotifyService:Create('Loader', "Wait for loader to finish", 3)
			end
		end)
		:oneClick()

	-- Left Alt Toggle
	UIS.InputBegan:Connect(function(input, isTyping)
		if isTyping then return end
		if input.KeyCode == Enum.KeyCode.LeftAlt then
			isOpen = not isOpen

			if isOpen then
				script.Parent.Main.Visible = true
				TS:Create(script.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 0}):Play()
			else
				task.spawn(function()
					TS:Create(script.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 1}):Play()
					wait(.4)
					script.Parent.Main.Visible = false
					NotifyService:Create('Interface', "Press Left ALT To Open the Interface.", 3)
				end)
			end
		end
	end)

	-- Key System Visibility Logic
	if game:GetService('Players').LocalPlayer.Name == "OldestRaidAccount" then
		script.Parent.Main.KeySystem.Visible = false
	else
		script.Parent.Main.KeySystem.Visible = true
	end

	task.wait(2)

	-- Show Loader
	TS:Create(script.Parent.Loader, TweenInfo.new(.4), {GroupTransparency = 0}):Play()
	TS:Create(script.Parent.Loader.UIStroke, TweenInfo.new(.4), {Transparency = 0}):Play()
	task.wait(.2)

	-- Animate UI components
	TS:Create(script.Parent.Loader.ImageLabel, TweenInfo.new(.6), {Position = UDim2.new(0.375, 0, 0.298, 0)}):Play()
	TS:Create(script.Parent.Loader.TextLabel, TweenInfo.new(.6), {Position = UDim2.new(0.25, 0, 0.548, 0)}):Play()
	task.wait(.1)

	-- Fade in the elements
	TS:Create(script.Parent.Loader.ImageLabel, TweenInfo.new(.5), {ImageTransparency = 0}):Play()
	TS:Create(script.Parent.Loader.TextLabel, TweenInfo.new(.7), {TextTransparency = 0.4}):Play()

	task.wait(.5)

	-- Update Loading Text
	script.Parent.Loader.TextLabel.Text = "Loading Configuration"
	task.wait(.5)
	NotifyService:Create('Config', "Default Config was loaded.", 3)

	-- Update Module Loading
	script.Parent.Loader.TextLabel.Text = "Loading Modules"
	task.wait(.5)

	-- Final Loader Text
	script.Parent.Loader.TextLabel.Text = "Loaded! Press Left-ALT to Open or Close! Opening, enjoy."


	-- Final Loader Animation Out
	task.wait(2)
	TS:Create(script.Parent.Loader.ImageLabel, TweenInfo.new(.6), {Position = UDim2.new(0.375, 0, 0.098, 0)}):Play()
	TS:Create(script.Parent.Loader.TextLabel, TweenInfo.new(.6), {Position = UDim2.new(0.25, 0, 0.347, 0)}):Play()

	task.wait(.1)

	-- Fade Out Loader
	TS:Create(script.Parent.Loader.ImageLabel, TweenInfo.new(.5), {ImageTransparency = 1}):Play()
	TS:Create(script.Parent.Loader.TextLabel, TweenInfo.new(.7), {TextTransparency = 1}):Play()

	task.wait(.4)

	TS:Create(script.Parent.Loader, TweenInfo.new(.4), {GroupTransparency = 1}):Play()
	TS:Create(script.Parent.Loader.UIStroke, TweenInfo.new(.4), {Transparency = 1}):Play()

	task.wait(.3)

	-- Display Main Interface
	script.Parent.Main.Visible = true
	TS:Create(script.Parent.Main, TweenInfo.new(.4), {GroupTransparency = 0}):Play()

	isLoader = false
end;
task.spawn(C_193);
-- StarterGui.SSWorks.FPlayerUI.Manager
local function C_1b6()
	local script = G2L["1b6"];
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local TweenService = game:GetService("TweenService")
	local Camera = game.Workspace.CurrentCamera

	local localPlayer = Players.LocalPlayer

	-- Fetch the thumbnail (for the current nearest player later)
	local thumbType = Enum.ThumbnailType.HeadShot
	local thumbSize = Enum.ThumbnailSize.Size420x420

	local UserLabel = script.Parent.TextLabel
	local imageLabel = script.Parent.ImageLabel
	local healthBar = script.Parent.HealthBar

	local function getNearestPlayer()
		local closestPlayer = nil
		local shortestDistance = 50  -- Set the max range (40 studs)

		-- Loop through all players to find the closest one within 40 studs
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				local distance = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
				if distance <= shortestDistance then
					shortestDistance = distance
					closestPlayer = player
				end
			end
		end

		return closestPlayer
	end

	local function updateUIForPlayer(targetPlayer)
		-- Update the user thumbnail and name for the target player
		local content, isReady = Players:GetUserThumbnailAsync(targetPlayer.UserId, thumbType, thumbSize)
		imageLabel.Image = content
		UserLabel.Text = targetPlayer.Name
	end

	RunService.Heartbeat:Connect(function()
		-- Ensure the local player character and humanoid exist
		local localCharacter = localPlayer.Character
		if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and localCharacter:FindFirstChild("Humanoid") then
			local targetPlayer = getNearestPlayer()

			if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character:FindFirstChild("Humanoid") then
				local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
				local humanoid = targetPlayer.Character.Humanoid

				-- If the player is dead, find the next closest one
				if humanoid.Health <= 0 then
					targetPlayer = getNearestPlayer()  -- Find the next closest player if the current one is dead
				end

				-- Update the UI to focus on the nearest player
				if targetPlayer then
					updateUIForPlayer(targetPlayer)

					local currentHealth = humanoid.Health
					local maxHealth = humanoid.MaxHealth

					-- Calculate the width of the health bar relative to current health
					local healthPercent = currentHealth / maxHealth
					local barWidth = 200 * healthPercent  -- Full width is 200

					-- Tween the health bar size to smoothly adjust it
					TweenService:Create(healthBar, TweenInfo.new(0.3), {Size = UDim2.new(0, barWidth, 0, 4)}):Play()

					-- Convert HumanoidRootPart's 3D position to 2D screen position
					local rootPosition = humanoidRootPart.Position
					local screenPosition, onScreen = Camera:WorldToViewportPoint(rootPosition)

					-- Check if the HumanoidRootPart is on the player's screen
					if onScreen then
						-- Update the position of script.Parent to follow the target player's HumanoidRootPart in 2D space
						local newPosition = UDim2.new(0, screenPosition.X, 0, screenPosition.Y)
						TweenService:Create(script.Parent, TweenInfo.new(0.1), {Position = newPosition}):Play()
					end

					if humanoid.Health < 1 then
						script.Parent.Position = UDim2.new(10000000000000000,100000000000,10000000000000,10000000000000)
					end
				end
			else
				script.Parent.Position = UDim2.new(10000000000000000,100000000000,10000000000000)
			end
		end
	end)

end;
task.spawn(C_1b6);
-- StarterGui.SSWorks.AimAssistFrame.LocalScript
local function C_1be()
	local script = G2L["1be"];
	local RunService = game:GetService("RunService")

	RunService.Heartbeat:Connect(function()
		local mouse = game:GetService('Players').LocalPlayer:GetMouse()

		-- Get the screen size to prevent the frame from going off-screen
		local screenWidth = game:GetService("Workspace").CurrentCamera.ViewportSize.X
		local screenHeight = game:GetService("Workspace").CurrentCamera.ViewportSize.Y

		-- Frame size (350x350) - adjust these values if needed
		local frameWidth = 350
		local frameHeight = 350

		-- Calculate new frame position so the mouse is at the center of the frame
		local newX = math.clamp(mouse.X - frameWidth / 2, 0, screenWidth - frameWidth)
		local newY = math.clamp(mouse.Y - frameHeight / 2, 0, screenHeight - frameHeight)

		-- Update the frame position
		script.Parent.Position = UDim2.new(0, newX, 0, newY)
	end)

end;
task.spawn(C_1be);
-- StarterGui.SSWorks.KeyConfig.ChangeKey.SmoothDrag
local function C_1c9()
	local script = G2L["1c9"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));

	local gui = script.Parent

	local dragging
	local dragInput
	local dragStart
	local startPos

	function Lerp(a, b, m)
		return a + (b - a) * m
	end;

	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;

		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_1c9);
-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.LocalScript
local function C_1d6()
	local script = G2L["1d6"];
	script.Parent.Activated:Connect(function()
		if script.Parent.Parent.TextBox.Text ~= "" then
			script.Parent.Parent.Parent.Parent.Configurations.Key.Value = script.Parent.Parent.TextBox.Text
			task.wait(.5)
			script.Parent.Parent.Visible = false
			script.Parent.Parent.TextBox.Text = ""
			require(script.Parent.Parent.Parent.Parent.Modules.NotificationAPI):Create('Key Configuration', "Key was changed.", 3)
		end
	end)
end;
task.spawn(C_1d6);
-- StarterGui.SSWorks.KeyConfig.ChangeKey.TextButton.LocalScript
local function C_1de()
	local script = G2L["1de"];
	script.Parent.Activated:Connect(function()
		script.Parent.Parent.Visible = false
		script.Parent.Parent.TextBox.Text = ""
	end)
end;
task.spawn(C_1de);

return G2L["1"], require;
